module.exports = [
"[project]/node_modules/@iota/wallet-standard/dist/esm/chains.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SUPPORTED_CHAINS",
    ()=>SUPPORTED_CHAINS,
    "isSupportedChain",
    ()=>isSupportedChain
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$wallet$2d$standard$2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$client$2f$network$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/wallet-standard/node_modules/@iota/iota-sdk/dist/esm/client/network.js [app-ssr] (ecmascript)");
;
const SUPPORTED_CHAINS = Object.values((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$wallet$2d$standard$2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$client$2f$network$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAllNetworks"])()).map((network)=>network.chain);
function isSupportedChain(chain) {
    return SUPPORTED_CHAINS.includes(chain) || chain.split(":")[0] === "iota";
}
;
 //# sourceMappingURL=chains.js.map
}),
"[project]/node_modules/@iota/wallet-standard/dist/esm/detect.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isWalletWithRequiredFeatureSet",
    ()=>isWalletWithRequiredFeatureSet
]);
const REQUIRED_FEATURES = [
    "standard:connect",
    "standard:events"
];
function isWalletWithRequiredFeatureSet(wallet, additionalFeatures = []) {
    return [
        ...REQUIRED_FEATURES,
        ...additionalFeatures
    ].every((feature)=>feature in wallet.features);
}
;
 //# sourceMappingURL=detect.js.map
}),
"[project]/node_modules/@iota/wallet-standard/dist/esm/wallet.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "signAndExecuteTransaction",
    ()=>signAndExecuteTransaction,
    "signTransaction",
    ()=>signTransaction
]);
async function signAndExecuteTransaction(wallet, input) {
    if (!wallet.features["iota:signAndExecuteTransaction"]) {
        throw new Error(`Provided wallet (${wallet.name}) does not support the signAndExecuteTransaction feature.`);
    }
    return wallet.features["iota:signAndExecuteTransaction"].signAndExecuteTransaction(input);
}
async function signTransaction(wallet, input) {
    if (!wallet.features["iota:signTransaction"]) {
        throw new Error(`Provided wallet (${wallet.name}) does not support the signTransaction feature.`);
    }
    return wallet.features["iota:signTransaction"].signTransaction(input);
}
;
 //# sourceMappingURL=wallet.js.map
}),
"[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/b58.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fromB58",
    ()=>fromB58,
    "fromBase58",
    ()=>fromBase58,
    "toB58",
    ()=>toB58,
    "toBase58",
    ()=>toBase58
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bs58$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bs58/src/esm/index.js [app-ssr] (ecmascript)");
;
const toBase58 = (buffer)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bs58$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].encode(buffer);
const fromBase58 = (str)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bs58$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].decode(str);
const toB58 = toBase58;
const fromB58 = fromBase58;
;
 //# sourceMappingURL=b58.js.map
}),
"[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/b64.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fromB64",
    ()=>fromB64,
    "fromBase64",
    ()=>fromBase64,
    "toB64",
    ()=>toB64,
    "toBase64",
    ()=>toBase64
]);
function fromBase64(base64String) {
    return Uint8Array.from(atob(base64String), (char)=>char.charCodeAt(0));
}
const CHUNK_SIZE = 8192;
function toBase64(bytes) {
    if (bytes.length < CHUNK_SIZE) {
        return btoa(String.fromCharCode(...bytes));
    }
    let output = "";
    for(let i = 0; i < bytes.length; i += CHUNK_SIZE){
        const chunk = bytes.slice(i, i + CHUNK_SIZE);
        output += String.fromCharCode(...chunk);
    }
    return btoa(output);
}
const toB64 = toBase64;
const fromB64 = fromBase64;
;
 //# sourceMappingURL=b64.js.map
}),
"[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/hex.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fromHEX",
    ()=>fromHEX,
    "fromHex",
    ()=>fromHex,
    "toHEX",
    ()=>toHEX,
    "toHex",
    ()=>toHex
]);
function fromHex(hexStr) {
    const normalized = hexStr.startsWith("0x") ? hexStr.slice(2) : hexStr;
    const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;
    const intArr = padded.match(/.{2}/g)?.map((byte)=>parseInt(byte, 16)) ?? [];
    return Uint8Array.from(intArr);
}
function toHex(bytes) {
    return bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, "0"), "");
}
const toHEX = toHex;
const fromHEX = fromHex;
;
 //# sourceMappingURL=hex.js.map
}),
"[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/utils.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decodeStr",
    ()=>decodeStr,
    "encodeStr",
    ()=>encodeStr,
    "splitGenericParameters",
    ()=>splitGenericParameters
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b58$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/b58.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/b64.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/hex.js [app-ssr] (ecmascript)");
;
;
;
function encodeStr(data, encoding) {
    switch(encoding){
        case "base58":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b58$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toBase58"])(data);
        case "base64":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toBase64"])(data);
        case "hex":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(data);
        default:
            throw new Error("Unsupported encoding, supported values are: base64, hex");
    }
}
function decodeStr(data, encoding) {
    switch(encoding){
        case "base58":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b58$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromBase58"])(data);
        case "base64":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromBase64"])(data);
        case "hex":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromHex"])(data);
        default:
            throw new Error("Unsupported encoding, supported values are: base64, hex");
    }
}
function splitGenericParameters(str, genericSeparators = [
    "<",
    ">"
]) {
    const [left, right] = genericSeparators;
    const tok = [];
    let word = "";
    let nestedAngleBrackets = 0;
    for(let i = 0; i < str.length; i++){
        const char = str[i];
        if (char === left) {
            nestedAngleBrackets++;
        }
        if (char === right) {
            nestedAngleBrackets--;
        }
        if (nestedAngleBrackets === 0 && char === ",") {
            tok.push(word.trim());
            word = "";
            continue;
        }
        word += char;
    }
    tok.push(word.trim());
    return tok;
}
;
 //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@iota/bcs/dist/esm/b58.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fromB58",
    ()=>fromB58,
    "fromBase58",
    ()=>fromBase58,
    "toB58",
    ()=>toB58,
    "toBase58",
    ()=>toBase58
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bs58$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bs58/src/esm/index.js [app-ssr] (ecmascript)");
;
const toBase58 = (buffer)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bs58$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].encode(buffer);
const fromBase58 = (str)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bs58$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].decode(str);
const toB58 = toBase58;
const fromB58 = fromBase58;
;
 //# sourceMappingURL=b58.js.map
}),
"[project]/node_modules/@iota/bcs/dist/esm/b64.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fromB64",
    ()=>fromB64,
    "fromBase64",
    ()=>fromBase64,
    "toB64",
    ()=>toB64,
    "toBase64",
    ()=>toBase64
]);
function fromBase64(base64String) {
    return Uint8Array.from(atob(base64String), (char)=>char.charCodeAt(0));
}
const CHUNK_SIZE = 8192;
function toBase64(bytes) {
    if (bytes.length < CHUNK_SIZE) {
        return btoa(String.fromCharCode(...bytes));
    }
    let output = "";
    for(let i = 0; i < bytes.length; i += CHUNK_SIZE){
        const chunk = bytes.slice(i, i + CHUNK_SIZE);
        output += String.fromCharCode(...chunk);
    }
    return btoa(output);
}
const toB64 = toBase64;
const fromB64 = fromBase64;
;
 //# sourceMappingURL=b64.js.map
}),
"[project]/node_modules/@iota/bcs/dist/esm/hex.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fromHEX",
    ()=>fromHEX,
    "fromHex",
    ()=>fromHex,
    "toHEX",
    ()=>toHEX,
    "toHex",
    ()=>toHex
]);
function fromHex(hexStr) {
    const normalized = hexStr.startsWith("0x") ? hexStr.slice(2) : hexStr;
    const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;
    const intArr = padded.match(/.{2}/g)?.map((byte)=>parseInt(byte, 16)) ?? [];
    return Uint8Array.from(intArr);
}
function toHex(bytes) {
    return bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, "0"), "");
}
const toHEX = toHex;
const fromHEX = fromHex;
;
 //# sourceMappingURL=hex.js.map
}),
"[project]/node_modules/@iota/bcs/dist/esm/uleb.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ulebDecode",
    ()=>ulebDecode,
    "ulebEncode",
    ()=>ulebEncode
]);
function ulebEncode(num) {
    const arr = [];
    let len = 0;
    if (num === 0) {
        return [
            0
        ];
    }
    while(num > 0){
        arr[len] = num & 127;
        if (num >>= 7) {
            arr[len] |= 128;
        }
        len += 1;
    }
    return arr;
}
function ulebDecode(arr) {
    let total = 0;
    let shift = 0;
    let len = 0;
    while(true){
        const byte = arr[len];
        len += 1;
        total |= (byte & 127) << shift;
        if ((byte & 128) === 0) {
            break;
        }
        shift += 7;
    }
    return {
        value: total,
        length: len
    };
}
;
 //# sourceMappingURL=uleb.js.map
}),
"[project]/node_modules/@iota/bcs/dist/esm/reader.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BcsReader",
    ()=>BcsReader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$uleb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/bcs/dist/esm/uleb.js [app-ssr] (ecmascript)");
;
class BcsReader {
    /**
   * @param {Uint8Array} data Data to use as a buffer.
   */ constructor(data){
        this.bytePosition = 0;
        this.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }
    /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */ shift(bytes) {
        this.bytePosition += bytes;
        return this;
    }
    /**
   * Read U8 value from the buffer and shift cursor by 1.
   * @returns
   */ read8() {
        const value = this.dataView.getUint8(this.bytePosition);
        this.shift(1);
        return value;
    }
    /**
   * Read U16 value from the buffer and shift cursor by 2.
   * @returns
   */ read16() {
        const value = this.dataView.getUint16(this.bytePosition, true);
        this.shift(2);
        return value;
    }
    /**
   * Read U32 value from the buffer and shift cursor by 4.
   * @returns
   */ read32() {
        const value = this.dataView.getUint32(this.bytePosition, true);
        this.shift(4);
        return value;
    }
    /**
   * Read U64 value from the buffer and shift cursor by 8.
   * @returns
   */ read64() {
        const value1 = this.read32();
        const value2 = this.read32();
        const result = value2.toString(16) + value1.toString(16).padStart(8, "0");
        return BigInt("0x" + result).toString(10);
    }
    /**
   * Read U128 value from the buffer and shift cursor by 16.
   */ read128() {
        const value1 = BigInt(this.read64());
        const value2 = BigInt(this.read64());
        const result = value2.toString(16) + value1.toString(16).padStart(16, "0");
        return BigInt("0x" + result).toString(10);
    }
    /**
   * Read U128 value from the buffer and shift cursor by 32.
   * @returns
   */ read256() {
        const value1 = BigInt(this.read128());
        const value2 = BigInt(this.read128());
        const result = value2.toString(16) + value1.toString(16).padStart(32, "0");
        return BigInt("0x" + result).toString(10);
    }
    /**
   * Read `num` number of bytes from the buffer and shift cursor by `num`.
   * @param num Number of bytes to read.
   */ readBytes(num) {
        const start = this.bytePosition + this.dataView.byteOffset;
        const value = new Uint8Array(this.dataView.buffer, start, num);
        this.shift(num);
        return value;
    }
    /**
   * Read ULEB value - an integer of varying size. Used for enum indexes and
   * vector lengths.
   * @returns {Number} The ULEB value.
   */ readULEB() {
        const start = this.bytePosition + this.dataView.byteOffset;
        const buffer = new Uint8Array(this.dataView.buffer, start);
        const { value, length } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$uleb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ulebDecode"])(buffer);
        this.shift(length);
        return value;
    }
    /**
   * Read a BCS vector: read a length and then apply function `cb` X times
   * where X is the length of the vector, defined as ULEB in BCS bytes.
   * @param cb Callback to process elements of vector.
   * @returns {Array<Any>} Array of the resulting values, returned by callback.
   */ readVec(cb) {
        const length = this.readULEB();
        const result = [];
        for(let i = 0; i < length; i++){
            result.push(cb(this, i, length));
        }
        return result;
    }
}
;
 //# sourceMappingURL=reader.js.map
}),
"[project]/node_modules/@iota/bcs/dist/esm/utils.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decodeStr",
    ()=>decodeStr,
    "encodeStr",
    ()=>encodeStr,
    "splitGenericParameters",
    ()=>splitGenericParameters
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b58$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/bcs/dist/esm/b58.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/bcs/dist/esm/b64.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/bcs/dist/esm/hex.js [app-ssr] (ecmascript)");
;
;
;
function encodeStr(data, encoding) {
    switch(encoding){
        case "base58":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b58$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toBase58"])(data);
        case "base64":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toBase64"])(data);
        case "hex":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(data);
        default:
            throw new Error("Unsupported encoding, supported values are: base64, hex");
    }
}
function decodeStr(data, encoding) {
    switch(encoding){
        case "base58":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b58$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromBase58"])(data);
        case "base64":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromBase64"])(data);
        case "hex":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromHex"])(data);
        default:
            throw new Error("Unsupported encoding, supported values are: base64, hex");
    }
}
function splitGenericParameters(str, genericSeparators = [
    "<",
    ">"
]) {
    const [left, right] = genericSeparators;
    const tok = [];
    let word = "";
    let nestedAngleBrackets = 0;
    for(let i = 0; i < str.length; i++){
        const char = str[i];
        if (char === left) {
            nestedAngleBrackets++;
        }
        if (char === right) {
            nestedAngleBrackets--;
        }
        if (nestedAngleBrackets === 0 && char === ",") {
            tok.push(word.trim());
            word = "";
            continue;
        }
        word += char;
    }
    tok.push(word.trim());
    return tok;
}
;
 //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@iota/bcs/dist/esm/writer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BcsWriter",
    ()=>BcsWriter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$uleb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/bcs/dist/esm/uleb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/bcs/dist/esm/utils.js [app-ssr] (ecmascript)");
;
;
class BcsWriter {
    constructor({ initialSize = 1024, maxSize = Infinity, allocateSize = 1024 } = {}){
        this.bytePosition = 0;
        this.size = initialSize;
        this.maxSize = maxSize;
        this.allocateSize = allocateSize;
        this.dataView = new DataView(new ArrayBuffer(initialSize));
    }
    ensureSizeOrGrow(bytes) {
        const requiredSize = this.bytePosition + bytes;
        if (requiredSize > this.size) {
            const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);
            if (requiredSize > nextSize) {
                throw new Error(`SizeLimitExceeded: Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`);
            }
            this.size = nextSize;
            const nextBuffer = new ArrayBuffer(this.size);
            new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));
            this.dataView = new DataView(nextBuffer);
        }
    }
    /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */ shift(bytes) {
        this.bytePosition += bytes;
        return this;
    }
    /**
   * Write a U8 value into a buffer and shift cursor position by 1.
   * @param {Number} value Value to write.
   * @returns {this}
   */ write8(value) {
        this.ensureSizeOrGrow(1);
        this.dataView.setUint8(this.bytePosition, Number(value));
        return this.shift(1);
    }
    /**
   * Write a U16 value into a buffer and shift cursor position by 2.
   * @param {Number} value Value to write.
   * @returns {this}
   */ write16(value) {
        this.ensureSizeOrGrow(2);
        this.dataView.setUint16(this.bytePosition, Number(value), true);
        return this.shift(2);
    }
    /**
   * Write a U32 value into a buffer and shift cursor position by 4.
   * @param {Number} value Value to write.
   * @returns {this}
   */ write32(value) {
        this.ensureSizeOrGrow(4);
        this.dataView.setUint32(this.bytePosition, Number(value), true);
        return this.shift(4);
    }
    /**
   * Write a U64 value into a buffer and shift cursor position by 8.
   * @param {bigint} value Value to write.
   * @returns {this}
   */ write64(value) {
        toLittleEndian(BigInt(value), 8).forEach((el)=>this.write8(el));
        return this;
    }
    /**
   * Write a U128 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */ write128(value) {
        toLittleEndian(BigInt(value), 16).forEach((el)=>this.write8(el));
        return this;
    }
    /**
   * Write a U256 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */ write256(value) {
        toLittleEndian(BigInt(value), 32).forEach((el)=>this.write8(el));
        return this;
    }
    /**
   * Write a ULEB value into a buffer and shift cursor position by number of bytes
   * written.
   * @param {Number} value Value to write.
   * @returns {this}
   */ writeULEB(value) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$uleb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ulebEncode"])(value).forEach((el)=>this.write8(el));
        return this;
    }
    /**
   * Write a vector into a buffer by first writing the vector length and then calling
   * a callback on each passed value.
   *
   * @param {Array<Any>} vector Array of elements to write.
   * @param {WriteVecCb} cb Callback to call on each element of the vector.
   * @returns {this}
   */ writeVec(vector, cb) {
        this.writeULEB(vector.length);
        Array.from(vector).forEach((el, i)=>cb(this, el, i, vector.length));
        return this;
    }
    /**
   * Adds support for iterations over the object.
   * @returns {Uint8Array}
   */ *[Symbol.iterator]() {
        for(let i = 0; i < this.bytePosition; i++){
            yield this.dataView.getUint8(i);
        }
        return this.toBytes();
    }
    /**
   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).
   * @returns {Uint8Array} Resulting bcs.
   */ toBytes() {
        return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
    }
    /**
   * Represent data as 'hex' or 'base64'
   * @param encoding Encoding to use: 'base64' or 'hex'
   */ toString(encoding) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodeStr"])(this.toBytes(), encoding);
    }
}
function toLittleEndian(bigint, size) {
    const result = new Uint8Array(size);
    let i = 0;
    while(bigint > 0){
        result[i] = Number(bigint % BigInt(256));
        bigint = bigint / BigInt(256);
        i += 1;
    }
    return result;
}
;
 //# sourceMappingURL=writer.js.map
}),
"[project]/node_modules/@iota/bcs/dist/esm/bcs-type.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BcsType",
    ()=>BcsType,
    "SerializedBcs",
    ()=>SerializedBcs,
    "bigUIntBcsType",
    ()=>bigUIntBcsType,
    "dynamicSizeBcsType",
    ()=>dynamicSizeBcsType,
    "fixedSizeBcsType",
    ()=>fixedSizeBcsType,
    "isSerializedBcs",
    ()=>isSerializedBcs,
    "lazyBcsType",
    ()=>lazyBcsType,
    "stringLikeBcsType",
    ()=>stringLikeBcsType,
    "uIntBcsType",
    ()=>uIntBcsType
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b58$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/bcs/dist/esm/b58.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/bcs/dist/esm/b64.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/bcs/dist/esm/hex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$reader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/bcs/dist/esm/reader.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$uleb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/bcs/dist/esm/uleb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$writer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/bcs/dist/esm/writer.js [app-ssr] (ecmascript)");
var __typeError = (msg)=>{
    throw TypeError(msg);
};
var __accessCheck = (obj, member, msg)=>member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter)=>(__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value)=>member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter)=>(__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _write, _serialize, _schema, _bytes;
;
;
;
;
;
;
const _BcsType = class _BcsType {
    constructor(options){
        __privateAdd(this, _write);
        __privateAdd(this, _serialize);
        this.name = options.name;
        this.read = options.read;
        this.serializedSize = options.serializedSize ?? (()=>null);
        __privateSet(this, _write, options.write);
        __privateSet(this, _serialize, options.serialize ?? ((value, options2)=>{
            const writer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$writer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BcsWriter"]({
                initialSize: this.serializedSize(value) ?? void 0,
                ...options2
            });
            __privateGet(this, _write).call(this, value, writer);
            return writer.toBytes();
        }));
        this.validate = options.validate ?? (()=>{});
    }
    write(value, writer) {
        this.validate(value);
        __privateGet(this, _write).call(this, value, writer);
    }
    serialize(value, options) {
        this.validate(value);
        return new SerializedBcs(this, __privateGet(this, _serialize).call(this, value, options));
    }
    parse(bytes) {
        const reader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$reader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BcsReader"](bytes);
        return this.read(reader);
    }
    fromHex(hex) {
        return this.parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromHex"])(hex));
    }
    fromBase58(b64) {
        return this.parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b58$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromBase58"])(b64));
    }
    fromBase64(b64) {
        return this.parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromBase64"])(b64));
    }
    transform({ name, input, output, validate }) {
        return new _BcsType({
            name: name ?? this.name,
            read: (reader)=>output ? output(this.read(reader)) : this.read(reader),
            write: (value, writer)=>__privateGet(this, _write).call(this, input ? input(value) : value, writer),
            serializedSize: (value)=>this.serializedSize(input ? input(value) : value),
            serialize: (value, options)=>__privateGet(this, _serialize).call(this, input ? input(value) : value, options),
            validate: (value)=>{
                validate?.(value);
                this.validate(input ? input(value) : value);
            }
        });
    }
};
_write = new WeakMap();
_serialize = new WeakMap();
let BcsType = _BcsType;
const SERIALIZED_BCS_BRAND = Symbol.for("@iota/serialized-bcs");
function isSerializedBcs(obj) {
    return !!obj && typeof obj === "object" && obj[SERIALIZED_BCS_BRAND] === true;
}
class SerializedBcs {
    constructor(type, schema){
        __privateAdd(this, _schema);
        __privateAdd(this, _bytes);
        __privateSet(this, _schema, type);
        __privateSet(this, _bytes, schema);
    }
    // Used to brand SerializedBcs so that they can be identified, even between multiple copies
    // of the @iota/bcs package are installed
    get [SERIALIZED_BCS_BRAND]() {
        return true;
    }
    toBytes() {
        return __privateGet(this, _bytes);
    }
    toHex() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(__privateGet(this, _bytes));
    }
    toBase64() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toBase64"])(__privateGet(this, _bytes));
    }
    toBase58() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b58$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toBase58"])(__privateGet(this, _bytes));
    }
    parse() {
        return __privateGet(this, _schema).parse(__privateGet(this, _bytes));
    }
}
_schema = new WeakMap();
_bytes = new WeakMap();
function fixedSizeBcsType({ size, ...options }) {
    return new BcsType({
        ...options,
        serializedSize: ()=>size
    });
}
function uIntBcsType({ readMethod, writeMethod, ...options }) {
    return fixedSizeBcsType({
        ...options,
        read: (reader)=>reader[readMethod](),
        write: (value, writer)=>writer[writeMethod](value),
        validate: (value)=>{
            if (value < 0 || value > options.maxValue) {
                throw new TypeError(`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`);
            }
            options.validate?.(value);
        }
    });
}
function bigUIntBcsType({ readMethod, writeMethod, ...options }) {
    return fixedSizeBcsType({
        ...options,
        read: (reader)=>reader[readMethod](),
        write: (value, writer)=>writer[writeMethod](BigInt(value)),
        validate: (val)=>{
            const value = BigInt(val);
            if (value < 0 || value > options.maxValue) {
                throw new TypeError(`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`);
            }
            options.validate?.(value);
        }
    });
}
function dynamicSizeBcsType({ serialize, ...options }) {
    const type = new BcsType({
        ...options,
        serialize,
        write: (value, writer)=>{
            for (const byte of type.serialize(value).toBytes()){
                writer.write8(byte);
            }
        }
    });
    return type;
}
function stringLikeBcsType({ toBytes, fromBytes, ...options }) {
    return new BcsType({
        ...options,
        read: (reader)=>{
            const length = reader.readULEB();
            const bytes = reader.readBytes(length);
            return fromBytes(bytes);
        },
        write: (hex, writer)=>{
            const bytes = toBytes(hex);
            writer.writeULEB(bytes.length);
            for(let i = 0; i < bytes.length; i++){
                writer.write8(bytes[i]);
            }
        },
        serialize: (value)=>{
            const bytes = toBytes(value);
            const size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$uleb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ulebEncode"])(bytes.length);
            const result = new Uint8Array(size.length + bytes.length);
            result.set(size, 0);
            result.set(bytes, size.length);
            return result;
        },
        validate: (value)=>{
            if (typeof value !== "string") {
                throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);
            }
            options.validate?.(value);
        }
    });
}
function lazyBcsType(cb) {
    let lazyType = null;
    function getType() {
        if (!lazyType) {
            lazyType = cb();
        }
        return lazyType;
    }
    return new BcsType({
        name: "lazy",
        read: (data)=>getType().read(data),
        serializedSize: (value)=>getType().serializedSize(value),
        write: (value, writer)=>getType().write(value, writer),
        serialize: (value, options)=>getType().serialize(value, options).toBytes()
    });
}
;
 //# sourceMappingURL=bcs-type.js.map
}),
"[project]/node_modules/@iota/bcs/dist/esm/bcs.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bcs",
    ()=>bcs
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/bcs/dist/esm/bcs-type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$uleb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/bcs/dist/esm/uleb.js [app-ssr] (ecmascript)");
;
;
const bcs = {
    /**
   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.
   * @example
   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]
   */ u8 (options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uIntBcsType"])({
            name: "u8",
            readMethod: "read8",
            writeMethod: "write8",
            size: 1,
            maxValue: 2 ** 8 - 1,
            ...options
        });
    },
    /**
   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.
   * @example
   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]
   */ u16 (options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uIntBcsType"])({
            name: "u16",
            readMethod: "read16",
            writeMethod: "write16",
            size: 2,
            maxValue: 2 ** 16 - 1,
            ...options
        });
    },
    /**
   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.
   * @example
   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]
   */ u32 (options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uIntBcsType"])({
            name: "u32",
            readMethod: "read32",
            writeMethod: "write32",
            size: 4,
            maxValue: 2 ** 32 - 1,
            ...options
        });
    },
    /**
   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.
   * @example
   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]
   */ u64 (options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bigUIntBcsType"])({
            name: "u64",
            readMethod: "read64",
            writeMethod: "write64",
            size: 8,
            maxValue: 2n ** 64n - 1n,
            ...options
        });
    },
    /**
   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.
   * @example
   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */ u128 (options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bigUIntBcsType"])({
            name: "u128",
            readMethod: "read128",
            writeMethod: "write128",
            size: 16,
            maxValue: 2n ** 128n - 1n,
            ...options
        });
    },
    /**
   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.
   * @example
   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */ u256 (options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bigUIntBcsType"])({
            name: "u256",
            readMethod: "read256",
            writeMethod: "write256",
            size: 32,
            maxValue: 2n ** 256n - 1n,
            ...options
        });
    },
    /**
   * Creates a BcsType that can be used to read and write boolean values.
   * @example
   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]
   */ bool (options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fixedSizeBcsType"])({
            name: "bool",
            size: 1,
            read: (reader)=>reader.read8() === 1,
            write: (value, writer)=>writer.write8(value ? 1 : 0),
            ...options,
            validate: (value)=>{
                options?.validate?.(value);
                if (typeof value !== "boolean") {
                    throw new TypeError(`Expected boolean, found ${typeof value}`);
                }
            }
        });
    },
    /**
   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers
   * @example
   *
   */ uleb128 (options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["dynamicSizeBcsType"])({
            name: "uleb128",
            read: (reader)=>reader.readULEB(),
            serialize: (value)=>{
                return Uint8Array.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$uleb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ulebEncode"])(value));
            },
            ...options
        });
    },
    /**
   * Creates a BcsType representing a fixed length byte array
   * @param size The number of bytes this types represents
   * @example
   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]
   */ bytes (size, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fixedSizeBcsType"])({
            name: `bytes[${size}]`,
            size,
            read: (reader)=>reader.readBytes(size),
            write: (value, writer)=>{
                for(let i = 0; i < size; i++){
                    writer.write8(value[i] ?? 0);
                }
            },
            ...options,
            validate: (value)=>{
                options?.validate?.(value);
                if (!value || typeof value !== "object" || !("length" in value)) {
                    throw new TypeError(`Expected array, found ${typeof value}`);
                }
                if (value.length !== size) {
                    throw new TypeError(`Expected array of length ${size}, found ${value.length}`);
                }
            }
        });
    },
    /**
   * Creates a BcsType representing a variable length byte array
   *
   * @example
   * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]
   */ byteVector (options) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BcsType"]({
            name: `bytesVector`,
            read: (reader)=>{
                const length = reader.readULEB();
                return reader.readBytes(length);
            },
            write: (value, writer)=>{
                const array = new Uint8Array(value);
                writer.writeULEB(array.length);
                for(let i = 0; i < array.length; i++){
                    writer.write8(array[i] ?? 0);
                }
            },
            ...options,
            serializedSize: (value)=>{
                const length = "length" in value ? value.length : null;
                return length == null ? null : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$uleb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ulebEncode"])(length).length + length;
            },
            validate: (value)=>{
                options?.validate?.(value);
                if (!value || typeof value !== "object" || !("length" in value)) {
                    throw new TypeError(`Expected array, found ${typeof value}`);
                }
            }
        });
    },
    /**
   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded
   * @example
   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]
   */ string (options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringLikeBcsType"])({
            name: "string",
            toBytes: (value)=>new TextEncoder().encode(value),
            fromBytes: (bytes)=>new TextDecoder().decode(bytes),
            ...options
        });
    },
    /**
   * Creates a BcsType that represents a fixed length array of a given type
   * @param size The number of elements in the array
   * @param type The BcsType of each element in the array
   * @example
   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]
   */ fixedArray (size, type, options) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BcsType"]({
            name: `${type.name}[${size}]`,
            read: (reader)=>{
                const result = new Array(size);
                for(let i = 0; i < size; i++){
                    result[i] = type.read(reader);
                }
                return result;
            },
            write: (value, writer)=>{
                for (const item of value){
                    type.write(item, writer);
                }
            },
            ...options,
            validate: (value)=>{
                options?.validate?.(value);
                if (!value || typeof value !== "object" || !("length" in value)) {
                    throw new TypeError(`Expected array, found ${typeof value}`);
                }
                if (value.length !== size) {
                    throw new TypeError(`Expected array of length ${size}, found ${value.length}`);
                }
            }
        });
    },
    /**
   * Creates a BcsType representing an optional value
   * @param type The BcsType of the optional value
   * @example
   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]
   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]
   */ option (type) {
        return bcs.enum(`Option<${type.name}>`, {
            None: null,
            Some: type
        }).transform({
            input: (value)=>{
                if (value == null) {
                    return {
                        None: true
                    };
                }
                return {
                    Some: value
                };
            },
            output: (value)=>{
                if (value.$kind === "Some") {
                    return value.Some;
                }
                return null;
            }
        });
    },
    /**
   * Creates a BcsType representing a variable length vector of a given type
   * @param type The BcsType of each element in the vector
   *
   * @example
   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]
   */ vector (type, options) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BcsType"]({
            name: `vector<${type.name}>`,
            read: (reader)=>{
                const length = reader.readULEB();
                const result = new Array(length);
                for(let i = 0; i < length; i++){
                    result[i] = type.read(reader);
                }
                return result;
            },
            write: (value, writer)=>{
                writer.writeULEB(value.length);
                for (const item of value){
                    type.write(item, writer);
                }
            },
            ...options,
            validate: (value)=>{
                options?.validate?.(value);
                if (!value || typeof value !== "object" || !("length" in value)) {
                    throw new TypeError(`Expected array, found ${typeof value}`);
                }
            }
        });
    },
    /**
   * Creates a BcsType representing a tuple of a given set of types
   * @param types The BcsTypes for each element in the tuple
   *
   * @example
   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])
   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]
   */ tuple (types, options) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BcsType"]({
            name: `(${types.map((t)=>t.name).join(", ")})`,
            serializedSize: (values)=>{
                let total = 0;
                for(let i = 0; i < types.length; i++){
                    const size = types[i].serializedSize(values[i]);
                    if (size == null) {
                        return null;
                    }
                    total += size;
                }
                return total;
            },
            read: (reader)=>{
                const result = [];
                for (const type of types){
                    result.push(type.read(reader));
                }
                return result;
            },
            write: (value, writer)=>{
                for(let i = 0; i < types.length; i++){
                    types[i].write(value[i], writer);
                }
            },
            ...options,
            validate: (value)=>{
                options?.validate?.(value);
                if (!Array.isArray(value)) {
                    throw new TypeError(`Expected array, found ${typeof value}`);
                }
                if (value.length !== types.length) {
                    throw new TypeError(`Expected array of length ${types.length}, found ${value.length}`);
                }
            }
        });
    },
    /**
   * Creates a BcsType representing a struct of a given set of fields
   * @param name The name of the struct
   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized
   *
   * @example
   * const struct = bcs.struct('MyStruct', {
   *  a: bcs.u8(),
   *  b: bcs.string(),
   * })
   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   */ struct (name, fields, options) {
        const canonicalOrder = Object.entries(fields);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BcsType"]({
            name,
            serializedSize: (values)=>{
                let total = 0;
                for (const [field, type] of canonicalOrder){
                    const size = type.serializedSize(values[field]);
                    if (size == null) {
                        return null;
                    }
                    total += size;
                }
                return total;
            },
            read: (reader)=>{
                const result = {};
                for (const [field, type] of canonicalOrder){
                    result[field] = type.read(reader);
                }
                return result;
            },
            write: (value, writer)=>{
                for (const [field, type] of canonicalOrder){
                    type.write(value[field], writer);
                }
            },
            ...options,
            validate: (value)=>{
                options?.validate?.(value);
                if (typeof value !== "object" || value == null) {
                    throw new TypeError(`Expected object, found ${typeof value}`);
                }
            }
        });
    },
    /**
   * Creates a BcsType representing an enum of a given set of options
   * @param name The name of the enum
   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.
   * null can be used to represent a variant with no data.
   *
   * @example
   * const enum = bcs.enum('MyEnum', {
   *   A: bcs.u8(),
   *   B: bcs.string(),
   *   C: null,
   * })
   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]
   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]
   */ enum (name, values, options) {
        const canonicalOrder = Object.entries(values);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BcsType"]({
            name,
            read: (reader)=>{
                const index = reader.readULEB();
                const enumEntry = canonicalOrder[index];
                if (!enumEntry) {
                    throw new TypeError(`Unknown value ${index} for enum ${name}`);
                }
                const [kind, type] = enumEntry;
                return {
                    [kind]: type?.read(reader) ?? true,
                    $kind: kind
                };
            },
            write: (value, writer)=>{
                const [name2, val] = Object.entries(value).filter(([name3])=>Object.hasOwn(values, name3))[0];
                for(let i = 0; i < canonicalOrder.length; i++){
                    const [optionName, optionType] = canonicalOrder[i];
                    if (optionName === name2) {
                        writer.writeULEB(i);
                        optionType?.write(val, writer);
                        return;
                    }
                }
            },
            ...options,
            validate: (value)=>{
                options?.validate?.(value);
                if (typeof value !== "object" || value == null) {
                    throw new TypeError(`Expected object, found ${typeof value}`);
                }
                const keys = Object.keys(value).filter((k)=>value[k] !== void 0 && Object.hasOwn(values, k));
                if (keys.length !== 1) {
                    throw new TypeError(`Expected object with one key, but found ${keys.length} for type ${name}}`);
                }
                const [variant] = keys;
                if (!Object.hasOwn(values, variant)) {
                    throw new TypeError(`Invalid enum variant ${variant}`);
                }
            }
        });
    },
    /**
   * Creates a BcsType representing a map of a given key and value type
   * @param keyType The BcsType of the key
   * @param valueType The BcsType of the value
   * @example
   * const map = bcs.map(bcs.u8(), bcs.string())
   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]
   */ map (keyType, valueType) {
        return bcs.vector(bcs.tuple([
            keyType,
            valueType
        ])).transform({
            name: `Map<${keyType.name}, ${valueType.name}>`,
            input: (value)=>{
                return [
                    ...value.entries()
                ];
            },
            output: (value)=>{
                const result = /* @__PURE__ */ new Map();
                for (const [key, val] of value){
                    result.set(key, val);
                }
                return result;
            }
        });
    },
    /**
   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.
   * @param cb A callback that returns the BcsType
   */ lazy (cb) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lazyBcsType"])(cb);
    }
};
;
 //# sourceMappingURL=bcs.js.map
}),
"[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/uleb.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ulebDecode",
    ()=>ulebDecode,
    "ulebEncode",
    ()=>ulebEncode
]);
function ulebEncode(num) {
    const arr = [];
    let len = 0;
    if (num === 0) {
        return [
            0
        ];
    }
    while(num > 0){
        arr[len] = num & 127;
        if (num >>= 7) {
            arr[len] |= 128;
        }
        len += 1;
    }
    return arr;
}
function ulebDecode(arr) {
    let total = 0;
    let shift = 0;
    let len = 0;
    while(true){
        const byte = arr[len];
        len += 1;
        total |= (byte & 127) << shift;
        if ((byte & 128) === 0) {
            break;
        }
        shift += 7;
    }
    return {
        value: total,
        length: len
    };
}
;
 //# sourceMappingURL=uleb.js.map
}),
"[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/reader.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BcsReader",
    ()=>BcsReader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$uleb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/uleb.js [app-ssr] (ecmascript)");
;
class BcsReader {
    /**
   * @param {Uint8Array} data Data to use as a buffer.
   */ constructor(data){
        this.bytePosition = 0;
        this.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }
    /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */ shift(bytes) {
        this.bytePosition += bytes;
        return this;
    }
    /**
   * Read U8 value from the buffer and shift cursor by 1.
   * @returns
   */ read8() {
        const value = this.dataView.getUint8(this.bytePosition);
        this.shift(1);
        return value;
    }
    /**
   * Read U16 value from the buffer and shift cursor by 2.
   * @returns
   */ read16() {
        const value = this.dataView.getUint16(this.bytePosition, true);
        this.shift(2);
        return value;
    }
    /**
   * Read U32 value from the buffer and shift cursor by 4.
   * @returns
   */ read32() {
        const value = this.dataView.getUint32(this.bytePosition, true);
        this.shift(4);
        return value;
    }
    /**
   * Read U64 value from the buffer and shift cursor by 8.
   * @returns
   */ read64() {
        const value1 = this.read32();
        const value2 = this.read32();
        const result = value2.toString(16) + value1.toString(16).padStart(8, "0");
        return BigInt("0x" + result).toString(10);
    }
    /**
   * Read U128 value from the buffer and shift cursor by 16.
   */ read128() {
        const value1 = BigInt(this.read64());
        const value2 = BigInt(this.read64());
        const result = value2.toString(16) + value1.toString(16).padStart(16, "0");
        return BigInt("0x" + result).toString(10);
    }
    /**
   * Read U128 value from the buffer and shift cursor by 32.
   * @returns
   */ read256() {
        const value1 = BigInt(this.read128());
        const value2 = BigInt(this.read128());
        const result = value2.toString(16) + value1.toString(16).padStart(32, "0");
        return BigInt("0x" + result).toString(10);
    }
    /**
   * Read `num` number of bytes from the buffer and shift cursor by `num`.
   * @param num Number of bytes to read.
   */ readBytes(num) {
        const start = this.bytePosition + this.dataView.byteOffset;
        const value = new Uint8Array(this.dataView.buffer, start, num);
        this.shift(num);
        return value;
    }
    /**
   * Read ULEB value - an integer of varying size. Used for enum indexes and
   * vector lengths.
   * @returns {Number} The ULEB value.
   */ readULEB() {
        const start = this.bytePosition + this.dataView.byteOffset;
        const buffer = new Uint8Array(this.dataView.buffer, start);
        const { value, length } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$uleb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ulebDecode"])(buffer);
        this.shift(length);
        return value;
    }
    /**
   * Read a BCS vector: read a length and then apply function `cb` X times
   * where X is the length of the vector, defined as ULEB in BCS bytes.
   * @param cb Callback to process elements of vector.
   * @returns {Array<Any>} Array of the resulting values, returned by callback.
   */ readVec(cb) {
        const length = this.readULEB();
        const result = [];
        for(let i = 0; i < length; i++){
            result.push(cb(this, i, length));
        }
        return result;
    }
}
;
 //# sourceMappingURL=reader.js.map
}),
"[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/writer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BcsWriter",
    ()=>BcsWriter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$uleb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/uleb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/utils.js [app-ssr] (ecmascript)");
;
;
class BcsWriter {
    constructor({ initialSize = 1024, maxSize = Infinity, allocateSize = 1024 } = {}){
        this.bytePosition = 0;
        this.size = initialSize;
        this.maxSize = maxSize;
        this.allocateSize = allocateSize;
        this.dataView = new DataView(new ArrayBuffer(initialSize));
    }
    ensureSizeOrGrow(bytes) {
        const requiredSize = this.bytePosition + bytes;
        if (requiredSize > this.size) {
            const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);
            if (requiredSize > nextSize) {
                throw new Error(`SizeLimitExceeded: Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`);
            }
            this.size = nextSize;
            const nextBuffer = new ArrayBuffer(this.size);
            new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));
            this.dataView = new DataView(nextBuffer);
        }
    }
    /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */ shift(bytes) {
        this.bytePosition += bytes;
        return this;
    }
    /**
   * Write a U8 value into a buffer and shift cursor position by 1.
   * @param {Number} value Value to write.
   * @returns {this}
   */ write8(value) {
        this.ensureSizeOrGrow(1);
        this.dataView.setUint8(this.bytePosition, Number(value));
        return this.shift(1);
    }
    /**
   * Write a U16 value into a buffer and shift cursor position by 2.
   * @param {Number} value Value to write.
   * @returns {this}
   */ write16(value) {
        this.ensureSizeOrGrow(2);
        this.dataView.setUint16(this.bytePosition, Number(value), true);
        return this.shift(2);
    }
    /**
   * Write a U32 value into a buffer and shift cursor position by 4.
   * @param {Number} value Value to write.
   * @returns {this}
   */ write32(value) {
        this.ensureSizeOrGrow(4);
        this.dataView.setUint32(this.bytePosition, Number(value), true);
        return this.shift(4);
    }
    /**
   * Write a U64 value into a buffer and shift cursor position by 8.
   * @param {bigint} value Value to write.
   * @returns {this}
   */ write64(value) {
        toLittleEndian(BigInt(value), 8).forEach((el)=>this.write8(el));
        return this;
    }
    /**
   * Write a U128 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */ write128(value) {
        toLittleEndian(BigInt(value), 16).forEach((el)=>this.write8(el));
        return this;
    }
    /**
   * Write a U256 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */ write256(value) {
        toLittleEndian(BigInt(value), 32).forEach((el)=>this.write8(el));
        return this;
    }
    /**
   * Write a ULEB value into a buffer and shift cursor position by number of bytes
   * written.
   * @param {Number} value Value to write.
   * @returns {this}
   */ writeULEB(value) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$uleb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ulebEncode"])(value).forEach((el)=>this.write8(el));
        return this;
    }
    /**
   * Write a vector into a buffer by first writing the vector length and then calling
   * a callback on each passed value.
   *
   * @param {Array<Any>} vector Array of elements to write.
   * @param {WriteVecCb} cb Callback to call on each element of the vector.
   * @returns {this}
   */ writeVec(vector, cb) {
        this.writeULEB(vector.length);
        Array.from(vector).forEach((el, i)=>cb(this, el, i, vector.length));
        return this;
    }
    /**
   * Adds support for iterations over the object.
   * @returns {Uint8Array}
   */ *[Symbol.iterator]() {
        for(let i = 0; i < this.bytePosition; i++){
            yield this.dataView.getUint8(i);
        }
        return this.toBytes();
    }
    /**
   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).
   * @returns {Uint8Array} Resulting bcs.
   */ toBytes() {
        return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
    }
    /**
   * Represent data as 'hex' or 'base64'
   * @param encoding Encoding to use: 'base64' or 'hex'
   */ toString(encoding) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodeStr"])(this.toBytes(), encoding);
    }
}
function toLittleEndian(bigint, size) {
    const result = new Uint8Array(size);
    let i = 0;
    while(bigint > 0){
        result[i] = Number(bigint % BigInt(256));
        bigint = bigint / BigInt(256);
        i += 1;
    }
    return result;
}
;
 //# sourceMappingURL=writer.js.map
}),
"[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/bcs-type.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BcsType",
    ()=>BcsType,
    "SerializedBcs",
    ()=>SerializedBcs,
    "bigUIntBcsType",
    ()=>bigUIntBcsType,
    "dynamicSizeBcsType",
    ()=>dynamicSizeBcsType,
    "fixedSizeBcsType",
    ()=>fixedSizeBcsType,
    "isSerializedBcs",
    ()=>isSerializedBcs,
    "lazyBcsType",
    ()=>lazyBcsType,
    "stringLikeBcsType",
    ()=>stringLikeBcsType,
    "uIntBcsType",
    ()=>uIntBcsType
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b58$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/b58.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/b64.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/hex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$reader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/reader.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$uleb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/uleb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$writer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/writer.js [app-ssr] (ecmascript)");
var __typeError = (msg)=>{
    throw TypeError(msg);
};
var __accessCheck = (obj, member, msg)=>member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter)=>(__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value)=>member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter)=>(__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _write, _serialize, _schema, _bytes;
;
;
;
;
;
;
const _BcsType = class _BcsType {
    constructor(options){
        __privateAdd(this, _write);
        __privateAdd(this, _serialize);
        this.name = options.name;
        this.read = options.read;
        this.serializedSize = options.serializedSize ?? (()=>null);
        __privateSet(this, _write, options.write);
        __privateSet(this, _serialize, options.serialize ?? ((value, options2)=>{
            const writer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$writer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BcsWriter"]({
                initialSize: this.serializedSize(value) ?? void 0,
                ...options2
            });
            __privateGet(this, _write).call(this, value, writer);
            return writer.toBytes();
        }));
        this.validate = options.validate ?? (()=>{});
    }
    write(value, writer) {
        this.validate(value);
        __privateGet(this, _write).call(this, value, writer);
    }
    serialize(value, options) {
        this.validate(value);
        return new SerializedBcs(this, __privateGet(this, _serialize).call(this, value, options));
    }
    parse(bytes) {
        const reader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$reader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BcsReader"](bytes);
        return this.read(reader);
    }
    fromHex(hex) {
        return this.parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromHex"])(hex));
    }
    fromBase58(b64) {
        return this.parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b58$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromBase58"])(b64));
    }
    fromBase64(b64) {
        return this.parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromBase64"])(b64));
    }
    transform({ name, input, output, validate }) {
        return new _BcsType({
            name: name ?? this.name,
            read: (reader)=>output ? output(this.read(reader)) : this.read(reader),
            write: (value, writer)=>__privateGet(this, _write).call(this, input ? input(value) : value, writer),
            serializedSize: (value)=>this.serializedSize(input ? input(value) : value),
            serialize: (value, options)=>__privateGet(this, _serialize).call(this, input ? input(value) : value, options),
            validate: (value)=>{
                validate?.(value);
                this.validate(input ? input(value) : value);
            }
        });
    }
};
_write = new WeakMap();
_serialize = new WeakMap();
let BcsType = _BcsType;
const SERIALIZED_BCS_BRAND = Symbol.for("@iota/serialized-bcs");
function isSerializedBcs(obj) {
    return !!obj && typeof obj === "object" && obj[SERIALIZED_BCS_BRAND] === true;
}
class SerializedBcs {
    constructor(type, schema){
        __privateAdd(this, _schema);
        __privateAdd(this, _bytes);
        __privateSet(this, _schema, type);
        __privateSet(this, _bytes, schema);
    }
    // Used to brand SerializedBcs so that they can be identified, even between multiple copies
    // of the @iota/bcs package are installed
    get [SERIALIZED_BCS_BRAND]() {
        return true;
    }
    toBytes() {
        return __privateGet(this, _bytes);
    }
    toHex() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(__privateGet(this, _bytes));
    }
    toBase64() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toBase64"])(__privateGet(this, _bytes));
    }
    toBase58() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b58$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toBase58"])(__privateGet(this, _bytes));
    }
    parse() {
        return __privateGet(this, _schema).parse(__privateGet(this, _bytes));
    }
}
_schema = new WeakMap();
_bytes = new WeakMap();
function fixedSizeBcsType({ size, ...options }) {
    return new BcsType({
        ...options,
        serializedSize: ()=>size
    });
}
function uIntBcsType({ readMethod, writeMethod, ...options }) {
    return fixedSizeBcsType({
        ...options,
        read: (reader)=>reader[readMethod](),
        write: (value, writer)=>writer[writeMethod](value),
        validate: (value)=>{
            if (value < 0 || value > options.maxValue) {
                throw new TypeError(`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`);
            }
            options.validate?.(value);
        }
    });
}
function bigUIntBcsType({ readMethod, writeMethod, ...options }) {
    return fixedSizeBcsType({
        ...options,
        read: (reader)=>reader[readMethod](),
        write: (value, writer)=>writer[writeMethod](BigInt(value)),
        validate: (val)=>{
            const value = BigInt(val);
            if (value < 0 || value > options.maxValue) {
                throw new TypeError(`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`);
            }
            options.validate?.(value);
        }
    });
}
function dynamicSizeBcsType({ serialize, ...options }) {
    const type = new BcsType({
        ...options,
        serialize,
        write: (value, writer)=>{
            for (const byte of type.serialize(value).toBytes()){
                writer.write8(byte);
            }
        }
    });
    return type;
}
function stringLikeBcsType({ toBytes, fromBytes, ...options }) {
    return new BcsType({
        ...options,
        read: (reader)=>{
            const length = reader.readULEB();
            const bytes = reader.readBytes(length);
            return fromBytes(bytes);
        },
        write: (hex, writer)=>{
            const bytes = toBytes(hex);
            writer.writeULEB(bytes.length);
            for(let i = 0; i < bytes.length; i++){
                writer.write8(bytes[i]);
            }
        },
        serialize: (value)=>{
            const bytes = toBytes(value);
            const size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$uleb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ulebEncode"])(bytes.length);
            const result = new Uint8Array(size.length + bytes.length);
            result.set(size, 0);
            result.set(bytes, size.length);
            return result;
        },
        validate: (value)=>{
            if (typeof value !== "string") {
                throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);
            }
            options.validate?.(value);
        }
    });
}
function lazyBcsType(cb) {
    let lazyType = null;
    function getType() {
        if (!lazyType) {
            lazyType = cb();
        }
        return lazyType;
    }
    return new BcsType({
        name: "lazy",
        read: (data)=>getType().read(data),
        serializedSize: (value)=>getType().serializedSize(value),
        write: (value, writer)=>getType().write(value, writer),
        serialize: (value, options)=>getType().serialize(value, options).toBytes()
    });
}
;
 //# sourceMappingURL=bcs-type.js.map
}),
"[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/bcs.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bcs",
    ()=>bcs
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/bcs-type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$uleb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/dapp-kit/node_modules/@iota/bcs/dist/esm/uleb.js [app-ssr] (ecmascript)");
;
;
const bcs = {
    /**
   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.
   * @example
   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]
   */ u8 (options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uIntBcsType"])({
            name: "u8",
            readMethod: "read8",
            writeMethod: "write8",
            size: 1,
            maxValue: 2 ** 8 - 1,
            ...options
        });
    },
    /**
   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.
   * @example
   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]
   */ u16 (options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uIntBcsType"])({
            name: "u16",
            readMethod: "read16",
            writeMethod: "write16",
            size: 2,
            maxValue: 2 ** 16 - 1,
            ...options
        });
    },
    /**
   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.
   * @example
   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]
   */ u32 (options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uIntBcsType"])({
            name: "u32",
            readMethod: "read32",
            writeMethod: "write32",
            size: 4,
            maxValue: 2 ** 32 - 1,
            ...options
        });
    },
    /**
   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.
   * @example
   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]
   */ u64 (options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bigUIntBcsType"])({
            name: "u64",
            readMethod: "read64",
            writeMethod: "write64",
            size: 8,
            maxValue: 2n ** 64n - 1n,
            ...options
        });
    },
    /**
   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.
   * @example
   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */ u128 (options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bigUIntBcsType"])({
            name: "u128",
            readMethod: "read128",
            writeMethod: "write128",
            size: 16,
            maxValue: 2n ** 128n - 1n,
            ...options
        });
    },
    /**
   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.
   * @example
   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */ u256 (options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bigUIntBcsType"])({
            name: "u256",
            readMethod: "read256",
            writeMethod: "write256",
            size: 32,
            maxValue: 2n ** 256n - 1n,
            ...options
        });
    },
    /**
   * Creates a BcsType that can be used to read and write boolean values.
   * @example
   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]
   */ bool (options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fixedSizeBcsType"])({
            name: "bool",
            size: 1,
            read: (reader)=>reader.read8() === 1,
            write: (value, writer)=>writer.write8(value ? 1 : 0),
            ...options,
            validate: (value)=>{
                options?.validate?.(value);
                if (typeof value !== "boolean") {
                    throw new TypeError(`Expected boolean, found ${typeof value}`);
                }
            }
        });
    },
    /**
   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers
   * @example
   *
   */ uleb128 (options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["dynamicSizeBcsType"])({
            name: "uleb128",
            read: (reader)=>reader.readULEB(),
            serialize: (value)=>{
                return Uint8Array.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$uleb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ulebEncode"])(value));
            },
            ...options
        });
    },
    /**
   * Creates a BcsType representing a fixed length byte array
   * @param size The number of bytes this types represents
   * @example
   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]
   */ bytes (size, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fixedSizeBcsType"])({
            name: `bytes[${size}]`,
            size,
            read: (reader)=>reader.readBytes(size),
            write: (value, writer)=>{
                for(let i = 0; i < size; i++){
                    writer.write8(value[i] ?? 0);
                }
            },
            ...options,
            validate: (value)=>{
                options?.validate?.(value);
                if (!value || typeof value !== "object" || !("length" in value)) {
                    throw new TypeError(`Expected array, found ${typeof value}`);
                }
                if (value.length !== size) {
                    throw new TypeError(`Expected array of length ${size}, found ${value.length}`);
                }
            }
        });
    },
    /**
   * Creates a BcsType representing a variable length byte array
   *
   * @example
   * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]
   */ byteVector (options) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BcsType"]({
            name: `bytesVector`,
            read: (reader)=>{
                const length = reader.readULEB();
                return reader.readBytes(length);
            },
            write: (value, writer)=>{
                const array = new Uint8Array(value);
                writer.writeULEB(array.length);
                for(let i = 0; i < array.length; i++){
                    writer.write8(array[i] ?? 0);
                }
            },
            ...options,
            serializedSize: (value)=>{
                const length = "length" in value ? value.length : null;
                return length == null ? null : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$uleb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ulebEncode"])(length).length + length;
            },
            validate: (value)=>{
                options?.validate?.(value);
                if (!value || typeof value !== "object" || !("length" in value)) {
                    throw new TypeError(`Expected array, found ${typeof value}`);
                }
            }
        });
    },
    /**
   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded
   * @example
   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]
   */ string (options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringLikeBcsType"])({
            name: "string",
            toBytes: (value)=>new TextEncoder().encode(value),
            fromBytes: (bytes)=>new TextDecoder().decode(bytes),
            ...options
        });
    },
    /**
   * Creates a BcsType that represents a fixed length array of a given type
   * @param size The number of elements in the array
   * @param type The BcsType of each element in the array
   * @example
   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]
   */ fixedArray (size, type, options) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BcsType"]({
            name: `${type.name}[${size}]`,
            read: (reader)=>{
                const result = new Array(size);
                for(let i = 0; i < size; i++){
                    result[i] = type.read(reader);
                }
                return result;
            },
            write: (value, writer)=>{
                for (const item of value){
                    type.write(item, writer);
                }
            },
            ...options,
            validate: (value)=>{
                options?.validate?.(value);
                if (!value || typeof value !== "object" || !("length" in value)) {
                    throw new TypeError(`Expected array, found ${typeof value}`);
                }
                if (value.length !== size) {
                    throw new TypeError(`Expected array of length ${size}, found ${value.length}`);
                }
            }
        });
    },
    /**
   * Creates a BcsType representing an optional value
   * @param type The BcsType of the optional value
   * @example
   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]
   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]
   */ option (type) {
        return bcs.enum(`Option<${type.name}>`, {
            None: null,
            Some: type
        }).transform({
            input: (value)=>{
                if (value == null) {
                    return {
                        None: true
                    };
                }
                return {
                    Some: value
                };
            },
            output: (value)=>{
                if (value.$kind === "Some") {
                    return value.Some;
                }
                return null;
            }
        });
    },
    /**
   * Creates a BcsType representing a variable length vector of a given type
   * @param type The BcsType of each element in the vector
   *
   * @example
   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]
   */ vector (type, options) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BcsType"]({
            name: `vector<${type.name}>`,
            read: (reader)=>{
                const length = reader.readULEB();
                const result = new Array(length);
                for(let i = 0; i < length; i++){
                    result[i] = type.read(reader);
                }
                return result;
            },
            write: (value, writer)=>{
                writer.writeULEB(value.length);
                for (const item of value){
                    type.write(item, writer);
                }
            },
            ...options,
            validate: (value)=>{
                options?.validate?.(value);
                if (!value || typeof value !== "object" || !("length" in value)) {
                    throw new TypeError(`Expected array, found ${typeof value}`);
                }
            }
        });
    },
    /**
   * Creates a BcsType representing a tuple of a given set of types
   * @param types The BcsTypes for each element in the tuple
   *
   * @example
   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])
   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]
   */ tuple (types, options) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BcsType"]({
            name: `(${types.map((t)=>t.name).join(", ")})`,
            serializedSize: (values)=>{
                let total = 0;
                for(let i = 0; i < types.length; i++){
                    const size = types[i].serializedSize(values[i]);
                    if (size == null) {
                        return null;
                    }
                    total += size;
                }
                return total;
            },
            read: (reader)=>{
                const result = [];
                for (const type of types){
                    result.push(type.read(reader));
                }
                return result;
            },
            write: (value, writer)=>{
                for(let i = 0; i < types.length; i++){
                    types[i].write(value[i], writer);
                }
            },
            ...options,
            validate: (value)=>{
                options?.validate?.(value);
                if (!Array.isArray(value)) {
                    throw new TypeError(`Expected array, found ${typeof value}`);
                }
                if (value.length !== types.length) {
                    throw new TypeError(`Expected array of length ${types.length}, found ${value.length}`);
                }
            }
        });
    },
    /**
   * Creates a BcsType representing a struct of a given set of fields
   * @param name The name of the struct
   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized
   *
   * @example
   * const struct = bcs.struct('MyStruct', {
   *  a: bcs.u8(),
   *  b: bcs.string(),
   * })
   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   */ struct (name, fields, options) {
        const canonicalOrder = Object.entries(fields);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BcsType"]({
            name,
            serializedSize: (values)=>{
                let total = 0;
                for (const [field, type] of canonicalOrder){
                    const size = type.serializedSize(values[field]);
                    if (size == null) {
                        return null;
                    }
                    total += size;
                }
                return total;
            },
            read: (reader)=>{
                const result = {};
                for (const [field, type] of canonicalOrder){
                    result[field] = type.read(reader);
                }
                return result;
            },
            write: (value, writer)=>{
                for (const [field, type] of canonicalOrder){
                    type.write(value[field], writer);
                }
            },
            ...options,
            validate: (value)=>{
                options?.validate?.(value);
                if (typeof value !== "object" || value == null) {
                    throw new TypeError(`Expected object, found ${typeof value}`);
                }
            }
        });
    },
    /**
   * Creates a BcsType representing an enum of a given set of options
   * @param name The name of the enum
   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.
   * null can be used to represent a variant with no data.
   *
   * @example
   * const enum = bcs.enum('MyEnum', {
   *   A: bcs.u8(),
   *   B: bcs.string(),
   *   C: null,
   * })
   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]
   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]
   */ enum (name, values, options) {
        const canonicalOrder = Object.entries(values);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BcsType"]({
            name,
            read: (reader)=>{
                const index = reader.readULEB();
                const enumEntry = canonicalOrder[index];
                if (!enumEntry) {
                    throw new TypeError(`Unknown value ${index} for enum ${name}`);
                }
                const [kind, type] = enumEntry;
                return {
                    [kind]: type?.read(reader) ?? true,
                    $kind: kind
                };
            },
            write: (value, writer)=>{
                const [name2, val] = Object.entries(value).filter(([name3])=>Object.hasOwn(values, name3))[0];
                for(let i = 0; i < canonicalOrder.length; i++){
                    const [optionName, optionType] = canonicalOrder[i];
                    if (optionName === name2) {
                        writer.writeULEB(i);
                        optionType?.write(val, writer);
                        return;
                    }
                }
            },
            ...options,
            validate: (value)=>{
                options?.validate?.(value);
                if (typeof value !== "object" || value == null) {
                    throw new TypeError(`Expected object, found ${typeof value}`);
                }
                const keys = Object.keys(value).filter((k)=>value[k] !== void 0 && Object.hasOwn(values, k));
                if (keys.length !== 1) {
                    throw new TypeError(`Expected object with one key, but found ${keys.length} for type ${name}}`);
                }
                const [variant] = keys;
                if (!Object.hasOwn(values, variant)) {
                    throw new TypeError(`Invalid enum variant ${variant}`);
                }
            }
        });
    },
    /**
   * Creates a BcsType representing a map of a given key and value type
   * @param keyType The BcsType of the key
   * @param valueType The BcsType of the value
   * @example
   * const map = bcs.map(bcs.u8(), bcs.string())
   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]
   */ map (keyType, valueType) {
        return bcs.vector(bcs.tuple([
            keyType,
            valueType
        ])).transform({
            name: `Map<${keyType.name}, ${valueType.name}>`,
            input: (value)=>{
                return [
                    ...value.entries()
                ];
            },
            output: (value)=>{
                const result = /* @__PURE__ */ new Map();
                for (const [key, val] of value){
                    result.set(key, val);
                }
                return result;
            }
        });
    },
    /**
   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.
   * @param cb A callback that returns the BcsType
   */ lazy (cb) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$dapp$2d$kit$2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$bcs$2d$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lazyBcsType"])(cb);
    }
};
;
 //# sourceMappingURL=bcs.js.map
}),
"[project]/node_modules/@iota/iota-names-sdk/dist/esm/bcs.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CouponBcs",
    ()=>CouponBcs,
    "CouponHouseBcs",
    ()=>CouponHouseBcs,
    "DummyFieldBcs",
    ()=>DummyFieldBcs,
    "NameBcs",
    ()=>NameBcs
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@iota/iota-sdk/dist/esm/bcs/index.js [app-ssr] (ecmascript) <locals>");
;
const DummyFieldBcs = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].struct("DummyFieldObj", {
    dummy_field: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].bool()
});
const NameBcs = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].struct("Name", {
    labels: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].vector(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].string())
});
const RangeBcs = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].struct("Range", {
    from: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].u8(),
    to: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].u8()
});
const CouponRulesBcs = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].struct("CouponRules", {
    length: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].option(RangeBcs),
    available_claims: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].option(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].u64()),
    user: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].option(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].Address),
    expiration: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].option(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].u64()),
    years: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].option(RangeBcs),
    can_stack: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].bool()
});
const CouponHouseBcs = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].struct("CouponHouse", {
    coupons: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].struct("Coupons", {
        coupons: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].struct("Table", {
            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].struct("UID", {
                id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].struct("ID", {
                    bytes: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].Address
                })
            }),
            size: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].u64()
        })
    }),
    version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].u8(),
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].struct("UID", {
        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].struct("ID", {
            bytes: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].Address
        })
    })
});
const CouponBcs = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].struct("Coupon", {
    kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].u8(),
    amount: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].u64(),
    rules: CouponRulesBcs
});
;
 //# sourceMappingURL=bcs.js.map
}),
"[project]/node_modules/@iota/iota-names-sdk/dist/esm/constants.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ALLOWED_METADATA",
    ()=>ALLOWED_METADATA,
    "GRACE_PERIOD_MS",
    ()=>GRACE_PERIOD_MS,
    "MAX_U64",
    ()=>MAX_U64,
    "MIN_LABEL_SIZE",
    ()=>MIN_LABEL_SIZE,
    "packages",
    ()=>packages
]);
const MAX_U64 = BigInt("18446744073709551615");
const MIN_LABEL_SIZE = 3;
const GRACE_PERIOD_MS = 30 * 24 * 60 * 60 * 1e3;
const ALLOWED_METADATA = {
    avatar: "avatar",
    twitterX: "twitter/x",
    discord: "discord",
    github: "github",
    email: "email",
    btc: "btc",
    eth: "eth",
    ltc: "ltc",
    doge: "doge",
    sol: "sol",
    sui: "sui",
    website: "website",
    ipfs: "ipfs",
    arweave: "arweave"
};
const packages = {
    devnet: {
        adminAddress: "0x1ca3c38e888493f869ac35346a2041d6cf87b0b935ebba14b35a08811d8a76e4",
        adminCap: "0x5a45ba086c2a873b5d6d34e8503e8ca8850588bf7f301285e279c8dab94eeb73",
        auctionPackageId: "0x79c8714ea294a92da04875c77ccabf8d1a06107e80d41c23d6777d5b1e6724a5",
        auctionHouseObjectId: "0xc922c77a1d4f4e699aa912a7c24aee4668f8975d2a5f01ba780f656289bf2c2c",
        coins: {
            IOTA: {
                type: "0x0000000000000000000000000000000000000000000000000000000000000002::iota::IOTA",
                metadataId: "0xf7ceb0424ca93f77858c74aebda8bcd5ffe0f32b82ebcc38afb3ba643d03a5f8"
            }
        },
        iotaNamesObjectId: "0x07c59b37bd7d036bf78fa30561a2ab9f7a970837487656ec29466e817f879342",
        packageId: "0xb9d617f24c84826bf660a2f4031951678cc80c264aebc4413459fb2a95ada9ba",
        paymentsPackageId: "0x98b9b33b7c2347a8f4e8b8716fb4c7e6e1af846ec2ea063a47bba81ffe03b440",
        publisherId: "0xb9435d6c5f3a7bd85fa362b4b89262cf738d48774695e8e9955704ce0fd3526f",
        registryTableId: "0xe00b2f2400c33b4dbd3081c4dcf2e289d0544caba23a3d130b264bd756403c07",
        reverseRegistryTableId: "0x1c1da17843cc453ad4079b05ce55e103b7a8cdd4db6ab42dc367b47ed6d8994d",
        couponsPackageId: "0xf2d61106ef44216f03709276c4e79c78485080c6d8fbad8464b7a570b9f36470",
        subnamesPackageId: "0x1efbf928710d0d92635dacff4c502516169d37fa006cabd2f3cdd0123221e09e",
        tempSubnameProxyPackageId: "0x4a16b7b2a9c194989519c87ee3f1d1007ece8aecb62b9a50a4c10075db0591a3",
        upgradeCap: "0xd64205c4b10eff4b4adb00ab6f754cda8d8e7525985a31307f7e232481dfaf6e"
    },
    testnet: {
        adminAddress: "0x548474360f9769077ccf07ff6e65060eb448470eabc1ae42b9ed371ddbfc23d2",
        adminCap: "0x541b117cac18fb1c07a293db300acd12b05c01fa81232b37151b005ca7d4f755",
        auctionPackageId: "0x6f727ea576a00036657fff0ae3a6d7c8171b178bf35112d6b83b2a6272cc5f0d",
        auctionHouseObjectId: "0x2292ea885039babe8c320f19e0b7546ebdef2b2f6cf2be600bf994cdb51e0050",
        coins: {
            IOTA: {
                type: "0x0000000000000000000000000000000000000000000000000000000000000002::iota::IOTA",
                metadataId: "0x6dcda050874e2f160a008afc9e3ca6304a667cc85045e35f25b3c7967282b153"
            }
        },
        iotaNamesObjectId: "0x7cab491740d51e0d75b26bf9984e49ba2e32a2d0694cabcee605543ed13c7dec",
        packageId: "0x7fff6e95f385349bec98d17121ab2bfa3e134f2f0b1ccefc270313415f7835ea",
        paymentsPackageId: "0x6b1b01f4c72786a893191d5c6e73d3012f7529f86fdee3bc8c163323cee08441",
        publisherId: "0x42faed18f40323158fb9b0f38630800addc2e9eea696265756769fc1f0e08ceb",
        registryTableId: "0x2dfc6f6d46ba55217425643a59dc85fe4d8ed273a9f74077bd0ee280dbb4f590",
        reverseRegistryTableId: "0x3550bcacb793ef8b776264665e7c99fa3d897695ed664656aac693cf9cf9b76b",
        couponsPackageId: "0xa7e4e483d79c245470d5eb3c285a4503a78d90a69d36e35e0993012f5c6137ca",
        subnamesPackageId: "0xd06a5607cc762f2352eeeb8c86c7f962558a06c6023c1eec031a41651d898c87",
        tempSubnameProxyPackageId: "0x7f34c135e55e5b436b3feaad369eabfe5b6d14c0c57544fefb6921db047e8cbc",
        upgradeCap: "0x03ac547ee58c268a69b5663a1fdee0e8202206922968d2a387104730627d188e"
    }
};
;
 //# sourceMappingURL=constants.js.map
}),
"[project]/node_modules/@iota/iota-names-sdk/dist/esm/coupons.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "COUPON_EXPIRED",
    ()=>COUPON_EXPIRED,
    "INVALID_AVAILABLE_CLAIMS",
    ()=>INVALID_AVAILABLE_CLAIMS,
    "INVALID_FOR_NAME_LENGTH",
    ()=>INVALID_FOR_NAME_LENGTH,
    "INVALID_PERCENTAGE",
    ()=>INVALID_PERCENTAGE,
    "INVALID_USER",
    ()=>INVALID_USER,
    "INVALID_YEARS",
    ()=>INVALID_YEARS,
    "NON_STACKING_COUPON",
    ()=>NON_STACKING_COUPON,
    "applyCouponToPrice",
    ()=>applyCouponToPrice,
    "applyCouponsToPrice",
    ()=>applyCouponsToPrice,
    "hasAvailableClaims",
    ()=>hasAvailableClaims,
    "isCouponExpired",
    ()=>isCouponExpired,
    "isCouponValidForAddress",
    ()=>isCouponValidForAddress,
    "isCouponValidForNameLength",
    ()=>isCouponValidForNameLength,
    "isCouponValidForNameYears",
    ()=>isCouponValidForNameYears,
    "isValidCouponPercentage",
    ()=>isValidCouponPercentage,
    "validateCoupon",
    ()=>validateCoupon,
    "validateCoupons",
    ()=>validateCoupons
]);
const INVALID_YEARS = "Coupon is not valid for the given number of years.";
const INVALID_FOR_NAME_LENGTH = "Coupon is not valid for the given name length.";
const INVALID_PERCENTAGE = "Invalid percentage amount for coupon.";
const INVALID_USER = "Coupon address does not match.";
const COUPON_EXPIRED = "Coupon has expired.";
const INVALID_AVAILABLE_CLAIMS = "Number of claims cannot be zero.";
const NON_STACKING_COUPON = "Coupon cannot be used with other coupons.";
function validateCoupon(coupon, years, length, address) {
    try {
        hasAvailableClaims(coupon.rules);
        isCouponValidForNameYears(coupon.rules, years);
        if (coupon.kind === 0) {
            isValidCouponPercentage(coupon.amount);
        }
        isCouponValidForNameLength(coupon.rules, length);
        isCouponValidForAddress(coupon.rules, address);
        isCouponExpired(coupon.rules);
    } catch (error) {
        throw new Error(`Coupon '${coupon.couponCode}' validation failed: ${error?.message}`);
    }
}
function validateCoupons(coupons, years, length, address) {
    for (const coupon of coupons){
        if (!coupon.rules.can_stack && coupons.length > 1) {
            throw new Error(`Coupon '${coupon.couponCode}' validation failed: ${NON_STACKING_COUPON}`);
        }
        validateCoupon(coupon, years, length, address);
    }
}
function applyCouponsToPrice(coupons, initialPrice) {
    if (!coupons || coupons.length === 0) {
        return initialPrice;
    }
    let price = initialPrice;
    for (const coupon of coupons){
        if (!coupon.rules.can_stack && coupons.length > 1) {
            throw new Error("Coupons provided cannot be stacked");
        }
        price = applyCouponToPrice(price, coupon);
    }
    return price;
}
function applyCouponToPrice(price, coupon) {
    if (!coupon) {
        return price;
    }
    const couponAmount = Number(coupon.amount);
    if (coupon.kind === 0) {
        let discountAmount = price * couponAmount / 100;
        return price - discountAmount;
    } else if (coupon.kind === 1) {
        const discountedAmount = price - couponAmount;
        return discountedAmount < 0 ? 0 : discountedAmount;
    } else {
        throw new Error(`Unknown coupon kind: ${coupon.kind}`);
    }
}
function hasAvailableClaims(rules) {
    if (rules?.available_claims !== null && rules?.available_claims !== void 0 && parseInt(rules?.available_claims) <= 0) {
        throw new Error(INVALID_AVAILABLE_CLAIMS);
    }
}
function isCouponValidForNameYears(rules, years) {
    const { from: minYears, to: maxYears } = rules.years || {};
    if (minYears && maxYears && (years < minYears || years > maxYears)) {
        throw new Error(INVALID_YEARS);
    }
}
function isValidCouponPercentage(amount) {
    if (parseInt(amount) <= 0 || parseInt(amount) > 100) {
        throw new Error(INVALID_PERCENTAGE);
    }
}
function isCouponValidForNameLength(rules, length) {
    const { from: minLength, to: maxLength } = rules.length || {};
    if (minLength && maxLength && (length < minLength || length > maxLength)) {
        throw new Error(INVALID_FOR_NAME_LENGTH);
    }
}
function isCouponValidForAddress(rules, userAddress) {
    if (rules.user && rules.user !== userAddress) {
        throw new Error(INVALID_USER);
    }
}
function isCouponExpired(rules, currentTimestamp = Date.now().toString()) {
    if (rules.expiration && Number(currentTimestamp) > Number(rules.expiration)) {
        throw new Error(COUPON_EXPIRED);
    }
}
;
 //# sourceMappingURL=coupons.js.map
}),
"[project]/node_modules/@iota/iota-names-sdk/dist/esm/utils.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isValidIotaName",
    ()=>isValidIotaName,
    "normalizeIotaName",
    ()=>normalizeIotaName,
    "validateIotaName",
    ()=>validateIotaName,
    "validateIotaSubname",
    ()=>validateIotaSubname
]);
const LABEL_REGEX = /(?!-)[a-z0-9-]{0,62}[a-z0-9]/;
const SUBNAME_REGEX = /^(?!-)[a-z0-9-]{1,62}[a-z0-9]$/;
const PATH_REGEX = new RegExp(`(?:${LABEL_REGEX.source}(?:\\.${LABEL_REGEX.source})*)`);
const NAME_AT_REGEX = new RegExp(`^(${PATH_REGEX.source})?@${LABEL_REGEX.source}$`);
const NAME_DOT_REGEX = new RegExp(`^(?:${LABEL_REGEX.source}\\.)+(iota)$`);
const MAX_LENGTH = 235;
function isValidIotaName(name) {
    if (name.length > MAX_LENGTH) {
        return false;
    }
    return NAME_AT_REGEX.test(name) || NAME_DOT_REGEX.test(name);
}
const LONG_NAMES_TRUNCATE_LENGTH = 11;
const CHARACTERS_TO_SHOW = 6;
function normalizeIotaName(name, format = "at", { onlyFirstSubname, truncateLongParts, ellipsisForDeepSubnames = onlyFirstSubname === true } = {}) {
    const lowerCase = name.toLowerCase();
    let parts;
    if (NAME_AT_REGEX.test(lowerCase)) {
        let [path, name2] = lowerCase.split("@");
        parts = [
            ...path ? path.split(".") : [],
            name2
        ];
    } else if (NAME_DOT_REGEX.test(lowerCase)) {
        parts = lowerCase.split(".").slice(0, -1);
    } else {
        throw new Error(`Invalid IOTA name "${name}"`);
    }
    const subnamesEllipsis = format === "dot" ? "." : "..";
    let subnames = onlyFirstSubname && parts.length >= 2 ? [
        // First name from the left (e.g yes.no.no.no.iota)
        parts[0],
        ellipsisForDeepSubnames && parts.length > 2 ? subnamesEllipsis : ""
    ].filter(Boolean) : parts.slice(0, -1);
    let parentName = parts[parts.length - 1];
    if (truncateLongParts) {
        subnames = subnames.map((s)=>{
            return s.length > LONG_NAMES_TRUNCATE_LENGTH ? `${s.slice(0, CHARACTERS_TO_SHOW)}...${s.slice(-CHARACTERS_TO_SHOW)}` : s;
        });
        parentName = parentName.length > LONG_NAMES_TRUNCATE_LENGTH ? `${parentName.slice(0, CHARACTERS_TO_SHOW)}...${parentName.slice(-CHARACTERS_TO_SHOW)}` : parentName;
    }
    if (format === "dot") {
        return `${[
            ...subnames,
            parentName
        ].join(".")}.iota`;
    } else {
        return `${subnames.join(".")}@${parentName}`;
    }
}
function validateIotaSubname(name, minLength = 3, maxLength = 64) {
    if (!name) return null;
    const lowerCase = name.toLowerCase();
    if (name.length < minLength || name.length > maxLength) {
        return `Name must be ${minLength}-${maxLength} characters long`;
    }
    if (!SUBNAME_REGEX.test(lowerCase)) {
        return "Invalid characters. Only a-z, 0-9, and hyphens (not at the beginning or end) are allowed";
    }
    return null;
}
function validateIotaName(name, minLength = 3, maxLength = 64, allowSubnames = true) {
    if (!name) return null;
    const lowerCase = name.toLowerCase();
    const parts = lowerCase.split(".");
    if (!allowSubnames && parts.length > 2) {
        return "No subnames allowed";
    }
    for (const part of parts.slice(0, -1)){
        if (part.length < minLength || part.length > maxLength) {
            return `Name must be ${minLength}-${maxLength} characters long`;
        }
    }
    if (!NAME_DOT_REGEX.test(name)) {
        return "Invalid characters. Only a-z, 0-9, and hyphens (not at the beginning or end) are allowed";
    }
    return null;
}
;
 //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@iota/iota-names-sdk/dist/esm/helpers.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getConfigType",
    ()=>getConfigType,
    "getCoreConfigType",
    ()=>getCoreConfigType,
    "getNameRegistrationType",
    ()=>getNameRegistrationType,
    "getNameType",
    ()=>getNameType,
    "getPricelistConfigType",
    ()=>getPricelistConfigType,
    "getRenewalPricelistConfigType",
    ()=>getRenewalPricelistConfigType,
    "getSubnameRegistrationType",
    ()=>getSubnameRegistrationType,
    "isNestedSubname",
    ()=>isNestedSubname,
    "isSubname",
    ()=>isSubname,
    "validateYears",
    ()=>validateYears,
    "zeroCoin",
    ()=>zeroCoin
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/iota-names-sdk/dist/esm/utils.js [app-ssr] (ecmascript)");
;
function isSubname(name) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeIotaName"])(name, "dot").split(".").length > 2;
}
function isNestedSubname(name) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeIotaName"])(name, "dot").split(".").length > 3;
}
function validateYears(years) {
    if (!(years > 0 && years < 6)) throw new Error("Years must be between 1 and 5");
}
function zeroCoin(tx, type) {
    return tx.moveCall({
        target: "0x2::coin::zero",
        typeArguments: [
            type
        ]
    });
}
function getConfigType(iotaNamesPackageV1, innerType) {
    return `${iotaNamesPackageV1}::iota_names::ConfigKey<${innerType}>`;
}
function getNameType(iotaNamesPackageV1) {
    return `${iotaNamesPackageV1}::name::Name`;
}
function getPricelistConfigType(iotaNamesPackageId) {
    return `${iotaNamesPackageId}::pricing_config::PricingConfig`;
}
function getRenewalPricelistConfigType(iotaNamesPackageId) {
    return `${iotaNamesPackageId}::pricing_config::RenewalConfig`;
}
function getNameRegistrationType(iotaNamesPackageId) {
    return `${iotaNamesPackageId}::name_registration::NameRegistration`;
}
function getSubnameRegistrationType(iotaNamesPackageId) {
    return `${iotaNamesPackageId}::subname_registration::SubnameRegistration`;
}
function getCoreConfigType(iotaNamesPackageId) {
    return `${iotaNamesPackageId}::core_config::CoreConfig`;
}
;
 //# sourceMappingURL=helpers.js.map
}),
"[project]/node_modules/@iota/iota-names-sdk/dist/esm/iota-names-client.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "IotaNamesClient",
    ()=>IotaNamesClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@iota/iota-sdk/dist/esm/bcs/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$graphql$2f$schemas$2f$2025$2e$2$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@iota/iota-sdk/dist/esm/graphql/schemas/2025.2/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/bcs/dist/esm/b64.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$blake2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/blake2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$bcs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/iota-names-sdk/dist/esm/bcs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/iota-names-sdk/dist/esm/constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$coupons$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/iota-names-sdk/dist/esm/coupons.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/iota-names-sdk/dist/esm/helpers.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@iota/iota-names-sdk/dist/esm/utils.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
class IotaNamesClient {
    constructor(config){
        this.graphQlClient = config.graphQlClient;
        if ("network" in config) {
            this.config = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["packages"][config.network];
        } else {
            this.config = config.packageInfo;
        }
    }
    /**
   * Returns the core config of IOTA Names.
   */ async getCoreConfig() {
        if (!this.config.iotaNamesObjectId) throw new Error("IotaNames object ID is not set");
        if (!this.config.packageId) throw new Error("IotaNames package ID is not set");
        const coreConfigBcsB64 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toB64"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$bcs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DummyFieldBcs"].serialize({
            dummy_field: false
        }).toBytes());
        const coreConfigResponse = await this.graphQlClient.query({
            query: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$graphql$2f$schemas$2f$2025$2e$2$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["graphql"])(`
                query getCoreConfig($parentId: IotaAddress!, $name: DynamicFieldName!) {
                    owner(address: $parentId) {
                        address
                        dynamicField(name: $name) {
                            value {
                                ... on MoveValue {
                                    json
                                }
                            }
                        }
                    }
                }
            `),
            variables: {
                parentId: this.config.iotaNamesObjectId,
                name: {
                    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getConfigType"])(this.config.packageId, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoreConfigType"])(this.config.packageId)),
                    bcs: coreConfigBcsB64
                }
            }
        });
        const coreConfig = coreConfigResponse?.data?.owner?.dynamicField?.value?.json;
        if (!coreConfig) {
            throw new Error("Core config not found or is invalid");
        }
        return coreConfig;
    }
    /**
   * Returns the price list for IOTA names in the base asset.
   */ // Format:
    // {
    // 	[ 3, 3 ] => 500000000,
    // 	[ 4, 4 ] => 100000000,
    // 	[ 5, 63 ] => 20000000
    // }
    async getPriceList() {
        if (!this.config.iotaNamesObjectId) throw new Error("IotaNames object ID is not set");
        if (!this.config.packageId) throw new Error("IotaNames package ID is not set");
        const pricingConfigBcsB64 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toB64"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$bcs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DummyFieldBcs"].serialize({
            dummy_field: false
        }).toBytes());
        const priceListResponse = await this.graphQlClient.query({
            query: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$graphql$2f$schemas$2f$2025$2e$2$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["graphql"])(`
                query getPriceList($parentId: IotaAddress!, $name: DynamicFieldName!) {
                    owner(address: $parentId) {
                        address
                        dynamicField(name: $name) {
                            value {
                                ... on MoveValue {
                                    json
                                }
                            }
                        }
                    }
                }
            `),
            variables: {
                parentId: this.config.iotaNamesObjectId,
                name: {
                    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getConfigType"])(this.config.packageId, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getPricelistConfigType"])(this.config.packageId)),
                    bcs: pricingConfigBcsB64
                }
            }
        });
        const priceList = priceListResponse?.data?.owner?.dynamicField?.value?.json?.pricing;
        const contents = priceList?.contents;
        if (!contents) {
            throw new Error("Price list not found or content is invalid");
        }
        const priceMap = /* @__PURE__ */ new Map();
        for (const entry of contents){
            const { pos0, pos1 } = entry.key;
            const key = [
                Number(pos0),
                Number(pos1)
            ];
            const value = Number(entry.value);
            priceMap.set(key, value);
        }
        return priceMap;
    }
    /**
   * Returns the renewal price list for IOTA names in the base asset.
   */ // Format:
    // {
    // 	[ 3, 3 ] => 500000000000,
    // 	[ 4, 4 ] => 250000000000,
    // 	[ 5, 63 ] => 50000000000
    // }
    async getRenewalPriceList() {
        if (!this.config.iotaNamesObjectId) throw new Error("IotaNames object ID is not set");
        if (!this.config.packageId) throw new Error("IotaNames package ID is not set");
        const pricingConfigBcsB64 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toB64"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$bcs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DummyFieldBcs"].serialize({
            dummy_field: false
        }).toBytes());
        const priceListResponse = await this.graphQlClient.query({
            query: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$graphql$2f$schemas$2f$2025$2e$2$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["graphql"])(`
                query getRenewalPriceList($parentId: IotaAddress!, $name: DynamicFieldName!) {
                    owner(address: $parentId) {
                        address
                        dynamicField(name: $name) {
                            value {
                                ... on MoveValue {
                                    json
                                }
                            }
                        }
                    }
                }
            `),
            variables: {
                parentId: this.config.iotaNamesObjectId,
                name: {
                    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getConfigType"])(this.config.packageId, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRenewalPricelistConfigType"])(this.config.packageId)),
                    bcs: pricingConfigBcsB64
                }
            }
        });
        const priceList = priceListResponse?.data?.owner?.dynamicField?.value?.json?.config?.pricing;
        const contents = priceList?.contents;
        if (!contents) {
            throw new Error("Price list not found or content is invalid");
        }
        const priceMap = /* @__PURE__ */ new Map();
        for (const entry of contents){
            const { pos0, pos1 } = entry.key;
            const key = [
                Number(pos0),
                Number(pos1)
            ];
            const value = Number(entry.value);
            priceMap.set(key, value);
        }
        return priceMap;
    }
    async getDefaultName(address) {
        const response = await this.graphQlClient.query({
            query: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$graphql$2f$schemas$2f$2025$2e$2$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["graphql"])(`
                query resolveNameServiceName($address: IotaAddress!, $nameFormat: NameFormat) {
                    address(address: $address) {
                        iotaNamesDefaultName(format: $nameFormat)
                    }
                }
            `),
            variables: {
                address
            }
        });
        const defaultName = response?.data?.address?.iotaNamesDefaultName ?? null;
        return defaultName;
    }
    async getNameRecord(name) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isValidIotaName"])(name)) throw new Error("Invalid IOTA name");
        if (!this.config.registryTableId) throw new Error("IotaNames package ID is not set");
        const nameBcsB64 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toB64"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$bcs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NameBcs"].serialize({
            labels: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeIotaName"])(name, "dot").split(".").reverse()
        }).toBytes());
        const nameRecordResponse = await this.graphQlClient.query({
            query: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$graphql$2f$schemas$2f$2025$2e$2$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["graphql"])(`
                query getNameRecord($parentId: IotaAddress!, $name: DynamicFieldName!) {
                    owner(address: $parentId) {
                        address
                        dynamicField(name: $name) {
                            value {
                                ... on MoveValue {
                                    json
                                }
                            }
                        }
                    }
                }
            `),
            variables: {
                parentId: this.config.registryTableId,
                name: {
                    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNameType"])(this.config.packageId),
                    bcs: nameBcsB64
                }
            }
        });
        const nameRecord = nameRecordResponse.data?.owner?.dynamicField?.value?.json;
        if (!nameRecord) return null;
        const nameRecordData = nameRecord.data?.contents;
        if (nameRecord.error || !nameRecordData) throw new Error("Name record not found. This name is not registered.");
        const data = {};
        if (nameRecordData) {
            nameRecordData.forEach((field)=>{
                if (field.key) {
                    data[field.key] = field.value;
                }
            });
        }
        return {
            name,
            nftId: nameRecord?.nft_id,
            targetAddress: nameRecord?.target_address,
            expirationTimestampMs: Number(nameRecord?.expiration_timestamp_ms),
            data,
            avatar: data[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ALLOWED_METADATA"].avatar]
        };
    }
    async getCouponHouse() {
        if (!this.config.iotaNamesObjectId) throw new Error("IotaNames object ID is not set");
        if (!this.config.packageId) throw new Error("IotaNames package ID is not set");
        if (!this.config.couponsPackageId) throw new Error("Coupon package ID is not set");
        const iotaNamesObjectId = this.config.iotaNamesObjectId;
        const packageId = this.config.packageId;
        const couponsPackageId = this.config.couponsPackageId;
        const DummyFieldB64 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$bcs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DummyFieldBcs"].serialize({
            dummy_field: false
        }).toBase64();
        const couponHouseResponse = await this.graphQlClient.query({
            query: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$graphql$2f$schemas$2f$2025$2e$2$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["graphql"])(`
                query getIotaNamesCouponHouseRegistryKey(
                    $parentId: IotaAddress!
                    $name: DynamicFieldName!
                ) {
                    owner(address: $parentId) {
                        dynamicField(name: $name) {
                            value {
                                ... on MoveValue {
                                    bcs
                                }
                            }
                        }
                    }
                }
            `),
            variables: {
                parentId: iotaNamesObjectId,
                name: {
                    type: `${packageId}::iota_names::RegistryKey<${couponsPackageId}::coupon_house::CouponHouse>`,
                    bcs: DummyFieldB64
                }
            }
        });
        const couponsHouseDynamicFieldBcsValue = couponHouseResponse?.data?.owner?.dynamicField?.value?.bcs;
        if (!couponsHouseDynamicFieldBcsValue) {
            throw new Error("Coupon house not found or is invalid");
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$bcs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CouponHouseBcs"].parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromB64"])(couponsHouseDynamicFieldBcsValue));
    }
    async resolveCoupon(couponCode) {
        const couponHouse = await this.getCouponHouse();
        const couponsTableId = couponHouse?.coupons?.coupons?.id.id.bytes;
        if (!couponsTableId) {
            throw new Error("Coupons table ID not found in the coupon house");
        }
        const couponCodeHash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$blake2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["blake2b"])(couponCode, {
            dkLen: 32
        }));
        const couponCodeBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(couponCodeHash);
        const couponCodeB64 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].vector(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$bcs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bcs"].u8()).serialize(couponCodeBytes).toBase64();
        const couponResponse = await this.graphQlClient.query({
            query: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$sdk$2f$dist$2f$esm$2f$graphql$2f$schemas$2f$2025$2e$2$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["graphql"])(`
                query getCouponBcs($parentId: IotaAddress!, $name: DynamicFieldName!) {
                    owner(address: $parentId) {
                        dynamicField(name: $name) {
                            value {
                                ... on MoveValue {
                                    bcs
                                }
                            }
                        }
                    }
                }
            `),
            variables: {
                parentId: couponsTableId,
                name: {
                    type: "vector<u8>",
                    bcs: couponCodeB64
                }
            }
        });
        const couponBcsBase64 = couponResponse?.data?.owner?.dynamicField?.value?.bcs;
        if (!couponBcsBase64) {
            return null;
        }
        const couponData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$bcs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CouponBcs"].parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$bcs$2f$dist$2f$esm$2f$b64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromB64"])(couponBcsBase64));
        return {
            ...couponData,
            couponCode
        };
    }
    /**
   * Calculates the registration or renewal price for an SLN (Second Level Name).
   * It expects a name, the number of years and a `IotaNamesPriceList` object,
   * as returned from `iotaNamesClient.getPriceList()` function, or `iotaNames.getRenewalPriceList()` function.
   *
   * It throws an error:
   * 1. if the name is a subname
   * 2. if the name is not a valid IOTA name
   * 3. if the years are not between 1 and 5
   */ async calculatePrice({ name, years, isRegistration = true }) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isValidIotaName"])(name)) {
            throw new Error("Invalid IOTA names");
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateYears"])(years);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isSubname"])(name)) {
            throw new Error("Subnames do not have a registration fee");
        }
        const length = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeIotaName"])(name, "dot").split(".")[0].length;
        const priceList = await this.getPriceList();
        const renewalPriceList = await this.getRenewalPriceList();
        let yearsRemain = years;
        let price = 0;
        if (isRegistration) {
            for (const [[minLength, maxLength], pricePerYear] of priceList.entries()){
                if (length >= minLength && length <= maxLength) {
                    price += pricePerYear;
                    yearsRemain -= 1;
                    break;
                }
            }
        }
        for (const [[minLength, maxLength], pricePerYear] of renewalPriceList.entries()){
            if (length >= minLength && length <= maxLength) {
                price += yearsRemain * pricePerYear;
                break;
            }
        }
        return price;
    }
    async calculateDiscountedPrice({ coupons, name, years, isRegistration = true, address }) {
        if (coupons.every((coupon)=>typeof coupon === "string")) {
            const couponPromises = coupons.map(async (couponCode)=>{
                const coupon = await this.resolveCoupon(couponCode);
                if (!coupon) {
                    throw new Error(`Coupon not found: ${couponCode}`);
                }
                return coupon;
            });
            coupons = await Promise.all(couponPromises);
        }
        const normalizedName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeIotaName"])(name, "dot");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateIotaName"])(normalizedName);
        const nameParts = normalizedName.split(".");
        const firstNamePart = nameParts[0];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$coupons$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateCoupons"])(coupons, years, firstNamePart.length, address);
        const standardPrice = await this.calculatePrice({
            name,
            years,
            isRegistration
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$iota$2f$iota$2d$names$2d$sdk$2f$dist$2f$esm$2f$coupons$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["applyCouponsToPrice"])(coupons, standardPrice);
    }
}
;
 //# sourceMappingURL=iota-names-client.js.map
}),
];

//# sourceMappingURL=node_modules_%40iota_8aaeb524._.js.map