{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/wallet-standard/node_modules/%40iota/iota-sdk/src/client/network.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nexport enum Network {\n    Mainnet = 'mainnet',\n    Devnet = 'devnet',\n    Testnet = 'testnet',\n    Localnet = 'localnet',\n    Custom = 'custom',\n}\n\n// We also accept `string` in case we want to use a network not supported by the SDK\nexport type NetworkId = Network | string;\n\nexport type ChainType = `${string}:${string}`;\n\nexport interface NetworkConfiguration<Metadata = undefined> {\n    id: Network;\n    name: string;\n    url: string;\n    explorer: string;\n    chain: ChainType;\n    faucet?: string;\n    kiosk?: KioskConfiguration;\n    graphql?: string;\n    metadata?: Metadata;\n}\n\nexport interface KioskConfiguration {\n    royaltyRulePackageId: string;\n    kioskLockRulePackageId: string;\n    floorPriceRulePackageId: string;\n    personalKioskRulePackageId: string;\n}\n\ntype NetworksConfiguration = Record<NetworkId, NetworkConfiguration>;\n\nexport function getAllNetworks(): NetworksConfiguration {\n    const networksStringified = process.env.IOTA_NETWORKS;\n\n    if (!networksStringified) {\n        throw new Error('\"IOTA_NETWORKS\" env var is not set.');\n    }\n\n    let networks;\n\n    try {\n        networks = JSON.parse(networksStringified);\n    } catch {\n        throw new Error('Failed to parse env var \"IOTA_NETWORKS\".');\n    }\n\n    return networks;\n}\n\nexport function getNetwork<T>(network: NetworkId): NetworkConfiguration<T> {\n    const networks = getAllNetworks();\n\n    const requestedNetwork = (networks[network] ?? network) as NetworkConfiguration<T>;\n\n    return requestedNetwork;\n}\n\nexport function getDefaultNetwork(): Network {\n    return (process.env.DEFAULT_NETWORK as Network) || Network.Mainnet;\n}\n\nexport function getFullnodeUrl(network: NetworkId): string {\n    return getNetwork(network).url;\n}\n\nexport function getGraphQLUrl(network: NetworkId): string | undefined {\n    return getNetwork(network).graphql;\n}\n"],"names":["Network"],"mappings":";;;;;;;;;;;;;;AAIO,IAAK,UAAL,aAAA,GAAA,CAAA,CAAKA,aAAL;IACHA,QAAAA,CAAA,UAAA,GAAU;IACVA,QAAAA,CAAA,SAAA,GAAS;IACTA,QAAAA,CAAA,UAAA,GAAU;IACVA,QAAAA,CAAA,WAAA,GAAW;IACXA,QAAAA,CAAA,SAAA,GAAS;IALD,OAAAA;AAAA,CAAA,EAAA,WAAA,CAAA;AAkCL,SAAS,iBAAwC;IACpD,MAAM,sBAAsB;IAE5B,IAAI,CAAC,qBAAqB;;IAI1B,IAAI;IAEJ,IAAI;QACA,WAAW,KAAK,KAAA,CAAM,mBAAmB;IAC7C,EAAA,OAAQ;QACJ,MAAM,IAAI,MAAM,0CAA0C;IAC9D;IAEA,OAAO;AACX;AAEO,SAAS,WAAc,OAAA,EAA6C;IACvE,MAAM,WAAW,eAAe;IAEhC,MAAM,mBAAoB,QAAA,CAAS,OAAO,CAAA,IAAK;IAE/C,OAAO;AACX;AAEO,SAAS,oBAA6B;IACzC,OAAQ;AACZ;AAEO,SAAS,eAAe,OAAA,EAA4B;IACvD,OAAO,WAAW,OAAO,EAAE,GAAA;AAC/B;AAEO,SAAS,cAAc,OAAA,EAAwC;IAClE,OAAO,WAAW,OAAO,EAAE,OAAA;AAC/B"}},
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/utils/iota-types.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, splitGenericParameters } from '@iota/bcs';\n\nconst TX_DIGEST_LENGTH = 32;\n\n/** Returns whether the tx digest is valid based on the serialization format */\nexport function isValidTransactionDigest(value: string): value is string {\n    try {\n        const buffer = fromB58(value);\n        return buffer.length === TX_DIGEST_LENGTH;\n    } catch (e) {\n        return false;\n    }\n}\n\n// TODO - can we automatically sync this with rust length definition?\n// Source of truth is\n// https://github.com/iotaledger/iota/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/iota-types/src/base_types.rs#L67\n// which uses the Move account address length\n// https://github.com/move-language/move/blob/67ec40dc50c66c34fd73512fcc412f3b68d67235/language/move-core/types/src/account_address.rs#L23 .\n\nexport const IOTA_ADDRESS_LENGTH = 32;\nexport function isValidIotaAddress(value: string): value is string {\n    return isHex(value) && getHexByteLength(value) === IOTA_ADDRESS_LENGTH;\n}\n\nexport function isValidIotaObjectId(value: string): boolean {\n    return isValidIotaAddress(value);\n}\n\ntype StructTag = {\n    address: string;\n    module: string;\n    name: string;\n    typeParams: (string | StructTag)[];\n};\n\nfunction parseTypeTag(type: string): string | StructTag {\n    if (!type.includes('::')) return type;\n\n    return parseStructTag(type);\n}\n\nexport function parseStructTag(type: string): StructTag {\n    const [address, module] = type.split('::');\n\n    const rest = type.slice(address.length + module.length + 4);\n    const name = rest.includes('<') ? rest.slice(0, rest.indexOf('<')) : rest;\n    const typeParams = rest.includes('<')\n        ? splitGenericParameters(rest.slice(rest.indexOf('<') + 1, rest.lastIndexOf('>'))).map(\n              (typeParam) => parseTypeTag(typeParam.trim()),\n          )\n        : [];\n\n    return {\n        address: normalizeIotaAddress(address),\n        module,\n        name,\n        typeParams,\n    };\n}\n\nexport function normalizeStructTag(type: string | StructTag): string {\n    const { address, module, name, typeParams } =\n        typeof type === 'string' ? parseStructTag(type) : type;\n\n    const formattedTypeParams =\n        typeParams?.length > 0\n            ? `<${typeParams\n                  .map((typeParam) =>\n                      typeof typeParam === 'string' ? typeParam : normalizeStructTag(typeParam),\n                  )\n                  .join(',')}>`\n            : '';\n\n    return `${address}::${module}::${name}${formattedTypeParams}`;\n}\n\n/**\n * Normalize an IOTA address to ensure consistent format.\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `IOTA_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n * @param value The address to normalize\n * @param forceAdd0x Whether to add 0x prefix without removing any existing 0x prefixes\n * @param validate Whether to validate the return address\n * @returns The normalized address\n * @throws Error if flag `validate` enabled and the address contains invalid hex characters\n */\nexport function normalizeIotaAddress(\n    value: string,\n    forceAdd0x: boolean = false,\n    validate: boolean = false,\n): string {\n    let address = value.toLowerCase().replace(/ /g, '');\n    if (!forceAdd0x && address.startsWith('0x')) {\n        address = address.slice(2);\n    }\n    address = `0x${address.padStart(IOTA_ADDRESS_LENGTH * 2, '0')}`;\n    if (validate && !isValidIotaAddress(address)) {\n        throw new Error(`Invalid IOTA address: ${value}`);\n    } else {\n        return address;\n    }\n}\n\nexport function normalizeIotaObjectId(\n    value: string,\n    forceAdd0x: boolean = false,\n    validate: boolean = false,\n): string {\n    return normalizeIotaAddress(value, forceAdd0x, validate);\n}\n\nfunction isHex(value: string): boolean {\n    return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\n\nfunction getHexByteLength(value: string): number {\n    return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAIA,SAAS,SAAS,8BAA8B;;AAEhD,MAAM,mBAAmB;AAGlB,SAAS,yBAAyB,KAAA,EAAgC;IACrE,IAAI;QACA,MAAM,aAAS,0MAAA,EAAQ,KAAK;QAC5B,OAAO,OAAO,MAAA,KAAW;IAC7B,EAAA,OAAS,GAAG;QACR,OAAO;IACX;AACJ;AAQO,MAAM,sBAAsB;AAC5B,SAAS,mBAAmB,KAAA,EAAgC;IAC/D,OAAO,MAAM,KAAK,KAAK,iBAAiB,KAAK,MAAM;AACvD;AAEO,SAAS,oBAAoB,KAAA,EAAwB;IACxD,OAAO,mBAAmB,KAAK;AACnC;AASA,SAAS,aAAa,IAAA,EAAkC;IACpD,IAAI,CAAC,KAAK,QAAA,CAAS,IAAI,EAAG,CAAA,OAAO;IAEjC,OAAO,eAAe,IAAI;AAC9B;AAEO,SAAS,eAAe,IAAA,EAAyB;IACpD,MAAM,CAAC,SAAS,MAAM,CAAA,GAAI,KAAK,KAAA,CAAM,IAAI;IAEzC,MAAM,OAAO,KAAK,KAAA,CAAM,QAAQ,MAAA,GAAS,OAAO,MAAA,GAAS,CAAC;IAC1D,MAAM,OAAO,KAAK,QAAA,CAAS,GAAG,IAAI,KAAK,KAAA,CAAM,GAAG,KAAK,OAAA,CAAQ,GAAG,CAAC,IAAI;IACrE,MAAM,aAAa,KAAK,QAAA,CAAS,GAAG,QAC9B,2NAAA,EAAuB,KAAK,KAAA,CAAM,KAAK,OAAA,CAAQ,GAAG,IAAI,GAAG,KAAK,WAAA,CAAY,GAAG,CAAC,CAAC,EAAE,GAAA,CAC7E,CAAC,YAAc,aAAa,UAAU,IAAA,CAAK,CAAC,KAEhD,CAAC,CAAA;IAEP,OAAO;QACH,SAAS,qBAAqB,OAAO;QACrC;QACA;QACA;IACJ;AACJ;AAEO,SAAS,mBAAmB,IAAA,EAAkC;IACjE,MAAM,EAAE,OAAA,EAAS,MAAA,EAAQ,IAAA,EAAM,UAAA,CAAW,CAAA,GACtC,OAAO,SAAS,WAAW,eAAe,IAAI,IAAI;IAEtD,MAAM,sBACF,YAAY,SAAS,IACf,CAAA,CAAA,EAAI,WACC,GAAA,CAAI,CAAC,YACF,OAAO,cAAc,WAAW,YAAY,mBAAmB,SAAS,GAE3E,IAAA,CAAK,GAAG,CAAC,CAAA,CAAA,CAAA,GACd;IAEV,OAAO,GAAG,OAAO,CAAA,EAAA,EAAK,MAAM,CAAA,EAAA,EAAK,IAAI,GAAG,mBAAmB,EAAA;AAC/D;AAmBO,SAAS,qBACZ,KAAA,EACA,aAAsB,KAAA,EACtB,WAAoB,KAAA,EACd;IACN,IAAI,UAAU,MAAM,WAAA,CAAY,EAAE,OAAA,CAAQ,MAAM,EAAE;IAClD,IAAI,CAAC,cAAc,QAAQ,UAAA,CAAW,IAAI,GAAG;QACzC,UAAU,QAAQ,KAAA,CAAM,CAAC;IAC7B;IACA,UAAU,CAAA,EAAA,EAAK,QAAQ,QAAA,CAAS,sBAAsB,GAAG,GAAG,CAAC,EAAA;IAC7D,IAAI,YAAY,CAAC,mBAAmB,OAAO,GAAG;QAC1C,MAAM,IAAI,MAAM,CAAA,sBAAA,EAAyB,KAAK,EAAE;IACpD,OAAO;QACH,OAAO;IACX;AACJ;AAEO,SAAS,sBACZ,KAAA,EACA,aAAsB,KAAA,EACtB,WAAoB,KAAA,EACd;IACN,OAAO,qBAAqB,OAAO,YAAY,QAAQ;AAC3D;AAEA,SAAS,MAAM,KAAA,EAAwB;IACnC,OAAO,yBAAyB,IAAA,CAAK,KAAK,KAAK,MAAM,MAAA,GAAS,MAAM;AACxE;AAEA,SAAS,iBAAiB,KAAA,EAAuB;IAC7C,OAAO,WAAW,IAAA,CAAK,KAAK,IAAA,CAAK,MAAM,MAAA,GAAS,CAAA,IAAK,IAAI,MAAM,MAAA,GAAS;AAC5E"}},
    {"offset": {"line": 143, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/utils/format.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isValidIotaAddress, isValidIotaObjectId, IOTA_ADDRESS_LENGTH } from './iota-types.js';\n\nconst ELLIPSIS = '\\u{2026}';\n\nexport function formatAddress(address: string) {\n    if (address.length <= 6) {\n        return address;\n    }\n\n    const offset = address.startsWith('0x') ? 2 : 0;\n\n    return `0x${address.slice(offset, offset + 4)}${ELLIPSIS}${address.slice(-4)}`;\n}\n\nexport function formatDigest(digest: string) {\n    // Use 10 first characters\n    return `${digest.slice(0, 10)}${ELLIPSIS}`;\n}\n\nexport function formatType(type: string) {\n    const objectAddressPattern = new RegExp(`0x[a-fA-F0-9]{${IOTA_ADDRESS_LENGTH * 2}}`, 'g');\n    const matches = type.match(objectAddressPattern) ?? [];\n    for (const match of matches) {\n        if (isValidIotaAddress(match) || isValidIotaObjectId(match)) {\n            type = type.replace(match, formatAddress(match));\n        }\n    }\n    return type;\n}\n\nconst ADDRESS_TRIM_MAX_LENGTH = 8;\n\nexport function trimAddress(address: string): string {\n    const addr = address.toLowerCase().replace(/^0x/, '');\n    const shortened = addr.replace(/^0+/, '') || '0';\n    return `0x${shortened}`;\n}\n\nexport function trimOrFormatAddress(address: string): string {\n    if (address.length <= 6) {\n        return address;\n    }\n\n    const trimmedAddress = trimAddress(address);\n\n    if (trimmedAddress.length <= ADDRESS_TRIM_MAX_LENGTH) {\n        return trimmedAddress;\n    }\n\n    return formatAddress(address);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAIA,SAAS,oBAAoB,qBAAqB,2BAA2B;;AAE7E,MAAM,WAAW;AAEV,SAAS,cAAc,OAAA,EAAiB;IAC3C,IAAI,QAAQ,MAAA,IAAU,GAAG;QACrB,OAAO;IACX;IAEA,MAAM,SAAS,QAAQ,UAAA,CAAW,IAAI,IAAI,IAAI;IAE9C,OAAO,CAAA,EAAA,EAAK,QAAQ,KAAA,CAAM,QAAQ,SAAS,CAAC,CAAC,GAAG,QAAQ,GAAG,QAAQ,KAAA,CAAM,CAAA,CAAE,CAAC,EAAA;AAChF;AAEO,SAAS,aAAa,MAAA,EAAgB;IAEzC,OAAO,GAAG,OAAO,KAAA,CAAM,GAAG,EAAE,CAAC,GAAG,QAAQ,EAAA;AAC5C;AAEO,SAAS,WAAW,IAAA,EAAc;IACrC,MAAM,uBAAuB,IAAI,OAAO,CAAA,cAAA,EAAiB,iPAAA,GAAsB,CAAC,CAAA,CAAA,CAAA,EAAK,GAAG;IACxF,MAAM,UAAU,KAAK,KAAA,CAAM,oBAAoB,KAAK,CAAC,CAAA;IACrD,KAAA,MAAW,SAAS,QAAS;QACzB,QAAI,gPAAA,EAAmB,KAAK,SAAK,iPAAA,EAAoB,KAAK,GAAG;YACzD,OAAO,KAAK,OAAA,CAAQ,OAAO,cAAc,KAAK,CAAC;QACnD;IACJ;IACA,OAAO;AACX;AAEA,MAAM,0BAA0B;AAEzB,SAAS,YAAY,OAAA,EAAyB;IACjD,MAAM,OAAO,QAAQ,WAAA,CAAY,EAAE,OAAA,CAAQ,OAAO,EAAE;IACpD,MAAM,YAAY,KAAK,OAAA,CAAQ,OAAO,EAAE,KAAK;IAC7C,OAAO,CAAA,EAAA,EAAK,SAAS,EAAA;AACzB;AAEO,SAAS,oBAAoB,OAAA,EAAyB;IACzD,IAAI,QAAQ,MAAA,IAAU,GAAG;QACrB,OAAO;IACX;IAEA,MAAM,iBAAiB,YAAY,OAAO;IAE1C,IAAI,eAAe,MAAA,IAAU,yBAAyB;QAClD,OAAO;IACX;IAEA,OAAO,cAAc,OAAO;AAChC"}},
    {"offset": {"line": 200, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/client/network.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nexport enum Network {\n    Mainnet = 'mainnet',\n    Devnet = 'devnet',\n    Testnet = 'testnet',\n    Localnet = 'localnet',\n    Custom = 'custom',\n}\n\n// We also accept `string` in case we want to use a network not supported by the SDK\nexport type NetworkId = Network | string;\n\nexport type ChainType = `${string}:${string}`;\n\nexport interface NetworkConfiguration<Metadata = undefined> {\n    id: Network;\n    name: string;\n    url: string;\n    explorer: string;\n    chain: ChainType;\n    faucet?: string;\n    kiosk?: KioskConfiguration;\n    graphql?: string;\n    metadata?: Metadata;\n}\n\nexport interface KioskConfiguration {\n    royaltyRulePackageId: string;\n    kioskLockRulePackageId: string;\n    floorPriceRulePackageId: string;\n    personalKioskRulePackageId: string;\n}\n\ntype NetworksConfiguration = Record<NetworkId, NetworkConfiguration>;\n\nexport function getAllNetworks(): NetworksConfiguration {\n    const networksStringified = process.env.IOTA_NETWORKS;\n\n    if (!networksStringified) {\n        throw new Error('\"IOTA_NETWORKS\" env var is not set.');\n    }\n\n    let networks;\n\n    try {\n        networks = JSON.parse(networksStringified);\n    } catch {\n        throw new Error('Failed to parse env var \"IOTA_NETWORKS\".');\n    }\n\n    return networks;\n}\n\nexport function getNetwork<T>(network: NetworkId): NetworkConfiguration<T> {\n    const networks = getAllNetworks();\n\n    const requestedNetwork = (networks[network] ?? network) as NetworkConfiguration<T>;\n\n    return requestedNetwork;\n}\n\nexport function getDefaultNetwork(): Network {\n    return (process.env.DEFAULT_NETWORK as Network) || Network.Mainnet;\n}\n\nexport function getFullnodeUrl(network: NetworkId): string {\n    return getNetwork(network).url;\n}\n\nexport function getGraphQLUrl(network: NetworkId): string | undefined {\n    return getNetwork(network).graphql;\n}\n"],"names":["Network"],"mappings":";;;;;;;;;;;;;;AAIO,IAAK,UAAL,aAAA,GAAA,CAAA,CAAKA,aAAL;IACHA,QAAAA,CAAA,UAAA,GAAU;IACVA,QAAAA,CAAA,SAAA,GAAS;IACTA,QAAAA,CAAA,UAAA,GAAU;IACVA,QAAAA,CAAA,WAAA,GAAW;IACXA,QAAAA,CAAA,SAAA,GAAS;IALD,OAAAA;AAAA,CAAA,EAAA,WAAA,CAAA;AAkCL,SAAS,iBAAwC;IACpD,MAAM,sBAAsB;IAE5B,IAAI,CAAC,qBAAqB;;IAI1B,IAAI;IAEJ,IAAI;QACA,WAAW,KAAK,KAAA,CAAM,mBAAmB;IAC7C,EAAA,OAAQ;QACJ,MAAM,IAAI,MAAM,0CAA0C;IAC9D;IAEA,OAAO;AACX;AAEO,SAAS,WAAc,OAAA,EAA6C;IACvE,MAAM,WAAW,eAAe;IAEhC,MAAM,mBAAoB,QAAA,CAAS,OAAO,CAAA,IAAK;IAE/C,OAAO;AACX;AAEO,SAAS,oBAA6B;IACzC,OAAQ;AACZ;AAEO,SAAS,eAAe,OAAA,EAA4B;IACvD,OAAO,WAAW,OAAO,EAAE,GAAA;AAC/B;AAEO,SAAS,cAAc,OAAA,EAAwC;IAClE,OAAO,WAAW,OAAO,EAAE,OAAA;AAC/B"}},
    {"offset": {"line": 254, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/iota-sdk/src/utils/iota-types.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, splitGenericParameters } from '@iota/bcs';\n\nconst TX_DIGEST_LENGTH = 32;\n\n/** Returns whether the tx digest is valid based on the serialization format */\nexport function isValidTransactionDigest(value: string): value is string {\n    try {\n        const buffer = fromB58(value);\n        return buffer.length === TX_DIGEST_LENGTH;\n    } catch (e) {\n        return false;\n    }\n}\n\n// TODO - can we automatically sync this with rust length definition?\n// Source of truth is\n// https://github.com/iotaledger/iota/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/iota-types/src/base_types.rs#L67\n// which uses the Move account address length\n// https://github.com/move-language/move/blob/67ec40dc50c66c34fd73512fcc412f3b68d67235/language/move-core/types/src/account_address.rs#L23 .\n\nexport const IOTA_ADDRESS_LENGTH = 32;\nexport function isValidIotaAddress(value: string): value is string {\n    return isHex(value) && getHexByteLength(value) === IOTA_ADDRESS_LENGTH;\n}\n\nexport function isValidIotaObjectId(value: string): boolean {\n    return isValidIotaAddress(value);\n}\n\ntype StructTag = {\n    address: string;\n    module: string;\n    name: string;\n    typeParams: (string | StructTag)[];\n};\n\nfunction parseTypeTag(type: string): string | StructTag {\n    if (!type.includes('::')) return type;\n\n    return parseStructTag(type);\n}\n\nexport function parseStructTag(type: string): StructTag {\n    const [address, module] = type.split('::');\n\n    const rest = type.slice(address.length + module.length + 4);\n    const name = rest.includes('<') ? rest.slice(0, rest.indexOf('<')) : rest;\n    const typeParams = rest.includes('<')\n        ? splitGenericParameters(rest.slice(rest.indexOf('<') + 1, rest.lastIndexOf('>'))).map(\n              (typeParam) => parseTypeTag(typeParam.trim()),\n          )\n        : [];\n\n    return {\n        address: normalizeIotaAddress(address),\n        module,\n        name,\n        typeParams,\n    };\n}\n\nexport function normalizeStructTag(type: string | StructTag): string {\n    const { address, module, name, typeParams } =\n        typeof type === 'string' ? parseStructTag(type) : type;\n\n    const formattedTypeParams =\n        typeParams?.length > 0\n            ? `<${typeParams\n                  .map((typeParam) =>\n                      typeof typeParam === 'string' ? typeParam : normalizeStructTag(typeParam),\n                  )\n                  .join(',')}>`\n            : '';\n\n    return `${address}::${module}::${name}${formattedTypeParams}`;\n}\n\n/**\n * Normalize an IOTA address to ensure consistent format.\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `IOTA_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n * @param value The address to normalize\n * @param forceAdd0x Whether to add 0x prefix without removing any existing 0x prefixes\n * @param validate Whether to validate the return address\n * @returns The normalized address\n * @throws Error if flag `validate` enabled and the address contains invalid hex characters\n */\nexport function normalizeIotaAddress(\n    value: string,\n    forceAdd0x: boolean = false,\n    validate: boolean = false,\n): string {\n    let address = value.toLowerCase().replace(/ /g, '');\n    if (!forceAdd0x && address.startsWith('0x')) {\n        address = address.slice(2);\n    }\n    address = `0x${address.padStart(IOTA_ADDRESS_LENGTH * 2, '0')}`;\n    if (validate && !isValidIotaAddress(address)) {\n        throw new Error(`Invalid IOTA address: ${value}`);\n    } else {\n        return address;\n    }\n}\n\nexport function normalizeIotaObjectId(\n    value: string,\n    forceAdd0x: boolean = false,\n    validate: boolean = false,\n): string {\n    return normalizeIotaAddress(value, forceAdd0x, validate);\n}\n\nfunction isHex(value: string): boolean {\n    return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\n\nfunction getHexByteLength(value: string): number {\n    return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAIA,SAAS,SAAS,8BAA8B;;AAEhD,MAAM,mBAAmB;AAGlB,SAAS,yBAAyB,KAAA,EAAgC;IACrE,IAAI;QACA,MAAM,aAAS,iKAAA,EAAQ,KAAK;QAC5B,OAAO,OAAO,MAAA,KAAW;IAC7B,EAAA,OAAS,GAAG;QACR,OAAO;IACX;AACJ;AAQO,MAAM,sBAAsB;AAC5B,SAAS,mBAAmB,KAAA,EAAgC;IAC/D,OAAO,MAAM,KAAK,KAAK,iBAAiB,KAAK,MAAM;AACvD;AAEO,SAAS,oBAAoB,KAAA,EAAwB;IACxD,OAAO,mBAAmB,KAAK;AACnC;AASA,SAAS,aAAa,IAAA,EAAkC;IACpD,IAAI,CAAC,KAAK,QAAA,CAAS,IAAI,EAAG,CAAA,OAAO;IAEjC,OAAO,eAAe,IAAI;AAC9B;AAEO,SAAS,eAAe,IAAA,EAAyB;IACpD,MAAM,CAAC,SAAS,MAAM,CAAA,GAAI,KAAK,KAAA,CAAM,IAAI;IAEzC,MAAM,OAAO,KAAK,KAAA,CAAM,QAAQ,MAAA,GAAS,OAAO,MAAA,GAAS,CAAC;IAC1D,MAAM,OAAO,KAAK,QAAA,CAAS,GAAG,IAAI,KAAK,KAAA,CAAM,GAAG,KAAK,OAAA,CAAQ,GAAG,CAAC,IAAI;IACrE,MAAM,aAAa,KAAK,QAAA,CAAS,GAAG,QAC9B,kLAAA,EAAuB,KAAK,KAAA,CAAM,KAAK,OAAA,CAAQ,GAAG,IAAI,GAAG,KAAK,WAAA,CAAY,GAAG,CAAC,CAAC,EAAE,GAAA,CAC7E,CAAC,YAAc,aAAa,UAAU,IAAA,CAAK,CAAC,KAEhD,CAAC,CAAA;IAEP,OAAO;QACH,SAAS,qBAAqB,OAAO;QACrC;QACA;QACA;IACJ;AACJ;AAEO,SAAS,mBAAmB,IAAA,EAAkC;IACjE,MAAM,EAAE,OAAA,EAAS,MAAA,EAAQ,IAAA,EAAM,UAAA,CAAW,CAAA,GACtC,OAAO,SAAS,WAAW,eAAe,IAAI,IAAI;IAEtD,MAAM,sBACF,YAAY,SAAS,IACf,CAAA,CAAA,EAAI,WACC,GAAA,CAAI,CAAC,YACF,OAAO,cAAc,WAAW,YAAY,mBAAmB,SAAS,GAE3E,IAAA,CAAK,GAAG,CAAC,CAAA,CAAA,CAAA,GACd;IAEV,OAAO,GAAG,OAAO,CAAA,EAAA,EAAK,MAAM,CAAA,EAAA,EAAK,IAAI,GAAG,mBAAmB,EAAA;AAC/D;AAmBO,SAAS,qBACZ,KAAA,EACA,aAAsB,KAAA,EACtB,WAAoB,KAAA,EACd;IACN,IAAI,UAAU,MAAM,WAAA,CAAY,EAAE,OAAA,CAAQ,MAAM,EAAE;IAClD,IAAI,CAAC,cAAc,QAAQ,UAAA,CAAW,IAAI,GAAG;QACzC,UAAU,QAAQ,KAAA,CAAM,CAAC;IAC7B;IACA,UAAU,CAAA,EAAA,EAAK,QAAQ,QAAA,CAAS,sBAAsB,GAAG,GAAG,CAAC,EAAA;IAC7D,IAAI,YAAY,CAAC,mBAAmB,OAAO,GAAG;QAC1C,MAAM,IAAI,MAAM,CAAA,sBAAA,EAAyB,KAAK,EAAE;IACpD,OAAO;QACH,OAAO;IACX;AACJ;AAEO,SAAS,sBACZ,KAAA,EACA,aAAsB,KAAA,EACtB,WAAoB,KAAA,EACd;IACN,OAAO,qBAAqB,OAAO,YAAY,QAAQ;AAC3D;AAEA,SAAS,MAAM,KAAA,EAAwB;IACnC,OAAO,yBAAyB,IAAA,CAAK,KAAK,KAAK,MAAM,MAAA,GAAS,MAAM;AACxE;AAEA,SAAS,iBAAiB,KAAA,EAAuB;IAC7C,OAAO,WAAW,IAAA,CAAK,KAAK,IAAA,CAAK,MAAM,MAAA,GAAS,CAAA,IAAK,IAAI,MAAM,MAAA,GAAS;AAC5E"}},
    {"offset": {"line": 339, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/iota-sdk/src/bcs/type-tag-serializer.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { splitGenericParameters } from '@iota/bcs';\n\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { TypeTag } from './types.js';\n\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\nexport class TypeTagSerializer {\n    static parseFromStr(str: string, normalizeAddress = false): TypeTag {\n        if (str === 'address') {\n            return { address: null };\n        } else if (str === 'bool') {\n            return { bool: null };\n        } else if (str === 'u8') {\n            return { u8: null };\n        } else if (str === 'u16') {\n            return { u16: null };\n        } else if (str === 'u32') {\n            return { u32: null };\n        } else if (str === 'u64') {\n            return { u64: null };\n        } else if (str === 'u128') {\n            return { u128: null };\n        } else if (str === 'u256') {\n            return { u256: null };\n        } else if (str === 'signer') {\n            return { signer: null };\n        }\n\n        const vectorMatch = str.match(VECTOR_REGEX);\n        if (vectorMatch) {\n            return {\n                vector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),\n            };\n        }\n\n        const structMatch = str.match(STRUCT_REGEX);\n        if (structMatch) {\n            const address = normalizeAddress\n                ? normalizeIotaAddress(structMatch[1])\n                : structMatch[1];\n            return {\n                struct: {\n                    address,\n                    module: structMatch[2],\n                    name: structMatch[3],\n                    typeParams:\n                        structMatch[5] === undefined\n                            ? []\n                            : TypeTagSerializer.parseStructTypeArgs(\n                                  structMatch[5],\n                                  normalizeAddress,\n                              ),\n                },\n            };\n        }\n\n        throw new Error(`Encountered unexpected token when parsing type args for ${str}`);\n    }\n\n    static parseStructTypeArgs(str: string, normalizeAddress = false): TypeTag[] {\n        return splitGenericParameters(str).map((tok) =>\n            TypeTagSerializer.parseFromStr(tok, normalizeAddress),\n        );\n    }\n\n    static tagToString(tag: TypeTag): string {\n        if ('bool' in tag) {\n            return 'bool';\n        }\n        if ('u8' in tag) {\n            return 'u8';\n        }\n        if ('u16' in tag) {\n            return 'u16';\n        }\n        if ('u32' in tag) {\n            return 'u32';\n        }\n        if ('u64' in tag) {\n            return 'u64';\n        }\n        if ('u128' in tag) {\n            return 'u128';\n        }\n        if ('u256' in tag) {\n            return 'u256';\n        }\n        if ('address' in tag) {\n            return 'address';\n        }\n        if ('signer' in tag) {\n            return 'signer';\n        }\n        if ('vector' in tag) {\n            return `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n        }\n        if ('struct' in tag) {\n            const struct = tag.struct;\n            const typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');\n            return `${struct.address}::${struct.module}::${struct.name}${\n                typeParams ? `<${typeParams}>` : ''\n            }`;\n        }\n        throw new Error('Invalid TypeTag');\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 456, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/iota-sdk/src/bcs/bcs.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType, BcsTypeOptions } from '@iota/bcs';\nimport { bcs, fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from '@iota/bcs';\n\nimport {\n    isValidIotaAddress,\n    normalizeIotaAddress,\n    IOTA_ADDRESS_LENGTH,\n} from '../utils/iota-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\nimport type { TypeTag as TypeTagType } from './types.js';\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n    return bcs\n        .u64({\n            name: 'unsafe_u64',\n            ...(options as object),\n        })\n        .transform({\n            input: (val: number | string) => val,\n            output: (val) => Number(val),\n        });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n    return bcs.enum('Option', {\n        None: null,\n        Some: type,\n    });\n}\n\nexport const Address = bcs.bytes(IOTA_ADDRESS_LENGTH).transform({\n    validate: (val) => {\n        const address = typeof val === 'string' ? val : toHex(val);\n        if (!address || !isValidIotaAddress(normalizeIotaAddress(address))) {\n            throw new Error(`Invalid IOTA address ${address}`);\n        }\n    },\n    input: (val: string | Uint8Array) =>\n        typeof val === 'string' ? fromHex(normalizeIotaAddress(val)) : val,\n    output: (val) => normalizeIotaAddress(toHex(val)),\n});\n\nexport const ObjectDigest = bcs.vector(bcs.u8()).transform({\n    name: 'ObjectDigest',\n    input: (value: string) => fromBase58(value),\n    output: (value) => toBase58(new Uint8Array(value)),\n    validate: (value) => {\n        if (fromBase58(value).length !== 32) {\n            throw new Error('ObjectDigest must be 32 bytes');\n        }\n    },\n});\n\nexport const IotaObjectRef = bcs.struct('IotaObjectRef', {\n    objectId: Address,\n    version: bcs.u64(),\n    digest: ObjectDigest,\n});\n\nexport const SharedObjectRef = bcs.struct('SharedObjectRef', {\n    objectId: Address,\n    initialSharedVersion: bcs.u64(),\n    mutable: bcs.bool(),\n});\n\nexport const ObjectArg = bcs.enum('ObjectArg', {\n    ImmOrOwnedObject: IotaObjectRef,\n    SharedObject: SharedObjectRef,\n    Receiving: IotaObjectRef,\n});\n\nexport const Owner = bcs.enum('Owner', {\n    AddressOwner: Address,\n    ObjectOwner: Address,\n    Shared: bcs.struct('Shared', {\n        initialSharedVersion: bcs.u64(),\n    }),\n    Immutable: null,\n});\n\nexport const CallArg = bcs.enum('CallArg', {\n    Pure: bcs.struct('Pure', {\n        bytes: bcs.vector(bcs.u8()).transform({\n            input: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n            output: (val) => toBase64(new Uint8Array(val)),\n        }),\n    }),\n    Object: ObjectArg,\n});\n\nconst InnerTypeTag: BcsType<TypeTagType, TypeTagType> = bcs.enum('TypeTag', {\n    bool: null,\n    u8: null,\n    u64: null,\n    u128: null,\n    address: null,\n    signer: null,\n    vector: bcs.lazy(() => InnerTypeTag),\n    struct: bcs.lazy(() => StructTag),\n    u16: null,\n    u32: null,\n    u256: null,\n}) as BcsType<TypeTagType>;\n\nexport const TypeTag = InnerTypeTag.transform({\n    input: (typeTag: string | TypeTagType) =>\n        typeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,\n    output: (typeTag: TypeTagType) => TypeTagSerializer.tagToString(typeTag),\n});\n\nexport const Argument = bcs.enum('Argument', {\n    GasCoin: null,\n    Input: bcs.u16(),\n    Result: bcs.u16(),\n    NestedResult: bcs.tuple([bcs.u16(), bcs.u16()]),\n});\n\nexport const ProgrammableMoveCall = bcs.struct('ProgrammableMoveCall', {\n    package: Address,\n    module: bcs.string(),\n    function: bcs.string(),\n    typeArguments: bcs.vector(TypeTag),\n    arguments: bcs.vector(Argument),\n});\n\nexport const Command = bcs.enum('Command', {\n    /**\n     * A Move Call - any public Move function can be called via\n     * this transaction. The results can be used that instant to pass\n     * into the next transaction.\n     */\n    MoveCall: ProgrammableMoveCall,\n    /**\n     * Transfer vector of objects to a receiver.\n     */\n    TransferObjects: bcs.struct('TransferObjects', {\n        objects: bcs.vector(Argument),\n        address: Argument,\n    }),\n    // /**\n    //  * Split `amount` from a `coin`.\n    //  */\n    SplitCoins: bcs.struct('SplitCoins', {\n        coin: Argument,\n        amounts: bcs.vector(Argument),\n    }),\n    // /**\n    //  * Merge Vector of Coins (`sources`) into a `destination`.\n    //  */\n    MergeCoins: bcs.struct('MergeCoins', {\n        destination: Argument,\n        sources: bcs.vector(Argument),\n    }),\n    // /**\n    //  * Publish a Move module.\n    //  */\n    Publish: bcs.struct('Publish', {\n        modules: bcs.vector(\n            bcs.vector(bcs.u8()).transform({\n                input: (val: string | Uint8Array) =>\n                    typeof val === 'string' ? fromBase64(val) : val,\n                output: (val) => toBase64(new Uint8Array(val)),\n            }),\n        ),\n        dependencies: bcs.vector(Address),\n    }),\n    // /**\n    //  * Build a vector of objects using the input arguments.\n    //  * It is impossible to export construct a `vector<T: key>` otherwise,\n    //  * so this call serves a utility function.\n    //  */\n    MakeMoveVec: bcs.struct('MakeMoveVec', {\n        type: optionEnum(TypeTag).transform({\n            input: (val: string | null) =>\n                val === null\n                    ? {\n                          None: true,\n                      }\n                    : {\n                          Some: val,\n                      },\n            output: (val) => val.Some ?? null,\n        }),\n        elements: bcs.vector(Argument),\n    }),\n    Upgrade: bcs.struct('Upgrade', {\n        modules: bcs.vector(\n            bcs.vector(bcs.u8()).transform({\n                input: (val: string | Uint8Array) =>\n                    typeof val === 'string' ? fromBase64(val) : val,\n                output: (val) => toBase64(new Uint8Array(val)),\n            }),\n        ),\n        dependencies: bcs.vector(Address),\n        package: Address,\n        ticket: Argument,\n    }),\n});\n\nexport const ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n    inputs: bcs.vector(CallArg),\n    commands: bcs.vector(Command),\n});\n\nexport const TransactionKind = bcs.enum('TransactionKind', {\n    ProgrammableTransaction: ProgrammableTransaction,\n    ChangeEpoch: null,\n    Genesis: null,\n    ConsensusCommitPrologue: null,\n});\n\nexport const TransactionExpiration = bcs.enum('TransactionExpiration', {\n    None: null,\n    Epoch: unsafe_u64(),\n});\n\nexport const StructTag = bcs.struct('StructTag', {\n    address: Address,\n    module: bcs.string(),\n    name: bcs.string(),\n    typeParams: bcs.vector(InnerTypeTag),\n});\n\nexport const GasData = bcs.struct('GasData', {\n    payment: bcs.vector(IotaObjectRef),\n    owner: Address,\n    price: bcs.u64(),\n    budget: bcs.u64(),\n});\n\nexport const TransactionDataV1 = bcs.struct('TransactionDataV1', {\n    kind: TransactionKind,\n    sender: Address,\n    gasData: GasData,\n    expiration: TransactionExpiration,\n});\n\nexport const TransactionData = bcs.enum('TransactionData', {\n    V1: TransactionDataV1,\n});\n\nexport const IntentScope = bcs.enum('IntentScope', {\n    TransactionData: null,\n    TransactionEffects: null,\n    CheckpointSummary: null,\n    PersonalMessage: null,\n});\n\nexport const IntentVersion = bcs.enum('IntentVersion', {\n    V0: null,\n});\n\nexport const AppId = bcs.enum('AppId', {\n    Iota: null,\n});\n\nexport const Intent = bcs.struct('Intent', {\n    scope: IntentScope,\n    version: IntentVersion,\n    appId: AppId,\n});\n\nexport function IntentMessage<T extends BcsType<any>>(T: T) {\n    return bcs.struct(`IntentMessage<${T.name}>`, {\n        intent: Intent,\n        value: T,\n    });\n}\n\nexport const CompressedSignature = bcs.enum('CompressedSignature', {\n    ED25519: bcs.fixedArray(64, bcs.u8()),\n    Secp256k1: bcs.fixedArray(64, bcs.u8()),\n    Secp256r1: bcs.fixedArray(64, bcs.u8()),\n});\n\nexport const PublicKey = bcs.enum('PublicKey', {\n    ED25519: bcs.fixedArray(32, bcs.u8()),\n    Secp256k1: bcs.fixedArray(33, bcs.u8()),\n    Secp256r1: bcs.fixedArray(33, bcs.u8()),\n});\n\nexport const MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n    pubKey: PublicKey,\n    weight: bcs.u8(),\n});\n\nexport const MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n    pk_map: bcs.vector(MultiSigPkMap),\n    threshold: bcs.u16(),\n});\n\nexport const MultiSig = bcs.struct('MultiSig', {\n    sigs: bcs.vector(CompressedSignature),\n    bitmap: bcs.u16(),\n    multisig_pk: MultiSigPublicKey,\n});\n\nexport const base64String = bcs.vector(bcs.u8()).transform({\n    input: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n    output: (val) => toBase64(new Uint8Array(val)),\n});\n\nexport const SenderSignedTransaction = bcs.struct('SenderSignedTransaction', {\n    intentMessage: IntentMessage(TransactionData),\n    txSignatures: bcs.vector(base64String),\n});\n\nexport const SenderSignedData = bcs.vector(SenderSignedTransaction, {\n    name: 'SenderSignedData',\n});\n\nexport const PasskeyAuthenticator = bcs.struct('PasskeyAuthenticator', {\n    authenticatorData: bcs.vector(bcs.u8()),\n    clientDataJson: bcs.string(),\n    userSignature: bcs.vector(bcs.u8()),\n});\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 796, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/iota-sdk/src/bcs/effects.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@iota/bcs';\n\nimport { Address, ObjectDigest, Owner } from './bcs.js';\n\nconst PackageUpgradeError = bcs.enum('PackageUpgradeError', {\n    UnableToFetchPackage: bcs.struct('UnableToFetchPackage', { packageId: Address }),\n    NotAPackage: bcs.struct('NotAPackage', { objectId: Address }),\n    IncompatibleUpgrade: null,\n    DigestDoesNotMatch: bcs.struct('DigestDoesNotMatch', { digest: bcs.vector(bcs.u8()) }),\n    UnknownUpgradePolicy: bcs.struct('UnknownUpgradePolicy', { policy: bcs.u8() }),\n    PackageIDDoesNotMatch: bcs.struct('PackageIDDoesNotMatch', {\n        packageId: Address,\n        ticketId: Address,\n    }),\n});\n\nconst ModuleId = bcs.struct('ModuleId', {\n    address: Address,\n    name: bcs.string(),\n});\nconst MoveLocation = bcs.struct('MoveLocation', {\n    module: ModuleId,\n    function: bcs.u16(),\n    instruction: bcs.u16(),\n    functionName: bcs.option(bcs.string()),\n});\n\nconst CommandArgumentError = bcs.enum('CommandArgumentError', {\n    TypeMismatch: null,\n    InvalidBCSBytes: null,\n    InvalidUsageOfPureArg: null,\n    InvalidArgumentToPrivateEntryFunction: null,\n    IndexOutOfBounds: bcs.struct('IndexOutOfBounds', { idx: bcs.u16() }),\n    SecondaryIndexOutOfBounds: bcs.struct('SecondaryIndexOutOfBounds', {\n        resultIdx: bcs.u16(),\n        secondaryIdx: bcs.u16(),\n    }),\n    InvalidResultArity: bcs.struct('InvalidResultArity', { resultIdx: bcs.u16() }),\n    InvalidGasCoinUsage: null,\n    InvalidValueUsage: null,\n    InvalidObjectByValue: null,\n    InvalidObjectByMutRef: null,\n    SharedObjectOperationNotAllowed: null,\n});\n\nconst TypeArgumentError = bcs.enum('TypeArgumentError', {\n    TypeNotFound: null,\n    ConstraintNotSatisfied: null,\n});\n\nconst ExecutionFailureStatus = bcs.enum('ExecutionFailureStatus', {\n    InsufficientGas: null,\n    InvalidGasObject: null,\n    InvariantViolation: null,\n    FeatureNotYetSupported: null,\n    MoveObjectTooBig: bcs.struct('MoveObjectTooBig', {\n        objectSize: bcs.u64(),\n        maxObjectSize: bcs.u64(),\n    }),\n    MovePackageTooBig: bcs.struct('MovePackageTooBig', {\n        objectSize: bcs.u64(),\n        maxObjectSize: bcs.u64(),\n    }),\n    CircularObjectOwnership: bcs.struct('CircularObjectOwnership', { object: Address }),\n    InsufficientCoinBalance: null,\n    CoinBalanceOverflow: null,\n    PublishErrorNonZeroAddress: null,\n    IotaMoveVerificationError: null,\n    MovePrimitiveRuntimeError: bcs.option(MoveLocation),\n    MoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),\n    VMVerificationOrDeserializationError: null,\n    VMInvariantViolation: null,\n    FunctionNotFound: null,\n    ArityMismatch: null,\n    TypeArityMismatch: null,\n    NonEntryFunctionInvoked: null,\n    CommandArgumentError: bcs.struct('CommandArgumentError', {\n        argIdx: bcs.u16(),\n        kind: CommandArgumentError,\n    }),\n    TypeArgumentError: bcs.struct('TypeArgumentError', {\n        argumentIdx: bcs.u16(),\n        kind: TypeArgumentError,\n    }),\n    UnusedValueWithoutDrop: bcs.struct('UnusedValueWithoutDrop', {\n        resultIdx: bcs.u16(),\n        secondaryIdx: bcs.u16(),\n    }),\n    InvalidPublicFunctionReturnType: bcs.struct('InvalidPublicFunctionReturnType', {\n        idx: bcs.u16(),\n    }),\n    InvalidTransferObject: null,\n    EffectsTooLarge: bcs.struct('EffectsTooLarge', { currentSize: bcs.u64(), maxSize: bcs.u64() }),\n    PublishUpgradeMissingDependency: null,\n    PublishUpgradeDependencyDowngrade: null,\n    PackageUpgradeError: bcs.struct('PackageUpgradeError', { upgradeError: PackageUpgradeError }),\n    WrittenObjectsTooLarge: bcs.struct('WrittenObjectsTooLarge', {\n        currentSize: bcs.u64(),\n        maxSize: bcs.u64(),\n    }),\n    CertificateDenied: null,\n    IotaMoveVerificationTimedout: null,\n    SharedObjectOperationNotAllowed: null,\n    InputObjectDeleted: null,\n    ExecutionCancelledDueToSharedObjectCongestion: bcs.struct(\n        'ExecutionCancelledDueToSharedObjectCongestion',\n        {\n            congestedObjects: bcs.vector(Address),\n        },\n    ),\n    AddressDeniedForCoin: bcs.struct('AddressDeniedForCoin', {\n        address: Address,\n        coinType: bcs.string(),\n    }),\n    CoinTypeGlobalPause: bcs.struct('CoinTypeGlobalPause', { coinType: bcs.string() }),\n    ExecutionCancelledDueToRandomnessUnavailable: null,\n});\n\nconst ExecutionStatus = bcs.enum('ExecutionStatus', {\n    Success: null,\n    Failed: bcs.struct('ExecutionFailed', {\n        error: ExecutionFailureStatus,\n        command: bcs.option(bcs.u64()),\n    }),\n});\n\nconst GasCostSummary = bcs.struct('GasCostSummary', {\n    computationCost: bcs.u64(),\n    computationCostBurned: bcs.u64(),\n    storageCost: bcs.u64(),\n    storageRebate: bcs.u64(),\n    nonRefundableStorageFee: bcs.u64(),\n});\n\nconst VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);\n\nconst ObjectIn = bcs.enum('ObjectIn', {\n    NotExist: null,\n    Exist: bcs.tuple([VersionDigest, Owner]),\n});\n\nexport const ObjectOut = bcs.enum('ObjectOut', {\n    NotExist: null,\n    ObjectWrite: bcs.tuple([ObjectDigest, Owner]),\n    PackageWrite: VersionDigest,\n});\n\nconst IDOperation = bcs.enum('IDOperation', {\n    None: null,\n    Created: null,\n    Deleted: null,\n});\n\nconst EffectsObjectChange = bcs.struct('EffectsObjectChange', {\n    inputState: ObjectIn,\n    outputState: ObjectOut,\n    idOperation: IDOperation,\n});\n\nconst UnchangedSharedKind = bcs.enum('UnchangedSharedKind', {\n    ReadOnlyRoot: VersionDigest,\n    MutateDeleted: bcs.u64(),\n    ReadDeleted: bcs.u64(),\n    Cancelled: bcs.u64(),\n    PerEpochConfig: null,\n});\n\nconst TransactionEffectsV1 = bcs.struct('TransactionEffectsV1', {\n    status: ExecutionStatus,\n    executedEpoch: bcs.u64(),\n    gasUsed: GasCostSummary,\n    transactionDigest: ObjectDigest,\n    gasObjectIndex: bcs.option(bcs.u32()),\n    eventsDigest: bcs.option(ObjectDigest),\n    dependencies: bcs.vector(ObjectDigest),\n    lamportVersion: bcs.u64(),\n    changedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),\n    unchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),\n    auxDataDigest: bcs.option(ObjectDigest),\n});\n\nexport const TransactionEffects = bcs.enum('TransactionEffects', {\n    V1: TransactionEffectsV1,\n});\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1014, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/iota-sdk/src/bcs/index.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@iota/bcs';\n\nimport {\n    Address,\n    AppId,\n    Argument,\n    CallArg,\n    Command,\n    CompressedSignature,\n    GasData,\n    Intent,\n    IntentMessage,\n    IntentScope,\n    IntentVersion,\n    MultiSig,\n    MultiSigPkMap,\n    MultiSigPublicKey,\n    ObjectArg,\n    ObjectDigest,\n    Owner,\n    ProgrammableMoveCall,\n    ProgrammableTransaction,\n    PublicKey,\n    SenderSignedData,\n    SenderSignedTransaction,\n    SharedObjectRef,\n    StructTag,\n    IotaObjectRef,\n    TransactionData,\n    TransactionDataV1,\n    TransactionExpiration,\n    TransactionKind,\n    TypeTag,\n    PasskeyAuthenticator,\n} from './bcs.js';\nimport { TransactionEffects } from './effects.js';\n\nexport type { TypeTag } from './types.js';\n\nexport { TypeTagSerializer } from './type-tag-serializer.js';\nexport { BcsType, type BcsTypeOptions } from '@iota/bcs';\n\nconst iotaBcs = {\n    ...bcs,\n    U8: bcs.u8(),\n    U16: bcs.u16(),\n    U32: bcs.u32(),\n    U64: bcs.u64(),\n    U128: bcs.u128(),\n    U256: bcs.u256(),\n    ULEB128: bcs.uleb128(),\n    Bool: bcs.bool(),\n    String: bcs.string(),\n    Address,\n    AppId,\n    Argument,\n    CallArg,\n    CompressedSignature,\n    GasData,\n    Intent,\n    IntentMessage,\n    IntentScope,\n    IntentVersion,\n    MultiSig,\n    MultiSigPkMap,\n    MultiSigPublicKey,\n    ObjectArg,\n    ObjectDigest,\n    Owner,\n    ProgrammableMoveCall,\n    ProgrammableTransaction,\n    PublicKey,\n    SenderSignedData,\n    SenderSignedTransaction,\n    SharedObjectRef,\n    StructTag,\n    IotaObjectRef,\n    Command,\n    TransactionData,\n    TransactionDataV1,\n    TransactionExpiration,\n    TransactionKind,\n    TypeTag,\n    TransactionEffects,\n    PasskeyAuthenticator,\n};\n\nexport { iotaBcs as bcs };\n"],"names":[],"mappings":";;;;AAIA,SAAS,WAAW;AAEpB;AAiCA,SAAS,0BAA0B;AAInC,SAAS,yBAAyB;AAClC,SAAS,eAAoC;;;;;;AAE7C,MAAM,UAAU;IACZ,GAAG,6JAAA;IACH,IAAI,6JAAA,CAAI,EAAA,CAAG;IACX,KAAK,6JAAA,CAAI,GAAA,CAAI;IACb,KAAK,6JAAA,CAAI,GAAA,CAAI;IACb,KAAK,6JAAA,CAAI,GAAA,CAAI;IACb,MAAM,6JAAA,CAAI,IAAA,CAAK;IACf,MAAM,6JAAA,CAAI,IAAA,CAAK;IACf,SAAS,6JAAA,CAAI,OAAA,CAAQ;IACrB,MAAM,6JAAA,CAAI,IAAA,CAAK;IACf,QAAQ,6JAAA,CAAI,MAAA,CAAO;aACnB,gLAAA;WACA,8KAAA;cACA,iLAAA;aACA,gLAAA;yBACA,4LAAA;aACA,gLAAA;YACA,+KAAA;mBACA,sLAAA;iBACA,oLAAA;mBACA,sLAAA;cACA,iLAAA;mBACA,sLAAA;uBACA,0LAAA;eACA,kLAAA;kBACA,qLAAA;WACA,8KAAA;0BACA,6LAAA;6BACA,gMAAA;eACA,kLAAA;sBACA,yLAAA;6BACA,gMAAA;qBACA,wLAAA;eACA,kLAAA;mBACA,sLAAA;aACA,gLAAA;qBACA,wLAAA;uBACA,0LAAA;2BACA,8LAAA;qBACA,wLAAA;aACA,gLAAA;wBACA,+LAAA;0BACA,6LAAA;AACJ"}},
    {"offset": {"line": 1078, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/iota-sdk/src/graphql/schemas/2025.2/index.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { initGraphQLTada } from 'gql.tada';\n\nimport type { introspection } from '../../generated/2025.2/tada-env.js';\nimport type { CustomScalars } from '../../types.js';\n\nexport * from '../../types.js';\n\nexport type { FragmentOf, ResultOf, VariablesOf, TadaDocumentNode } from 'gql.tada';\nexport { readFragment, maskFragments } from 'gql.tada';\n\nexport const graphql = initGraphQLTada<{\n    introspection: introspection;\n    scalars: CustomScalars;\n}>();\n"],"names":[],"mappings":";;;;AAIA,SAAS,uBAAuB;;;;AAUzB,MAAM,cAAU,yKAAA,CAGpB"}},
    {"offset": {"line": 1093, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/transactions/data/internal.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EnumInputShape, EnumOutputShape } from '@iota/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n    array,\n    boolean,\n    check,\n    integer,\n    lazy,\n    literal,\n    nullable,\n    nullish,\n    number,\n    object,\n    optional,\n    pipe,\n    record,\n    string,\n    transform,\n    tuple,\n    union,\n    unknown,\n} from 'valibot';\n\nimport { isValidIotaAddress, normalizeIotaAddress } from '../../utils/iota-types.js';\n\ntype Merge<T> = T extends object ? { [K in keyof T]: T[K] } : never;\n\ntype EnumSchema<T extends Record<string, GenericSchema<any>>> = GenericSchema<\n    EnumInputShape<\n        Merge<{\n            [K in keyof T]: InferInput<T[K]>;\n        }>\n    >,\n    EnumOutputShape<\n        Merge<{\n            [K in keyof T]: InferOutput<T[K]>;\n        }>\n    >\n>;\n\nexport function safeEnum<T extends Record<string, GenericSchema<any>>>(options: T): EnumSchema<T> {\n    const unionOptions = Object.entries(options).map(([key, value]) => object({ [key]: value }));\n\n    return pipe(\n        union(unionOptions),\n        transform((value) => ({\n            ...value,\n            $kind: Object.keys(value)[0] as keyof typeof value,\n        })),\n    ) as EnumSchema<T>;\n}\n\nexport const IotaAddress = pipe(\n    string(),\n    transform((value) => normalizeIotaAddress(value)),\n    check(isValidIotaAddress),\n);\nexport const ObjectID = IotaAddress;\nexport const BCSBytes = string();\nexport const JsonU64 = pipe(\n    union([string(), pipe(number(), integer())]),\n\n    check((val) => {\n        try {\n            BigInt(val);\n            return BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;\n        } catch {\n            return false;\n        }\n    }, 'Invalid u64'),\n);\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/base_types.rs#L138\n// Implemented as a tuple in rust\nexport const ObjectRef = object({\n    objectId: IotaAddress,\n    version: JsonU64,\n    digest: string(),\n});\nexport type ObjectRef = InferOutput<typeof ObjectRef>;\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L690-L702\nexport const Argument = pipe(\n    union([\n        object({ GasCoin: literal(true) }),\n        object({ Input: pipe(number(), integer()), type: optional(literal('pure')) }),\n        object({ Input: pipe(number(), integer()), type: optional(literal('object')) }),\n        object({ Result: pipe(number(), integer()) }),\n        object({ NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]) }),\n    ]),\n    transform((value) => ({\n        ...value,\n        $kind: Object.keys(value)[0] as keyof typeof value,\n    })),\n    // Defined manually to add `type?: 'pure' | 'object'` to Input\n) as GenericSchema<\n    // Input\n    | { GasCoin: true }\n    | { Input: number; type?: 'pure' | 'object' }\n    | { Result: number }\n    | { NestedResult: [number, number] },\n    // Output\n    | { $kind: 'GasCoin'; GasCoin: true }\n    | { $kind: 'Input'; Input: number; type?: 'pure' }\n    | { $kind: 'Input'; Input: number; type?: 'object' }\n    | { $kind: 'Result'; Result: number }\n    | { $kind: 'NestedResult'; NestedResult: [number, number] }\n>;\n\nexport type Argument = InferOutput<typeof Argument>;\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L1387-L1392\nexport const GasData = object({\n    budget: nullable(JsonU64),\n    price: nullable(JsonU64),\n    owner: nullable(IotaAddress),\n    payment: nullable(array(ObjectRef)),\n});\nexport type GasData = InferOutput<typeof GasData>;\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTag = object({\n    address: string(),\n    module: string(),\n    name: string(),\n    // type_params in rust, should be updated to use camelCase\n    typeParams: array(string()),\n});\nexport type StructTag = InferOutput<typeof StructTag>;\n\n// https://github.com/iotaledger/iota/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/iota-graphql-rpc/schema/current_progress_schema.graphql#L1614-L1627\nexport type OpenMoveTypeSignatureBody =\n    | 'address'\n    | 'bool'\n    | 'u8'\n    | 'u16'\n    | 'u32'\n    | 'u64'\n    | 'u128'\n    | 'u256'\n    | { vector: OpenMoveTypeSignatureBody }\n    | {\n          datatype: {\n              package: string;\n              module: string;\n              type: string;\n              typeParameters: OpenMoveTypeSignatureBody[];\n          };\n      }\n    | { typeParameter: number };\n\nexport const OpenMoveTypeSignatureBody: GenericSchema<OpenMoveTypeSignatureBody> = union([\n    literal('address'),\n    literal('bool'),\n    literal('u8'),\n    literal('u16'),\n    literal('u32'),\n    literal('u64'),\n    literal('u128'),\n    literal('u256'),\n    object({ vector: lazy(() => OpenMoveTypeSignatureBody) }),\n    object({\n        datatype: object({\n            package: string(),\n            module: string(),\n            type: string(),\n            typeParameters: array(lazy(() => OpenMoveTypeSignatureBody)),\n        }),\n    }),\n    object({ typeParameter: pipe(number(), integer()) }),\n]);\n\n// https://github.com/iotaledger/iota/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/iota-graphql-rpc/schema/current_progress_schema.graphql#L1609-L1612\nexport const OpenMoveTypeSignature = object({\n    ref: nullable(union([literal('&'), literal('&mut')])),\n    body: OpenMoveTypeSignatureBody,\n});\nexport type OpenMoveTypeSignature = InferOutput<typeof OpenMoveTypeSignature>;\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L707-L718\nconst ProgrammableMoveCall = object({\n    package: ObjectID,\n    module: string(),\n    function: string(),\n    // snake case in rust\n    typeArguments: array(string()),\n    arguments: array(Argument),\n    _argumentTypes: optional(nullable(array(OpenMoveTypeSignature))),\n});\nexport type ProgrammableMoveCall = InferOutput<typeof ProgrammableMoveCall>;\n\nexport const $Intent = object({\n    name: string(),\n    inputs: record(string(), union([Argument, array(Argument)])),\n    data: record(string(), unknown()),\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L657-L685\nexport const Command = safeEnum({\n    MoveCall: ProgrammableMoveCall,\n    TransferObjects: object({\n        objects: array(Argument),\n        address: Argument,\n    }),\n    SplitCoins: object({\n        coin: Argument,\n        amounts: array(Argument),\n    }),\n    MergeCoins: object({\n        destination: Argument,\n        sources: array(Argument),\n    }),\n    Publish: object({\n        modules: array(BCSBytes),\n        dependencies: array(ObjectID),\n    }),\n    MakeMoveVec: object({\n        type: nullable(string()),\n        elements: array(Argument),\n    }),\n    Upgrade: object({\n        modules: array(BCSBytes),\n        dependencies: array(ObjectID),\n        package: ObjectID,\n        ticket: Argument,\n    }),\n    $Intent,\n});\n\nexport type Command<Arg = Argument> = EnumOutputShape<{\n    MoveCall: {\n        package: string;\n        module: string;\n        function: string;\n        typeArguments: string[];\n        arguments: Arg[];\n        _argumentTypes?: OpenMoveTypeSignature[] | null;\n    };\n    TransferObjects: {\n        objects: Arg[];\n        address: Arg;\n    };\n    SplitCoins: {\n        coin: Arg;\n        amounts: Arg[];\n    };\n    MergeCoins: {\n        destination: Arg;\n        sources: Arg[];\n    };\n    Publish: {\n        modules: string[];\n        dependencies: string[];\n    };\n    MakeMoveVec: {\n        type: string | null;\n        elements: Arg[];\n    };\n    Upgrade: {\n        modules: string[];\n        dependencies: string[];\n        package: string;\n        ticket: Arg;\n    };\n    $Intent: {\n        name: string;\n        inputs: Record<string, Argument | Argument[]>;\n        data: Record<string, unknown>;\n    };\n}>;\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L102-L114\nexport const ObjectArg = safeEnum({\n    ImmOrOwnedObject: ObjectRef,\n    SharedObject: object({\n        objectId: ObjectID,\n        // snake case in rust\n        initialSharedVersion: JsonU64,\n        mutable: boolean(),\n    }),\n    Receiving: ObjectRef,\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L75-L80\nconst CallArg = safeEnum({\n    Object: ObjectArg,\n    Pure: object({\n        bytes: BCSBytes,\n    }),\n    UnresolvedPure: object({\n        value: unknown(),\n    }),\n    UnresolvedObject: object({\n        objectId: ObjectID,\n        version: optional(nullable(JsonU64)),\n        digest: optional(nullable(string())),\n        initialSharedVersion: optional(nullable(JsonU64)),\n    }),\n});\nexport type CallArg = InferOutput<typeof CallArg>;\n\nexport const NormalizedCallArg = safeEnum({\n    Object: ObjectArg,\n    Pure: object({\n        bytes: BCSBytes,\n    }),\n});\n\nexport const TransactionExpiration = safeEnum({\n    None: literal(true),\n    Epoch: JsonU64,\n});\n\nexport type TransactionExpiration = InferOutput<typeof TransactionExpiration>;\n\nexport const TransactionData = object({\n    version: literal(2),\n    sender: nullish(IotaAddress),\n    expiration: nullish(TransactionExpiration),\n    gasData: GasData,\n    inputs: array(CallArg),\n    commands: array(Command),\n});\nexport type TransactionData = InferOutput<typeof TransactionData>;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1326, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/transactions/Commands.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@iota/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { normalizeIotaObjectId } from '../utils/iota-types.js';\nimport { Argument } from './data/internal.js';\nimport type { CallArg, Command } from './data/internal.js';\nimport type { Transaction } from './Transaction.js';\n\nexport type TransactionArgument =\n    | InferInput<typeof Argument>\n    | ((tx: Transaction) => InferInput<typeof Argument>);\nexport type TransactionInput = CallArg;\n\n// Keep in sync with constants in\n// crates/iota-framework/packages/iota-framework/sources/package.move\nexport enum UpgradePolicy {\n    COMPATIBLE = 0,\n    ADDITIVE = 128,\n    DEP_ONLY = 192,\n}\n\ntype TransactionShape<T extends Command['$kind']> = { $kind: T } & {\n    [K in T]: Extract<Command, { [K in T]: any }>[T];\n};\n\n/**\n * Simple helpers used to construct transactions:\n */\nexport const Commands = {\n    MoveCall(\n        input:\n            | {\n                  package: string;\n                  module: string;\n                  function: string;\n                  arguments?: Argument[];\n                  typeArguments?: string[];\n              }\n            | {\n                  target: string;\n                  arguments?: Argument[];\n                  typeArguments?: string[];\n              },\n    ): TransactionShape<'MoveCall'> {\n        const [pkg, mod = '', fn = ''] =\n            'target' in input\n                ? input.target.split('::')\n                : [input.package, input.module, input.function];\n\n        return {\n            $kind: 'MoveCall',\n            MoveCall: {\n                package: pkg,\n                module: mod,\n                function: fn,\n                typeArguments: input.typeArguments ?? [],\n                arguments: input.arguments ?? [],\n            },\n        };\n    },\n\n    TransferObjects(\n        objects: InferInput<typeof Argument>[],\n        address: InferInput<typeof Argument>,\n    ): TransactionShape<'TransferObjects'> {\n        return {\n            $kind: 'TransferObjects',\n            TransferObjects: {\n                objects: objects.map((o) => parse(Argument, o)),\n                address: parse(Argument, address),\n            },\n        };\n    },\n    SplitCoins(\n        coin: InferInput<typeof Argument>,\n        amounts: InferInput<typeof Argument>[],\n    ): TransactionShape<'SplitCoins'> {\n        return {\n            $kind: 'SplitCoins',\n            SplitCoins: {\n                coin: parse(Argument, coin),\n                amounts: amounts.map((o) => parse(Argument, o)),\n            },\n        };\n    },\n    MergeCoins(\n        destination: InferInput<typeof Argument>,\n        sources: InferInput<typeof Argument>[],\n    ): TransactionShape<'MergeCoins'> {\n        return {\n            $kind: 'MergeCoins',\n            MergeCoins: {\n                destination: parse(Argument, destination),\n                sources: sources.map((o) => parse(Argument, o)),\n            },\n        };\n    },\n    Publish({\n        modules,\n        dependencies,\n    }: {\n        modules: number[][] | string[];\n        dependencies: string[];\n    }): TransactionShape<'Publish'> {\n        return {\n            $kind: 'Publish',\n            Publish: {\n                modules: modules.map((module) =>\n                    typeof module === 'string' ? module : toBase64(new Uint8Array(module)),\n                ),\n                dependencies: dependencies.map((dep) => normalizeIotaObjectId(dep)),\n            },\n        };\n    },\n    Upgrade({\n        modules,\n        dependencies,\n        package: packageId,\n        ticket,\n    }: {\n        modules: number[][] | string[];\n        dependencies: string[];\n        package: string;\n        ticket: InferInput<typeof Argument>;\n    }): TransactionShape<'Upgrade'> {\n        return {\n            $kind: 'Upgrade',\n            Upgrade: {\n                modules: modules.map((module) =>\n                    typeof module === 'string' ? module : toBase64(new Uint8Array(module)),\n                ),\n                dependencies: dependencies.map((dep) => normalizeIotaObjectId(dep)),\n                package: packageId,\n                ticket: parse(Argument, ticket),\n            },\n        };\n    },\n    MakeMoveVec({\n        type,\n        elements,\n    }: {\n        type?: string;\n        elements: InferInput<typeof Argument>[];\n    }): TransactionShape<'MakeMoveVec'> {\n        return {\n            $kind: 'MakeMoveVec',\n            MakeMoveVec: {\n                type: type ?? null,\n                elements: elements.map((o) => parse(Argument, o)),\n            },\n        };\n    },\n    Intent({\n        name,\n        inputs = {},\n        data = {},\n    }: {\n        name: string;\n        inputs?: Record<string, InferInput<typeof Argument> | InferInput<typeof Argument>[]>;\n        data?: Record<string, unknown>;\n    }): TransactionShape<'$Intent'> {\n        return {\n            $kind: '$Intent',\n            $Intent: {\n                name,\n                inputs: Object.fromEntries(\n                    Object.entries(inputs).map(([key, value]) => [\n                        key,\n                        Array.isArray(value)\n                            ? value.map((o) => parse(Argument, o))\n                            : parse(Argument, value),\n                    ]),\n                ),\n                data,\n            },\n        };\n    },\n};\n"],"names":["UpgradePolicy"],"mappings":"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"}},
    {"offset": {"line": 1440, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/bcs/type-tag-serializer.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { splitGenericParameters } from '@iota/bcs';\n\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { TypeTag } from './types.js';\n\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\nexport class TypeTagSerializer {\n    static parseFromStr(str: string, normalizeAddress = false): TypeTag {\n        if (str === 'address') {\n            return { address: null };\n        } else if (str === 'bool') {\n            return { bool: null };\n        } else if (str === 'u8') {\n            return { u8: null };\n        } else if (str === 'u16') {\n            return { u16: null };\n        } else if (str === 'u32') {\n            return { u32: null };\n        } else if (str === 'u64') {\n            return { u64: null };\n        } else if (str === 'u128') {\n            return { u128: null };\n        } else if (str === 'u256') {\n            return { u256: null };\n        } else if (str === 'signer') {\n            return { signer: null };\n        }\n\n        const vectorMatch = str.match(VECTOR_REGEX);\n        if (vectorMatch) {\n            return {\n                vector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),\n            };\n        }\n\n        const structMatch = str.match(STRUCT_REGEX);\n        if (structMatch) {\n            const address = normalizeAddress\n                ? normalizeIotaAddress(structMatch[1])\n                : structMatch[1];\n            return {\n                struct: {\n                    address,\n                    module: structMatch[2],\n                    name: structMatch[3],\n                    typeParams:\n                        structMatch[5] === undefined\n                            ? []\n                            : TypeTagSerializer.parseStructTypeArgs(\n                                  structMatch[5],\n                                  normalizeAddress,\n                              ),\n                },\n            };\n        }\n\n        throw new Error(`Encountered unexpected token when parsing type args for ${str}`);\n    }\n\n    static parseStructTypeArgs(str: string, normalizeAddress = false): TypeTag[] {\n        return splitGenericParameters(str).map((tok) =>\n            TypeTagSerializer.parseFromStr(tok, normalizeAddress),\n        );\n    }\n\n    static tagToString(tag: TypeTag): string {\n        if ('bool' in tag) {\n            return 'bool';\n        }\n        if ('u8' in tag) {\n            return 'u8';\n        }\n        if ('u16' in tag) {\n            return 'u16';\n        }\n        if ('u32' in tag) {\n            return 'u32';\n        }\n        if ('u64' in tag) {\n            return 'u64';\n        }\n        if ('u128' in tag) {\n            return 'u128';\n        }\n        if ('u256' in tag) {\n            return 'u256';\n        }\n        if ('address' in tag) {\n            return 'address';\n        }\n        if ('signer' in tag) {\n            return 'signer';\n        }\n        if ('vector' in tag) {\n            return `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n        }\n        if ('struct' in tag) {\n            const struct = tag.struct;\n            const typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');\n            return `${struct.address}::${struct.module}::${struct.name}${\n                typeParams ? `<${typeParams}>` : ''\n            }`;\n        }\n        throw new Error('Invalid TypeTag');\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1557, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/transactions/data/v1.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@iota/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n    array,\n    bigint,\n    boolean,\n    check,\n    integer,\n    is,\n    lazy,\n    literal,\n    nullable,\n    nullish,\n    number,\n    object,\n    optional,\n    parse,\n    pipe,\n    string,\n    union,\n    unknown,\n} from 'valibot';\n\nimport { TypeTagSerializer } from '../../bcs/index.js';\nimport type { StructTag as StructTagType, TypeTag as TypeTagType } from '../../bcs/types.js';\nimport { JsonU64, ObjectID, safeEnum, TransactionData } from './internal.js';\nimport type { Argument } from './internal.js';\n\nexport const ObjectRef = object({\n    digest: string(),\n    objectId: string(),\n    version: union([pipe(number(), integer()), string(), bigint()]),\n});\n\nconst ObjectArg = safeEnum({\n    ImmOrOwned: ObjectRef,\n    Shared: object({\n        objectId: ObjectID,\n        initialSharedVersion: JsonU64,\n        mutable: boolean(),\n    }),\n    Receiving: ObjectRef,\n});\n\nexport const NormalizedCallArg = safeEnum({\n    Object: ObjectArg,\n    Pure: array(pipe(number(), integer())),\n});\n\nconst TransactionInput = union([\n    object({\n        kind: literal('Input'),\n        index: pipe(number(), integer()),\n        value: unknown(),\n        type: optional(literal('object')),\n    }),\n    object({\n        kind: literal('Input'),\n        index: pipe(number(), integer()),\n        value: unknown(),\n        type: literal('pure'),\n    }),\n]);\n\nconst TransactionExpiration = union([\n    object({ Epoch: pipe(number(), integer()) }),\n    object({ None: nullable(literal(true)) }),\n]);\n\nconst StringEncodedBigint = pipe(\n    union([number(), string(), bigint()]),\n    check((val) => {\n        if (!['string', 'number', 'bigint'].includes(typeof val)) return false;\n\n        try {\n            BigInt(val as string);\n            return true;\n        } catch {\n            return false;\n        }\n    }),\n);\n\nexport const TypeTag: GenericSchema<TypeTagType> = union([\n    object({ bool: nullable(literal(true)) }),\n    object({ u8: nullable(literal(true)) }),\n    object({ u64: nullable(literal(true)) }),\n    object({ u128: nullable(literal(true)) }),\n    object({ address: nullable(literal(true)) }),\n    object({ signer: nullable(literal(true)) }),\n    object({ vector: lazy(() => TypeTag) }),\n    object({ struct: lazy(() => StructTag) }),\n    object({ u16: nullable(literal(true)) }),\n    object({ u32: nullable(literal(true)) }),\n    object({ u256: nullable(literal(true)) }),\n]);\n\n// https://github.com/iotaledger/iota/blob/cea8742e810142a8145fd83c4c142d61e561004a/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTag: GenericSchema<StructTagType> = object({\n    address: string(),\n    module: string(),\n    name: string(),\n    typeParams: array(TypeTag),\n});\n\nconst GasConfig = object({\n    budget: optional(StringEncodedBigint),\n    price: optional(StringEncodedBigint),\n    payment: optional(array(ObjectRef)),\n    owner: optional(string()),\n});\n\nconst TransactionArgumentTypes = [\n    TransactionInput,\n    object({ kind: literal('GasCoin') }),\n    object({ kind: literal('Result'), index: pipe(number(), integer()) }),\n    object({\n        kind: literal('NestedResult'),\n        index: pipe(number(), integer()),\n        resultIndex: pipe(number(), integer()),\n    }),\n] as const;\n\n// Generic transaction argument\nexport const TransactionArgument = union([...TransactionArgumentTypes]);\n\nconst MoveCallTransaction = object({\n    kind: literal('MoveCall'),\n    target: pipe(\n        string(),\n        check((target) => target.split('::').length === 3),\n    ) as GenericSchema<`${string}::${string}::${string}`>,\n    typeArguments: array(string()),\n    arguments: array(TransactionArgument),\n});\n\nconst TransferObjectsTransaction = object({\n    kind: literal('TransferObjects'),\n    objects: array(TransactionArgument),\n    address: TransactionArgument,\n});\n\nconst SplitCoinsTransaction = object({\n    kind: literal('SplitCoins'),\n    coin: TransactionArgument,\n    amounts: array(TransactionArgument),\n});\n\nconst MergeCoinsTransaction = object({\n    kind: literal('MergeCoins'),\n    destination: TransactionArgument,\n    sources: array(TransactionArgument),\n});\n\nconst MakeMoveVecTransaction = object({\n    kind: literal('MakeMoveVec'),\n    type: union([object({ Some: TypeTag }), object({ None: nullable(literal(true)) })]),\n    objects: array(TransactionArgument),\n});\n\nconst PublishTransaction = object({\n    kind: literal('Publish'),\n    modules: array(array(pipe(number(), integer()))),\n    dependencies: array(string()),\n});\n\nconst UpgradeTransaction = object({\n    kind: literal('Upgrade'),\n    modules: array(array(pipe(number(), integer()))),\n    dependencies: array(string()),\n    packageId: string(),\n    ticket: TransactionArgument,\n});\n\nconst TransactionTypes = [\n    MoveCallTransaction,\n    TransferObjectsTransaction,\n    SplitCoinsTransaction,\n    MergeCoinsTransaction,\n    PublishTransaction,\n    UpgradeTransaction,\n    MakeMoveVecTransaction,\n] as const;\n\nconst TransactionType = union([...TransactionTypes]);\n\nexport const SerializedTransactionDataV1 = object({\n    version: literal(1),\n    sender: optional(string()),\n    expiration: nullish(TransactionExpiration),\n    gasConfig: GasConfig,\n    inputs: array(TransactionInput),\n    transactions: array(TransactionType),\n});\n\nexport type SerializedTransactionDataV1 = InferOutput<typeof SerializedTransactionDataV1>;\n\nexport function serializeV1TransactionData(\n    transactionData: TransactionData,\n): SerializedTransactionDataV1 {\n    const inputs: InferOutput<typeof TransactionInput>[] = transactionData.inputs.map(\n        (input, index) => {\n            if (input.Object) {\n                return {\n                    kind: 'Input',\n                    index,\n                    value: {\n                        Object: input.Object.ImmOrOwnedObject\n                            ? {\n                                  ImmOrOwned: input.Object.ImmOrOwnedObject,\n                              }\n                            : input.Object.Receiving\n                              ? {\n                                    Receiving: {\n                                        digest: input.Object.Receiving.digest,\n                                        version: input.Object.Receiving.version,\n                                        objectId: input.Object.Receiving.objectId,\n                                    },\n                                }\n                              : {\n                                    Shared: {\n                                        mutable: input.Object.SharedObject.mutable,\n                                        initialSharedVersion:\n                                            input.Object.SharedObject.initialSharedVersion,\n                                        objectId: input.Object.SharedObject.objectId,\n                                    },\n                                },\n                    },\n                    type: 'object',\n                };\n            }\n            if (input.Pure) {\n                return {\n                    kind: 'Input',\n                    index,\n                    value: {\n                        Pure: Array.from(fromBase64(input.Pure.bytes)),\n                    },\n                    type: 'pure',\n                };\n            }\n\n            if (input.UnresolvedPure) {\n                return {\n                    kind: 'Input',\n                    type: 'pure',\n                    index,\n                    value: input.UnresolvedPure.value,\n                };\n            }\n\n            if (input.UnresolvedObject) {\n                return {\n                    kind: 'Input',\n                    type: 'object',\n                    index,\n                    value: input.UnresolvedObject.objectId,\n                };\n            }\n\n            throw new Error('Invalid input');\n        },\n    );\n\n    return {\n        version: 1,\n        sender: transactionData.sender ?? undefined,\n        expiration:\n            transactionData.expiration?.$kind === 'Epoch'\n                ? { Epoch: Number(transactionData.expiration.Epoch) }\n                : transactionData.expiration\n                  ? { None: true }\n                  : null,\n        gasConfig: {\n            owner: transactionData.gasData.owner ?? undefined,\n            budget: transactionData.gasData.budget ?? undefined,\n            price: transactionData.gasData.price ?? undefined,\n            payment: transactionData.gasData.payment ?? undefined,\n        },\n        inputs,\n        transactions: transactionData.commands.map(\n            (command): InferOutput<typeof TransactionType> => {\n                if (command.MakeMoveVec) {\n                    return {\n                        kind: 'MakeMoveVec',\n                        type:\n                            command.MakeMoveVec.type === null\n                                ? { None: true }\n                                : {\n                                      Some: TypeTagSerializer.parseFromStr(\n                                          command.MakeMoveVec.type,\n                                      ),\n                                  },\n                        objects: command.MakeMoveVec.elements.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                    };\n                }\n                if (command.MergeCoins) {\n                    return {\n                        kind: 'MergeCoins',\n                        destination: convertTransactionArgument(\n                            command.MergeCoins.destination,\n                            inputs,\n                        ),\n                        sources: command.MergeCoins.sources.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                    };\n                }\n                if (command.MoveCall) {\n                    return {\n                        kind: 'MoveCall',\n                        target: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,\n                        typeArguments: command.MoveCall.typeArguments,\n                        arguments: command.MoveCall.arguments.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                    };\n                }\n                if (command.Publish) {\n                    return {\n                        kind: 'Publish',\n                        modules: command.Publish.modules.map((mod) => Array.from(fromBase64(mod))),\n                        dependencies: command.Publish.dependencies,\n                    };\n                }\n                if (command.SplitCoins) {\n                    return {\n                        kind: 'SplitCoins',\n                        coin: convertTransactionArgument(command.SplitCoins.coin, inputs),\n                        amounts: command.SplitCoins.amounts.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                    };\n                }\n                if (command.TransferObjects) {\n                    return {\n                        kind: 'TransferObjects',\n                        objects: command.TransferObjects.objects.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                        address: convertTransactionArgument(\n                            command.TransferObjects.address,\n                            inputs,\n                        ),\n                    };\n                }\n\n                if (command.Upgrade) {\n                    return {\n                        kind: 'Upgrade',\n                        modules: command.Upgrade.modules.map((mod) => Array.from(fromBase64(mod))),\n                        dependencies: command.Upgrade.dependencies,\n                        packageId: command.Upgrade.package,\n                        ticket: convertTransactionArgument(command.Upgrade.ticket, inputs),\n                    };\n                }\n\n                throw new Error(`Unknown transaction ${Object.keys(command)}`);\n            },\n        ),\n    };\n}\n\nfunction convertTransactionArgument(\n    arg: Argument,\n    inputs: InferOutput<typeof TransactionInput>[],\n): InferOutput<typeof TransactionArgument> {\n    if (arg.$kind === 'GasCoin') {\n        return { kind: 'GasCoin' };\n    }\n    if (arg.$kind === 'Result') {\n        return { kind: 'Result', index: arg.Result };\n    }\n    if (arg.$kind === 'NestedResult') {\n        return {\n            kind: 'NestedResult',\n            index: arg.NestedResult[0],\n            resultIndex: arg.NestedResult[1],\n        };\n    }\n    if (arg.$kind === 'Input') {\n        return inputs[arg.Input];\n    }\n\n    throw new Error(`Invalid argument ${Object.keys(arg)}`);\n}\n\nexport function transactionDataFromV1(data: SerializedTransactionDataV1): TransactionData {\n    return parse(TransactionData, {\n        version: 2,\n        sender: data.sender ?? null,\n        expiration: data.expiration\n            ? 'Epoch' in data.expiration\n                ? { Epoch: data.expiration.Epoch }\n                : { None: true }\n            : null,\n        gasData: {\n            owner: data.gasConfig.owner ?? null,\n            budget: data.gasConfig.budget?.toString() ?? null,\n            price: data.gasConfig.price?.toString() ?? null,\n            payment:\n                data.gasConfig.payment?.map((ref) => ({\n                    digest: ref.digest,\n                    objectId: ref.objectId,\n                    version: ref.version.toString(),\n                })) ?? null,\n        },\n        inputs: data.inputs.map((input) => {\n            if (input.kind === 'Input') {\n                if (is(NormalizedCallArg, input.value)) {\n                    const value = parse(NormalizedCallArg, input.value);\n\n                    if (value.Object) {\n                        if (value.Object.ImmOrOwned) {\n                            return {\n                                Object: {\n                                    ImmOrOwnedObject: {\n                                        objectId: value.Object.ImmOrOwned.objectId,\n                                        version: String(value.Object.ImmOrOwned.version),\n                                        digest: value.Object.ImmOrOwned.digest,\n                                    },\n                                },\n                            };\n                        }\n                        if (value.Object.Shared) {\n                            return {\n                                Object: {\n                                    SharedObject: {\n                                        mutable: value.Object.Shared.mutable ?? null,\n                                        initialSharedVersion:\n                                            value.Object.Shared.initialSharedVersion,\n                                        objectId: value.Object.Shared.objectId,\n                                    },\n                                },\n                            };\n                        }\n                        if (value.Object.Receiving) {\n                            return {\n                                Object: {\n                                    Receiving: {\n                                        digest: value.Object.Receiving.digest,\n                                        version: String(value.Object.Receiving.version),\n                                        objectId: value.Object.Receiving.objectId,\n                                    },\n                                },\n                            };\n                        }\n\n                        throw new Error('Invalid object input');\n                    }\n\n                    return {\n                        Pure: {\n                            bytes: toBase64(new Uint8Array(value.Pure)),\n                        },\n                    };\n                }\n\n                if (input.type === 'object') {\n                    return {\n                        UnresolvedObject: {\n                            objectId: input.value as string,\n                        },\n                    };\n                }\n\n                return {\n                    UnresolvedPure: {\n                        value: input.value,\n                    },\n                };\n            }\n\n            throw new Error('Invalid input');\n        }),\n        commands: data.transactions.map((transaction) => {\n            switch (transaction.kind) {\n                case 'MakeMoveVec':\n                    return {\n                        MakeMoveVec: {\n                            type:\n                                'Some' in transaction.type\n                                    ? TypeTagSerializer.tagToString(transaction.type.Some)\n                                    : null,\n                            elements: transaction.objects.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                        },\n                    };\n                case 'MergeCoins': {\n                    return {\n                        MergeCoins: {\n                            destination: parseV1TransactionArgument(transaction.destination),\n                            sources: transaction.sources.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                        },\n                    };\n                }\n                case 'MoveCall': {\n                    const [pkg, mod, fn] = transaction.target.split('::');\n                    return {\n                        MoveCall: {\n                            package: pkg,\n                            module: mod,\n                            function: fn,\n                            typeArguments: transaction.typeArguments,\n                            arguments: transaction.arguments.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                        },\n                    };\n                }\n                case 'Publish': {\n                    return {\n                        Publish: {\n                            modules: transaction.modules.map((mod) =>\n                                toBase64(Uint8Array.from(mod)),\n                            ),\n                            dependencies: transaction.dependencies,\n                        },\n                    };\n                }\n                case 'SplitCoins': {\n                    return {\n                        SplitCoins: {\n                            coin: parseV1TransactionArgument(transaction.coin),\n                            amounts: transaction.amounts.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                        },\n                    };\n                }\n                case 'TransferObjects': {\n                    return {\n                        TransferObjects: {\n                            objects: transaction.objects.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                            address: parseV1TransactionArgument(transaction.address),\n                        },\n                    };\n                }\n                case 'Upgrade': {\n                    return {\n                        Upgrade: {\n                            modules: transaction.modules.map((mod) =>\n                                toBase64(Uint8Array.from(mod)),\n                            ),\n                            dependencies: transaction.dependencies,\n                            package: transaction.packageId,\n                            ticket: parseV1TransactionArgument(transaction.ticket),\n                        },\n                    };\n                }\n            }\n\n            throw new Error(`Unknown transaction ${Object.keys(transaction)}`);\n        }),\n    } satisfies InferInput<typeof TransactionData>);\n}\n\nfunction parseV1TransactionArgument(\n    arg: InferOutput<typeof TransactionArgument>,\n): InferInput<typeof Argument> {\n    switch (arg.kind) {\n        case 'GasCoin': {\n            return { GasCoin: true };\n        }\n        case 'Result':\n            return { Result: arg.index };\n        case 'NestedResult': {\n            return { NestedResult: [arg.index, arg.resultIndex] };\n        }\n        case 'Input': {\n            return { Input: arg.index };\n        }\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2117, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/transactions/data/v2.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EnumInputShape } from '@iota/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n    array,\n    boolean,\n    integer,\n    literal,\n    nullable,\n    nullish,\n    number,\n    object,\n    optional,\n    pipe,\n    record,\n    string,\n    tuple,\n    union,\n    unknown,\n} from 'valibot';\n\nimport { BCSBytes, JsonU64, ObjectID, ObjectRef, IotaAddress } from './internal.js';\n\ntype Merge<T> = T extends object ? { [K in keyof T]: T[K] } : never;\n\nfunction enumUnion<T extends Record<string, GenericSchema<any>>>(options: T) {\n    return union(\n        Object.entries(options).map(([key, value]) => object({ [key]: value })),\n    ) as GenericSchema<\n        EnumInputShape<\n            Merge<{\n                [K in keyof T]: InferInput<T[K]>;\n            }>\n        >\n    >;\n}\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L690-L702\nconst Argument = enumUnion({\n    GasCoin: literal(true),\n    Input: pipe(number(), integer()),\n    Result: pipe(number(), integer()),\n    NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]),\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L1387-L1392\nconst GasData = object({\n    budget: nullable(JsonU64),\n    price: nullable(JsonU64),\n    owner: nullable(IotaAddress),\n    payment: nullable(array(ObjectRef)),\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L707-L718\nconst ProgrammableMoveCall = object({\n    package: ObjectID,\n    module: string(),\n    function: string(),\n    // snake case in rust\n    typeArguments: array(string()),\n    arguments: array(Argument),\n});\n\nconst $Intent = object({\n    name: string(),\n    inputs: record(string(), union([Argument, array(Argument)])),\n    data: record(string(), unknown()),\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L657-L685\nconst Command = enumUnion({\n    MoveCall: ProgrammableMoveCall,\n    TransferObjects: object({\n        objects: array(Argument),\n        address: Argument,\n    }),\n    SplitCoins: object({\n        coin: Argument,\n        amounts: array(Argument),\n    }),\n    MergeCoins: object({\n        destination: Argument,\n        sources: array(Argument),\n    }),\n    Publish: object({\n        modules: array(BCSBytes),\n        dependencies: array(ObjectID),\n    }),\n    MakeMoveVec: object({\n        type: nullable(string()),\n        elements: array(Argument),\n    }),\n    Upgrade: object({\n        modules: array(BCSBytes),\n        dependencies: array(ObjectID),\n        package: ObjectID,\n        ticket: Argument,\n    }),\n    $Intent,\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L102-L114\nconst ObjectArg = enumUnion({\n    ImmOrOwnedObject: ObjectRef,\n    SharedObject: object({\n        objectId: ObjectID,\n        // snake case in rust\n        initialSharedVersion: JsonU64,\n        mutable: boolean(),\n    }),\n    Receiving: ObjectRef,\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L75-L80\nconst CallArg = enumUnion({\n    Object: ObjectArg,\n    Pure: object({\n        bytes: BCSBytes,\n    }),\n    UnresolvedPure: object({\n        value: unknown(),\n    }),\n    UnresolvedObject: object({\n        objectId: ObjectID,\n        version: optional(nullable(JsonU64)),\n        digest: optional(nullable(string())),\n        initialSharedVersion: optional(nullable(JsonU64)),\n    }),\n});\n\nconst TransactionExpiration = enumUnion({\n    None: literal(true),\n    Epoch: JsonU64,\n});\n\nexport const SerializedTransactionDataV2 = object({\n    version: literal(2),\n    sender: nullish(IotaAddress),\n    expiration: nullish(TransactionExpiration),\n    gasData: GasData,\n    inputs: array(CallArg),\n    commands: array(Command),\n});\n\nexport type SerializedTransactionDataV2 = InferOutput<typeof SerializedTransactionDataV2>;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2234, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/transactions/Inputs.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@iota/bcs';\nimport type { SerializedBcs } from '@iota/bcs';\n\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { CallArg, ObjectRef } from './data/internal.js';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction Pure(data: Uint8Array | SerializedBcs<any>): Extract<CallArg, { Pure: unknown }> {\n    return {\n        $kind: 'Pure',\n        Pure: {\n            bytes: data instanceof Uint8Array ? toBase64(data) : data.toBase64(),\n        },\n    };\n}\n\nexport const Inputs = {\n    Pure,\n    ObjectRef({ objectId, digest, version }: ObjectRef): Extract<CallArg, { Object: unknown }> {\n        return {\n            $kind: 'Object',\n            Object: {\n                $kind: 'ImmOrOwnedObject',\n                ImmOrOwnedObject: {\n                    digest,\n                    version,\n                    objectId: normalizeIotaAddress(objectId),\n                },\n            },\n        };\n    },\n    SharedObjectRef({\n        objectId,\n        mutable,\n        initialSharedVersion,\n    }: {\n        objectId: string;\n        mutable: boolean;\n        initialSharedVersion: number | string;\n    }): Extract<CallArg, { Object: unknown }> {\n        return {\n            $kind: 'Object',\n            Object: {\n                $kind: 'SharedObject',\n                SharedObject: {\n                    mutable,\n                    initialSharedVersion,\n                    objectId: normalizeIotaAddress(objectId),\n                },\n            },\n        };\n    },\n    ReceivingRef({ objectId, digest, version }: ObjectRef): Extract<CallArg, { Object: unknown }> {\n        return {\n            $kind: 'Object',\n            Object: {\n                $kind: 'Receiving',\n                Receiving: {\n                    digest,\n                    version,\n                    objectId: normalizeIotaAddress(objectId),\n                },\n            },\n        };\n    },\n};\n"],"names":[],"mappings":";;;;AAIA,SAAS,gBAAgB;AAGzB,SAAS,4BAA4B;;;AAIrC,SAAS,KAAK,IAAA,EAA4E;IACtF,OAAO;QACH,OAAO;QACP,MAAM;YACF,OAAO,gBAAgB,iBAAa,2MAAA,EAAS,IAAI,IAAI,KAAK,QAAA,CAAS;QACvE;IACJ;AACJ;AAEO,MAAM,SAAS;IAClB;IACA,WAAU,EAAE,QAAA,EAAU,MAAA,EAAQ,OAAA,CAAQ,CAAA,EAAqD;QACvF,OAAO;YACH,OAAO;YACP,QAAQ;gBACJ,OAAO;gBACP,kBAAkB;oBACd;oBACA;oBACA,cAAU,kPAAA,EAAqB,QAAQ;gBAC3C;YACJ;QACJ;IACJ;IACA,iBAAgB,EACZ,QAAA,EACA,OAAA,EACA,oBAAA,EACJ,EAI0C;QACtC,OAAO;YACH,OAAO;YACP,QAAQ;gBACJ,OAAO;gBACP,cAAc;oBACV;oBACA;oBACA,cAAU,kPAAA,EAAqB,QAAQ;gBAC3C;YACJ;QACJ;IACJ;IACA,cAAa,EAAE,QAAA,EAAU,MAAA,EAAQ,OAAA,CAAQ,CAAA,EAAqD;QAC1F,OAAO;YACH,OAAO;YACP,QAAQ;gBACJ,OAAO;gBACP,WAAW;oBACP;oBACA;oBACA,cAAU,kPAAA,EAAqB,QAAQ;gBAC3C;YACJ;QACJ;IACJ;AACJ"}},
    {"offset": {"line": 2298, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/bcs/bcs.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType, BcsTypeOptions } from '@iota/bcs';\nimport { bcs, fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from '@iota/bcs';\n\nimport {\n    isValidIotaAddress,\n    normalizeIotaAddress,\n    IOTA_ADDRESS_LENGTH,\n} from '../utils/iota-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\nimport type { TypeTag as TypeTagType } from './types.js';\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n    return bcs\n        .u64({\n            name: 'unsafe_u64',\n            ...(options as object),\n        })\n        .transform({\n            input: (val: number | string) => val,\n            output: (val) => Number(val),\n        });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n    return bcs.enum('Option', {\n        None: null,\n        Some: type,\n    });\n}\n\nexport const Address = bcs.bytes(IOTA_ADDRESS_LENGTH).transform({\n    validate: (val) => {\n        const address = typeof val === 'string' ? val : toHex(val);\n        if (!address || !isValidIotaAddress(normalizeIotaAddress(address))) {\n            throw new Error(`Invalid IOTA address ${address}`);\n        }\n    },\n    input: (val: string | Uint8Array) =>\n        typeof val === 'string' ? fromHex(normalizeIotaAddress(val)) : val,\n    output: (val) => normalizeIotaAddress(toHex(val)),\n});\n\nexport const ObjectDigest = bcs.vector(bcs.u8()).transform({\n    name: 'ObjectDigest',\n    input: (value: string) => fromBase58(value),\n    output: (value) => toBase58(new Uint8Array(value)),\n    validate: (value) => {\n        if (fromBase58(value).length !== 32) {\n            throw new Error('ObjectDigest must be 32 bytes');\n        }\n    },\n});\n\nexport const IotaObjectRef = bcs.struct('IotaObjectRef', {\n    objectId: Address,\n    version: bcs.u64(),\n    digest: ObjectDigest,\n});\n\nexport const SharedObjectRef = bcs.struct('SharedObjectRef', {\n    objectId: Address,\n    initialSharedVersion: bcs.u64(),\n    mutable: bcs.bool(),\n});\n\nexport const ObjectArg = bcs.enum('ObjectArg', {\n    ImmOrOwnedObject: IotaObjectRef,\n    SharedObject: SharedObjectRef,\n    Receiving: IotaObjectRef,\n});\n\nexport const Owner = bcs.enum('Owner', {\n    AddressOwner: Address,\n    ObjectOwner: Address,\n    Shared: bcs.struct('Shared', {\n        initialSharedVersion: bcs.u64(),\n    }),\n    Immutable: null,\n});\n\nexport const CallArg = bcs.enum('CallArg', {\n    Pure: bcs.struct('Pure', {\n        bytes: bcs.vector(bcs.u8()).transform({\n            input: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n            output: (val) => toBase64(new Uint8Array(val)),\n        }),\n    }),\n    Object: ObjectArg,\n});\n\nconst InnerTypeTag: BcsType<TypeTagType, TypeTagType> = bcs.enum('TypeTag', {\n    bool: null,\n    u8: null,\n    u64: null,\n    u128: null,\n    address: null,\n    signer: null,\n    vector: bcs.lazy(() => InnerTypeTag),\n    struct: bcs.lazy(() => StructTag),\n    u16: null,\n    u32: null,\n    u256: null,\n}) as BcsType<TypeTagType>;\n\nexport const TypeTag = InnerTypeTag.transform({\n    input: (typeTag: string | TypeTagType) =>\n        typeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,\n    output: (typeTag: TypeTagType) => TypeTagSerializer.tagToString(typeTag),\n});\n\nexport const Argument = bcs.enum('Argument', {\n    GasCoin: null,\n    Input: bcs.u16(),\n    Result: bcs.u16(),\n    NestedResult: bcs.tuple([bcs.u16(), bcs.u16()]),\n});\n\nexport const ProgrammableMoveCall = bcs.struct('ProgrammableMoveCall', {\n    package: Address,\n    module: bcs.string(),\n    function: bcs.string(),\n    typeArguments: bcs.vector(TypeTag),\n    arguments: bcs.vector(Argument),\n});\n\nexport const Command = bcs.enum('Command', {\n    /**\n     * A Move Call - any public Move function can be called via\n     * this transaction. The results can be used that instant to pass\n     * into the next transaction.\n     */\n    MoveCall: ProgrammableMoveCall,\n    /**\n     * Transfer vector of objects to a receiver.\n     */\n    TransferObjects: bcs.struct('TransferObjects', {\n        objects: bcs.vector(Argument),\n        address: Argument,\n    }),\n    // /**\n    //  * Split `amount` from a `coin`.\n    //  */\n    SplitCoins: bcs.struct('SplitCoins', {\n        coin: Argument,\n        amounts: bcs.vector(Argument),\n    }),\n    // /**\n    //  * Merge Vector of Coins (`sources`) into a `destination`.\n    //  */\n    MergeCoins: bcs.struct('MergeCoins', {\n        destination: Argument,\n        sources: bcs.vector(Argument),\n    }),\n    // /**\n    //  * Publish a Move module.\n    //  */\n    Publish: bcs.struct('Publish', {\n        modules: bcs.vector(\n            bcs.vector(bcs.u8()).transform({\n                input: (val: string | Uint8Array) =>\n                    typeof val === 'string' ? fromBase64(val) : val,\n                output: (val) => toBase64(new Uint8Array(val)),\n            }),\n        ),\n        dependencies: bcs.vector(Address),\n    }),\n    // /**\n    //  * Build a vector of objects using the input arguments.\n    //  * It is impossible to export construct a `vector<T: key>` otherwise,\n    //  * so this call serves a utility function.\n    //  */\n    MakeMoveVec: bcs.struct('MakeMoveVec', {\n        type: optionEnum(TypeTag).transform({\n            input: (val: string | null) =>\n                val === null\n                    ? {\n                          None: true,\n                      }\n                    : {\n                          Some: val,\n                      },\n            output: (val) => val.Some ?? null,\n        }),\n        elements: bcs.vector(Argument),\n    }),\n    Upgrade: bcs.struct('Upgrade', {\n        modules: bcs.vector(\n            bcs.vector(bcs.u8()).transform({\n                input: (val: string | Uint8Array) =>\n                    typeof val === 'string' ? fromBase64(val) : val,\n                output: (val) => toBase64(new Uint8Array(val)),\n            }),\n        ),\n        dependencies: bcs.vector(Address),\n        package: Address,\n        ticket: Argument,\n    }),\n});\n\nexport const ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n    inputs: bcs.vector(CallArg),\n    commands: bcs.vector(Command),\n});\n\nexport const TransactionKind = bcs.enum('TransactionKind', {\n    ProgrammableTransaction: ProgrammableTransaction,\n    ChangeEpoch: null,\n    Genesis: null,\n    ConsensusCommitPrologue: null,\n});\n\nexport const TransactionExpiration = bcs.enum('TransactionExpiration', {\n    None: null,\n    Epoch: unsafe_u64(),\n});\n\nexport const StructTag = bcs.struct('StructTag', {\n    address: Address,\n    module: bcs.string(),\n    name: bcs.string(),\n    typeParams: bcs.vector(InnerTypeTag),\n});\n\nexport const GasData = bcs.struct('GasData', {\n    payment: bcs.vector(IotaObjectRef),\n    owner: Address,\n    price: bcs.u64(),\n    budget: bcs.u64(),\n});\n\nexport const TransactionDataV1 = bcs.struct('TransactionDataV1', {\n    kind: TransactionKind,\n    sender: Address,\n    gasData: GasData,\n    expiration: TransactionExpiration,\n});\n\nexport const TransactionData = bcs.enum('TransactionData', {\n    V1: TransactionDataV1,\n});\n\nexport const IntentScope = bcs.enum('IntentScope', {\n    TransactionData: null,\n    TransactionEffects: null,\n    CheckpointSummary: null,\n    PersonalMessage: null,\n});\n\nexport const IntentVersion = bcs.enum('IntentVersion', {\n    V0: null,\n});\n\nexport const AppId = bcs.enum('AppId', {\n    Iota: null,\n});\n\nexport const Intent = bcs.struct('Intent', {\n    scope: IntentScope,\n    version: IntentVersion,\n    appId: AppId,\n});\n\nexport function IntentMessage<T extends BcsType<any>>(T: T) {\n    return bcs.struct(`IntentMessage<${T.name}>`, {\n        intent: Intent,\n        value: T,\n    });\n}\n\nexport const CompressedSignature = bcs.enum('CompressedSignature', {\n    ED25519: bcs.fixedArray(64, bcs.u8()),\n    Secp256k1: bcs.fixedArray(64, bcs.u8()),\n    Secp256r1: bcs.fixedArray(64, bcs.u8()),\n});\n\nexport const PublicKey = bcs.enum('PublicKey', {\n    ED25519: bcs.fixedArray(32, bcs.u8()),\n    Secp256k1: bcs.fixedArray(33, bcs.u8()),\n    Secp256r1: bcs.fixedArray(33, bcs.u8()),\n});\n\nexport const MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n    pubKey: PublicKey,\n    weight: bcs.u8(),\n});\n\nexport const MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n    pk_map: bcs.vector(MultiSigPkMap),\n    threshold: bcs.u16(),\n});\n\nexport const MultiSig = bcs.struct('MultiSig', {\n    sigs: bcs.vector(CompressedSignature),\n    bitmap: bcs.u16(),\n    multisig_pk: MultiSigPublicKey,\n});\n\nexport const base64String = bcs.vector(bcs.u8()).transform({\n    input: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n    output: (val) => toBase64(new Uint8Array(val)),\n});\n\nexport const SenderSignedTransaction = bcs.struct('SenderSignedTransaction', {\n    intentMessage: IntentMessage(TransactionData),\n    txSignatures: bcs.vector(base64String),\n});\n\nexport const SenderSignedData = bcs.vector(SenderSignedTransaction, {\n    name: 'SenderSignedData',\n});\n\nexport const PasskeyAuthenticator = bcs.struct('PasskeyAuthenticator', {\n    authenticatorData: bcs.vector(bcs.u8()),\n    clientDataJson: bcs.string(),\n    userSignature: bcs.vector(bcs.u8()),\n});\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA,SAAS,KAAK,YAAY,YAAY,SAAS,UAAU,UAAU,aAAa;AAEhF;AAKA,SAAS,yBAAyB;;;;AAGlC,SAAS,WAAW,OAAA,EAAkC;IAClD,OAAO,sMAAA,CACF,GAAA,CAAI;QACD,MAAM;QACN,GAAI,OAAA;IACR,CAAC,EACA,SAAA,CAAU;QACP,OAAO,CAAC,MAAyB;QACjC,QAAQ,CAAC,MAAQ,OAAO,GAAG;IAC/B,CAAC;AACT;AAGA,SAAS,WAAwC,IAAA,EAAS;IACtD,OAAO,sMAAA,CAAI,IAAA,CAAK,UAAU;QACtB,MAAM;QACN,MAAM;IACV,CAAC;AACL;AAEO,MAAM,UAAU,sMAAA,CAAI,KAAA,CAAM,iPAAmB,EAAE,SAAA,CAAU;IAC5D,UAAU,CAAC,QAAQ;QACf,MAAM,UAAU,OAAO,QAAQ,WAAW,UAAM,wMAAA,EAAM,GAAG;QACzD,IAAI,CAAC,WAAW,KAAC,gPAAA,MAAmB,kPAAA,EAAqB,OAAO,CAAC,GAAG;YAChE,MAAM,IAAI,MAAM,CAAA,qBAAA,EAAwB,OAAO,EAAE;QACrD;IACJ;IACA,OAAO,CAAC,MACJ,OAAO,QAAQ,eAAW,0MAAA,MAAQ,kPAAA,EAAqB,GAAG,CAAC,IAAI;IACnE,QAAQ,CAAC,UAAQ,kPAAA,MAAqB,wMAAA,EAAM,GAAG,CAAC;AACpD,CAAC;AAEM,MAAM,eAAe,sMAAA,CAAI,MAAA,CAAO,sMAAA,CAAI,EAAA,CAAG,CAAC,EAAE,SAAA,CAAU;IACvD,MAAM;IACN,OAAO,CAAC,YAAkB,6MAAA,EAAW,KAAK;IAC1C,QAAQ,CAAC,YAAU,2MAAA,EAAS,IAAI,WAAW,KAAK,CAAC;IACjD,UAAU,CAAC,UAAU;QACjB,QAAI,6MAAA,EAAW,KAAK,EAAE,MAAA,KAAW,IAAI;YACjC,MAAM,IAAI,MAAM,+BAA+B;QACnD;IACJ;AACJ,CAAC;AAEM,MAAM,gBAAgB,sMAAA,CAAI,MAAA,CAAO,iBAAiB;IACrD,UAAU;IACV,SAAS,sMAAA,CAAI,GAAA,CAAI;IACjB,QAAQ;AACZ,CAAC;AAEM,MAAM,kBAAkB,sMAAA,CAAI,MAAA,CAAO,mBAAmB;IACzD,UAAU;IACV,sBAAsB,sMAAA,CAAI,GAAA,CAAI;IAC9B,SAAS,sMAAA,CAAI,IAAA,CAAK;AACtB,CAAC;AAEM,MAAM,YAAY,sMAAA,CAAI,IAAA,CAAK,aAAa;IAC3C,kBAAkB;IAClB,cAAc;IACd,WAAW;AACf,CAAC;AAEM,MAAM,QAAQ,sMAAA,CAAI,IAAA,CAAK,SAAS;IACnC,cAAc;IACd,aAAa;IACb,QAAQ,sMAAA,CAAI,MAAA,CAAO,UAAU;QACzB,sBAAsB,sMAAA,CAAI,GAAA,CAAI;IAClC,CAAC;IACD,WAAW;AACf,CAAC;AAEM,MAAM,UAAU,sMAAA,CAAI,IAAA,CAAK,WAAW;IACvC,MAAM,sMAAA,CAAI,MAAA,CAAO,QAAQ;QACrB,OAAO,sMAAA,CAAI,MAAA,CAAO,sMAAA,CAAI,EAAA,CAAG,CAAC,EAAE,SAAA,CAAU;YAClC,OAAO,CAAC,MAA8B,OAAO,QAAQ,eAAW,6MAAA,EAAW,GAAG,IAAI;YAClF,QAAQ,CAAC,UAAQ,2MAAA,EAAS,IAAI,WAAW,GAAG,CAAC;QACjD,CAAC;IACL,CAAC;IACD,QAAQ;AACZ,CAAC;AAED,MAAM,eAAkD,sMAAA,CAAI,IAAA,CAAK,WAAW;IACxE,MAAM;IACN,IAAI;IACJ,KAAK;IACL,MAAM;IACN,SAAS;IACT,QAAQ;IACR,QAAQ,sMAAA,CAAI,IAAA,CAAK,IAAM,YAAY;IACnC,QAAQ,sMAAA,CAAI,IAAA,CAAK,IAAM,SAAS;IAChC,KAAK;IACL,KAAK;IACL,MAAM;AACV,CAAC;AAEM,MAAM,UAAU,aAAa,SAAA,CAAU;IAC1C,OAAO,CAAC,UACJ,OAAO,YAAY,WAAW,yPAAA,CAAkB,YAAA,CAAa,SAAS,IAAI,IAAI;IAClF,QAAQ,CAAC,UAAyB,yPAAA,CAAkB,WAAA,CAAY,OAAO;AAC3E,CAAC;AAEM,MAAM,WAAW,sMAAA,CAAI,IAAA,CAAK,YAAY;IACzC,SAAS;IACT,OAAO,sMAAA,CAAI,GAAA,CAAI;IACf,QAAQ,sMAAA,CAAI,GAAA,CAAI;IAChB,cAAc,sMAAA,CAAI,KAAA,CAAM;QAAC,sMAAA,CAAI,GAAA,CAAI;QAAG,sMAAA,CAAI,GAAA,CAAI,CAAC;KAAC;AAClD,CAAC;AAEM,MAAM,uBAAuB,sMAAA,CAAI,MAAA,CAAO,wBAAwB;IACnE,SAAS;IACT,QAAQ,sMAAA,CAAI,MAAA,CAAO;IACnB,UAAU,sMAAA,CAAI,MAAA,CAAO;IACrB,eAAe,sMAAA,CAAI,MAAA,CAAO,OAAO;IACjC,WAAW,sMAAA,CAAI,MAAA,CAAO,QAAQ;AAClC,CAAC;AAEM,MAAM,UAAU,sMAAA,CAAI,IAAA,CAAK,WAAW;IAAA;;;;GAAA,GAMvC,UAAU;IAAA;;GAAA,GAIV,iBAAiB,sMAAA,CAAI,MAAA,CAAO,mBAAmB;QAC3C,SAAS,sMAAA,CAAI,MAAA,CAAO,QAAQ;QAC5B,SAAS;IACb,CAAC;IAAA,MAAA;IAAA,mCAAA;IAAA,MAAA;IAID,YAAY,sMAAA,CAAI,MAAA,CAAO,cAAc;QACjC,MAAM;QACN,SAAS,sMAAA,CAAI,MAAA,CAAO,QAAQ;IAChC,CAAC;IAAA,MAAA;IAAA,6DAAA;IAAA,MAAA;IAID,YAAY,sMAAA,CAAI,MAAA,CAAO,cAAc;QACjC,aAAa;QACb,SAAS,sMAAA,CAAI,MAAA,CAAO,QAAQ;IAChC,CAAC;IAAA,MAAA;IAAA,4BAAA;IAAA,MAAA;IAID,SAAS,sMAAA,CAAI,MAAA,CAAO,WAAW;QAC3B,SAAS,sMAAA,CAAI,MAAA,CACT,sMAAA,CAAI,MAAA,CAAO,sMAAA,CAAI,EAAA,CAAG,CAAC,EAAE,SAAA,CAAU;YAC3B,OAAO,CAAC,MACJ,OAAO,QAAQ,eAAW,6MAAA,EAAW,GAAG,IAAI;YAChD,QAAQ,CAAC,UAAQ,2MAAA,EAAS,IAAI,WAAW,GAAG,CAAC;QACjD,CAAC;QAEL,cAAc,sMAAA,CAAI,MAAA,CAAO,OAAO;IACpC,CAAC;IAAA,MAAA;IAAA,0DAAA;IAAA,wEAAA;IAAA,6CAAA;IAAA,MAAA;IAMD,aAAa,sMAAA,CAAI,MAAA,CAAO,eAAe;QACnC,MAAM,WAAW,OAAO,EAAE,SAAA,CAAU;YAChC,OAAO,CAAC,MACJ,QAAQ,OACF;oBACI,MAAM;gBACV,IACA;oBACI,MAAM;gBACV;YACV,QAAQ,CAAC,MAAQ,IAAI,IAAA,IAAQ;QACjC,CAAC;QACD,UAAU,sMAAA,CAAI,MAAA,CAAO,QAAQ;IACjC,CAAC;IACD,SAAS,sMAAA,CAAI,MAAA,CAAO,WAAW;QAC3B,SAAS,sMAAA,CAAI,MAAA,CACT,sMAAA,CAAI,MAAA,CAAO,sMAAA,CAAI,EAAA,CAAG,CAAC,EAAE,SAAA,CAAU;YAC3B,OAAO,CAAC,MACJ,OAAO,QAAQ,eAAW,6MAAA,EAAW,GAAG,IAAI;YAChD,QAAQ,CAAC,UAAQ,2MAAA,EAAS,IAAI,WAAW,GAAG,CAAC;QACjD,CAAC;QAEL,cAAc,sMAAA,CAAI,MAAA,CAAO,OAAO;QAChC,SAAS;QACT,QAAQ;IACZ,CAAC;AACL,CAAC;AAEM,MAAM,0BAA0B,sMAAA,CAAI,MAAA,CAAO,2BAA2B;IACzE,QAAQ,sMAAA,CAAI,MAAA,CAAO,OAAO;IAC1B,UAAU,sMAAA,CAAI,MAAA,CAAO,OAAO;AAChC,CAAC;AAEM,MAAM,kBAAkB,sMAAA,CAAI,IAAA,CAAK,mBAAmB;IACvD;IACA,aAAa;IACb,SAAS;IACT,yBAAyB;AAC7B,CAAC;AAEM,MAAM,wBAAwB,sMAAA,CAAI,IAAA,CAAK,yBAAyB;IACnE,MAAM;IACN,OAAO,WAAW;AACtB,CAAC;AAEM,MAAM,YAAY,sMAAA,CAAI,MAAA,CAAO,aAAa;IAC7C,SAAS;IACT,QAAQ,sMAAA,CAAI,MAAA,CAAO;IACnB,MAAM,sMAAA,CAAI,MAAA,CAAO;IACjB,YAAY,sMAAA,CAAI,MAAA,CAAO,YAAY;AACvC,CAAC;AAEM,MAAM,UAAU,sMAAA,CAAI,MAAA,CAAO,WAAW;IACzC,SAAS,sMAAA,CAAI,MAAA,CAAO,aAAa;IACjC,OAAO;IACP,OAAO,sMAAA,CAAI,GAAA,CAAI;IACf,QAAQ,sMAAA,CAAI,GAAA,CAAI;AACpB,CAAC;AAEM,MAAM,oBAAoB,sMAAA,CAAI,MAAA,CAAO,qBAAqB;IAC7D,MAAM;IACN,QAAQ;IACR,SAAS;IACT,YAAY;AAChB,CAAC;AAEM,MAAM,kBAAkB,sMAAA,CAAI,IAAA,CAAK,mBAAmB;IACvD,IAAI;AACR,CAAC;AAEM,MAAM,cAAc,sMAAA,CAAI,IAAA,CAAK,eAAe;IAC/C,iBAAiB;IACjB,oBAAoB;IACpB,mBAAmB;IACnB,iBAAiB;AACrB,CAAC;AAEM,MAAM,gBAAgB,sMAAA,CAAI,IAAA,CAAK,iBAAiB;IACnD,IAAI;AACR,CAAC;AAEM,MAAM,QAAQ,sMAAA,CAAI,IAAA,CAAK,SAAS;IACnC,MAAM;AACV,CAAC;AAEM,MAAM,SAAS,sMAAA,CAAI,MAAA,CAAO,UAAU;IACvC,OAAO;IACP,SAAS;IACT,OAAO;AACX,CAAC;AAEM,SAAS,cAAsC,CAAA,EAAM;IACxD,OAAO,sMAAA,CAAI,MAAA,CAAO,CAAA,cAAA,EAAiB,EAAE,IAAI,CAAA,CAAA,CAAA,EAAK;QAC1C,QAAQ;QACR,OAAO;IACX,CAAC;AACL;AAEO,MAAM,sBAAsB,sMAAA,CAAI,IAAA,CAAK,uBAAuB;IAC/D,SAAS,sMAAA,CAAI,UAAA,CAAW,IAAI,sMAAA,CAAI,EAAA,CAAG,CAAC;IACpC,WAAW,sMAAA,CAAI,UAAA,CAAW,IAAI,sMAAA,CAAI,EAAA,CAAG,CAAC;IACtC,WAAW,sMAAA,CAAI,UAAA,CAAW,IAAI,sMAAA,CAAI,EAAA,CAAG,CAAC;AAC1C,CAAC;AAEM,MAAM,YAAY,sMAAA,CAAI,IAAA,CAAK,aAAa;IAC3C,SAAS,sMAAA,CAAI,UAAA,CAAW,IAAI,sMAAA,CAAI,EAAA,CAAG,CAAC;IACpC,WAAW,sMAAA,CAAI,UAAA,CAAW,IAAI,sMAAA,CAAI,EAAA,CAAG,CAAC;IACtC,WAAW,sMAAA,CAAI,UAAA,CAAW,IAAI,sMAAA,CAAI,EAAA,CAAG,CAAC;AAC1C,CAAC;AAEM,MAAM,gBAAgB,sMAAA,CAAI,MAAA,CAAO,iBAAiB;IACrD,QAAQ;IACR,QAAQ,sMAAA,CAAI,EAAA,CAAG;AACnB,CAAC;AAEM,MAAM,oBAAoB,sMAAA,CAAI,MAAA,CAAO,qBAAqB;IAC7D,QAAQ,sMAAA,CAAI,MAAA,CAAO,aAAa;IAChC,WAAW,sMAAA,CAAI,GAAA,CAAI;AACvB,CAAC;AAEM,MAAM,WAAW,sMAAA,CAAI,MAAA,CAAO,YAAY;IAC3C,MAAM,sMAAA,CAAI,MAAA,CAAO,mBAAmB;IACpC,QAAQ,sMAAA,CAAI,GAAA,CAAI;IAChB,aAAa;AACjB,CAAC;AAEM,MAAM,eAAe,sMAAA,CAAI,MAAA,CAAO,sMAAA,CAAI,EAAA,CAAG,CAAC,EAAE,SAAA,CAAU;IACvD,OAAO,CAAC,MAA8B,OAAO,QAAQ,eAAW,6MAAA,EAAW,GAAG,IAAI;IAClF,QAAQ,CAAC,UAAQ,2MAAA,EAAS,IAAI,WAAW,GAAG,CAAC;AACjD,CAAC;AAEM,MAAM,0BAA0B,sMAAA,CAAI,MAAA,CAAO,2BAA2B;IACzE,eAAe,cAAc,eAAe;IAC5C,cAAc,sMAAA,CAAI,MAAA,CAAO,YAAY;AACzC,CAAC;AAEM,MAAM,mBAAmB,sMAAA,CAAI,MAAA,CAAO,yBAAyB;IAChE,MAAM;AACV,CAAC;AAEM,MAAM,uBAAuB,sMAAA,CAAI,MAAA,CAAO,wBAAwB;IACnE,mBAAmB,sMAAA,CAAI,MAAA,CAAO,sMAAA,CAAI,EAAA,CAAG,CAAC;IACtC,gBAAgB,sMAAA,CAAI,MAAA,CAAO;IAC3B,eAAe,sMAAA,CAAI,MAAA,CAAO,sMAAA,CAAI,EAAA,CAAG,CAAC;AACtC,CAAC"}},
    {"offset": {"line": 2638, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/bcs/effects.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@iota/bcs';\n\nimport { Address, ObjectDigest, Owner } from './bcs.js';\n\nconst PackageUpgradeError = bcs.enum('PackageUpgradeError', {\n    UnableToFetchPackage: bcs.struct('UnableToFetchPackage', { packageId: Address }),\n    NotAPackage: bcs.struct('NotAPackage', { objectId: Address }),\n    IncompatibleUpgrade: null,\n    DigestDoesNotMatch: bcs.struct('DigestDoesNotMatch', { digest: bcs.vector(bcs.u8()) }),\n    UnknownUpgradePolicy: bcs.struct('UnknownUpgradePolicy', { policy: bcs.u8() }),\n    PackageIDDoesNotMatch: bcs.struct('PackageIDDoesNotMatch', {\n        packageId: Address,\n        ticketId: Address,\n    }),\n});\n\nconst ModuleId = bcs.struct('ModuleId', {\n    address: Address,\n    name: bcs.string(),\n});\nconst MoveLocation = bcs.struct('MoveLocation', {\n    module: ModuleId,\n    function: bcs.u16(),\n    instruction: bcs.u16(),\n    functionName: bcs.option(bcs.string()),\n});\n\nconst CommandArgumentError = bcs.enum('CommandArgumentError', {\n    TypeMismatch: null,\n    InvalidBCSBytes: null,\n    InvalidUsageOfPureArg: null,\n    InvalidArgumentToPrivateEntryFunction: null,\n    IndexOutOfBounds: bcs.struct('IndexOutOfBounds', { idx: bcs.u16() }),\n    SecondaryIndexOutOfBounds: bcs.struct('SecondaryIndexOutOfBounds', {\n        resultIdx: bcs.u16(),\n        secondaryIdx: bcs.u16(),\n    }),\n    InvalidResultArity: bcs.struct('InvalidResultArity', { resultIdx: bcs.u16() }),\n    InvalidGasCoinUsage: null,\n    InvalidValueUsage: null,\n    InvalidObjectByValue: null,\n    InvalidObjectByMutRef: null,\n    SharedObjectOperationNotAllowed: null,\n});\n\nconst TypeArgumentError = bcs.enum('TypeArgumentError', {\n    TypeNotFound: null,\n    ConstraintNotSatisfied: null,\n});\n\nconst ExecutionFailureStatus = bcs.enum('ExecutionFailureStatus', {\n    InsufficientGas: null,\n    InvalidGasObject: null,\n    InvariantViolation: null,\n    FeatureNotYetSupported: null,\n    MoveObjectTooBig: bcs.struct('MoveObjectTooBig', {\n        objectSize: bcs.u64(),\n        maxObjectSize: bcs.u64(),\n    }),\n    MovePackageTooBig: bcs.struct('MovePackageTooBig', {\n        objectSize: bcs.u64(),\n        maxObjectSize: bcs.u64(),\n    }),\n    CircularObjectOwnership: bcs.struct('CircularObjectOwnership', { object: Address }),\n    InsufficientCoinBalance: null,\n    CoinBalanceOverflow: null,\n    PublishErrorNonZeroAddress: null,\n    IotaMoveVerificationError: null,\n    MovePrimitiveRuntimeError: bcs.option(MoveLocation),\n    MoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),\n    VMVerificationOrDeserializationError: null,\n    VMInvariantViolation: null,\n    FunctionNotFound: null,\n    ArityMismatch: null,\n    TypeArityMismatch: null,\n    NonEntryFunctionInvoked: null,\n    CommandArgumentError: bcs.struct('CommandArgumentError', {\n        argIdx: bcs.u16(),\n        kind: CommandArgumentError,\n    }),\n    TypeArgumentError: bcs.struct('TypeArgumentError', {\n        argumentIdx: bcs.u16(),\n        kind: TypeArgumentError,\n    }),\n    UnusedValueWithoutDrop: bcs.struct('UnusedValueWithoutDrop', {\n        resultIdx: bcs.u16(),\n        secondaryIdx: bcs.u16(),\n    }),\n    InvalidPublicFunctionReturnType: bcs.struct('InvalidPublicFunctionReturnType', {\n        idx: bcs.u16(),\n    }),\n    InvalidTransferObject: null,\n    EffectsTooLarge: bcs.struct('EffectsTooLarge', { currentSize: bcs.u64(), maxSize: bcs.u64() }),\n    PublishUpgradeMissingDependency: null,\n    PublishUpgradeDependencyDowngrade: null,\n    PackageUpgradeError: bcs.struct('PackageUpgradeError', { upgradeError: PackageUpgradeError }),\n    WrittenObjectsTooLarge: bcs.struct('WrittenObjectsTooLarge', {\n        currentSize: bcs.u64(),\n        maxSize: bcs.u64(),\n    }),\n    CertificateDenied: null,\n    IotaMoveVerificationTimedout: null,\n    SharedObjectOperationNotAllowed: null,\n    InputObjectDeleted: null,\n    ExecutionCancelledDueToSharedObjectCongestion: bcs.struct(\n        'ExecutionCancelledDueToSharedObjectCongestion',\n        {\n            congestedObjects: bcs.vector(Address),\n        },\n    ),\n    AddressDeniedForCoin: bcs.struct('AddressDeniedForCoin', {\n        address: Address,\n        coinType: bcs.string(),\n    }),\n    CoinTypeGlobalPause: bcs.struct('CoinTypeGlobalPause', { coinType: bcs.string() }),\n    ExecutionCancelledDueToRandomnessUnavailable: null,\n});\n\nconst ExecutionStatus = bcs.enum('ExecutionStatus', {\n    Success: null,\n    Failed: bcs.struct('ExecutionFailed', {\n        error: ExecutionFailureStatus,\n        command: bcs.option(bcs.u64()),\n    }),\n});\n\nconst GasCostSummary = bcs.struct('GasCostSummary', {\n    computationCost: bcs.u64(),\n    computationCostBurned: bcs.u64(),\n    storageCost: bcs.u64(),\n    storageRebate: bcs.u64(),\n    nonRefundableStorageFee: bcs.u64(),\n});\n\nconst VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);\n\nconst ObjectIn = bcs.enum('ObjectIn', {\n    NotExist: null,\n    Exist: bcs.tuple([VersionDigest, Owner]),\n});\n\nexport const ObjectOut = bcs.enum('ObjectOut', {\n    NotExist: null,\n    ObjectWrite: bcs.tuple([ObjectDigest, Owner]),\n    PackageWrite: VersionDigest,\n});\n\nconst IDOperation = bcs.enum('IDOperation', {\n    None: null,\n    Created: null,\n    Deleted: null,\n});\n\nconst EffectsObjectChange = bcs.struct('EffectsObjectChange', {\n    inputState: ObjectIn,\n    outputState: ObjectOut,\n    idOperation: IDOperation,\n});\n\nconst UnchangedSharedKind = bcs.enum('UnchangedSharedKind', {\n    ReadOnlyRoot: VersionDigest,\n    MutateDeleted: bcs.u64(),\n    ReadDeleted: bcs.u64(),\n    Cancelled: bcs.u64(),\n    PerEpochConfig: null,\n});\n\nconst TransactionEffectsV1 = bcs.struct('TransactionEffectsV1', {\n    status: ExecutionStatus,\n    executedEpoch: bcs.u64(),\n    gasUsed: GasCostSummary,\n    transactionDigest: ObjectDigest,\n    gasObjectIndex: bcs.option(bcs.u32()),\n    eventsDigest: bcs.option(ObjectDigest),\n    dependencies: bcs.vector(ObjectDigest),\n    lamportVersion: bcs.u64(),\n    changedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),\n    unchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),\n    auxDataDigest: bcs.option(ObjectDigest),\n});\n\nexport const TransactionEffects = bcs.enum('TransactionEffects', {\n    V1: TransactionEffectsV1,\n});\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2856, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/bcs/index.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@iota/bcs';\n\nimport {\n    Address,\n    AppId,\n    Argument,\n    CallArg,\n    Command,\n    CompressedSignature,\n    GasData,\n    Intent,\n    IntentMessage,\n    IntentScope,\n    IntentVersion,\n    MultiSig,\n    MultiSigPkMap,\n    MultiSigPublicKey,\n    ObjectArg,\n    ObjectDigest,\n    Owner,\n    ProgrammableMoveCall,\n    ProgrammableTransaction,\n    PublicKey,\n    SenderSignedData,\n    SenderSignedTransaction,\n    SharedObjectRef,\n    StructTag,\n    IotaObjectRef,\n    TransactionData,\n    TransactionDataV1,\n    TransactionExpiration,\n    TransactionKind,\n    TypeTag,\n    PasskeyAuthenticator,\n} from './bcs.js';\nimport { TransactionEffects } from './effects.js';\n\nexport type { TypeTag } from './types.js';\n\nexport { TypeTagSerializer } from './type-tag-serializer.js';\nexport { BcsType, type BcsTypeOptions } from '@iota/bcs';\n\nconst iotaBcs = {\n    ...bcs,\n    U8: bcs.u8(),\n    U16: bcs.u16(),\n    U32: bcs.u32(),\n    U64: bcs.u64(),\n    U128: bcs.u128(),\n    U256: bcs.u256(),\n    ULEB128: bcs.uleb128(),\n    Bool: bcs.bool(),\n    String: bcs.string(),\n    Address,\n    AppId,\n    Argument,\n    CallArg,\n    CompressedSignature,\n    GasData,\n    Intent,\n    IntentMessage,\n    IntentScope,\n    IntentVersion,\n    MultiSig,\n    MultiSigPkMap,\n    MultiSigPublicKey,\n    ObjectArg,\n    ObjectDigest,\n    Owner,\n    ProgrammableMoveCall,\n    ProgrammableTransaction,\n    PublicKey,\n    SenderSignedData,\n    SenderSignedTransaction,\n    SharedObjectRef,\n    StructTag,\n    IotaObjectRef,\n    Command,\n    TransactionData,\n    TransactionDataV1,\n    TransactionExpiration,\n    TransactionKind,\n    TypeTag,\n    TransactionEffects,\n    PasskeyAuthenticator,\n};\n\nexport { iotaBcs as bcs };\n"],"names":[],"mappings":";;;;AAIA,SAAS,WAAW;AAEpB;AAiCA,SAAS,0BAA0B;AAInC,SAAS,yBAAyB;AAClC,SAAS,eAAoC;;;;;;AAE7C,MAAM,UAAU;IACZ,GAAG,sMAAA;IACH,IAAI,sMAAA,CAAI,EAAA,CAAG;IACX,KAAK,sMAAA,CAAI,GAAA,CAAI;IACb,KAAK,sMAAA,CAAI,GAAA,CAAI;IACb,KAAK,sMAAA,CAAI,GAAA,CAAI;IACb,MAAM,sMAAA,CAAI,IAAA,CAAK;IACf,MAAM,sMAAA,CAAI,IAAA,CAAK;IACf,SAAS,sMAAA,CAAI,OAAA,CAAQ;IACrB,MAAM,sMAAA,CAAI,IAAA,CAAK;IACf,QAAQ,sMAAA,CAAI,MAAA,CAAO;aACnB,yNAAA;WACA,uNAAA;cACA,0NAAA;aACA,yNAAA;yBACA,qOAAA;aACA,yNAAA;YACA,wNAAA;mBACA,+NAAA;iBACA,6NAAA;mBACA,+NAAA;cACA,0NAAA;mBACA,+NAAA;uBACA,mOAAA;eACA,2NAAA;kBACA,8NAAA;WACA,uNAAA;0BACA,sOAAA;6BACA,yOAAA;eACA,2NAAA;sBACA,kOAAA;6BACA,yOAAA;qBACA,iOAAA;eACA,2NAAA;mBACA,+NAAA;aACA,yNAAA;qBACA,iOAAA;uBACA,mOAAA;2BACA,uOAAA;qBACA,iOAAA;aACA,yNAAA;wBACA,wOAAA;0BACA,sOAAA;AACJ"}},
    {"offset": {"line": 2920, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/utils/constants.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { normalizeIotaObjectId } from './iota-types.js';\n\nexport const IOTA_DECIMALS = 9;\nexport const NANOS_PER_IOTA = BigInt(1000000000);\n\nexport const MOVE_STDLIB_ADDRESS = '0x1';\nexport const IOTA_FRAMEWORK_ADDRESS = '0x2';\nexport const IOTA_SYSTEM_ADDRESS = '0x3';\nexport const IOTA_CLOCK_OBJECT_ID = normalizeIotaObjectId('0x6');\nexport const IOTA_SYSTEM_MODULE_NAME = 'iota_system';\nexport const IOTA_TYPE_ARG = `${IOTA_FRAMEWORK_ADDRESS}::iota::IOTA`;\nexport const IOTA_SYSTEM_STATE_OBJECT_ID: string = normalizeIotaObjectId('0x5');\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAIA,SAAS,6BAA6B;;AAE/B,MAAM,gBAAgB;AACtB,MAAM,iBAAiB,OAAO,GAAU;AAExC,MAAM,sBAAsB;AAC5B,MAAM,yBAAyB;AAC/B,MAAM,sBAAsB;AAC5B,MAAM,2BAAuB,mPAAA,EAAsB,KAAK;AACxD,MAAM,0BAA0B;AAChC,MAAM,gBAAgB,GAAG,sBAAsB,CAAA,YAAA,CAAA;AAC/C,MAAM,kCAAsC,mPAAA,EAAsB,KAAK"}},
    {"offset": {"line": 2957, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/transactions/serializer.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType } from '@iota/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport type { IotaMoveNormalizedType } from '../client/index.js';\nimport { MOVE_STDLIB_ADDRESS, IOTA_FRAMEWORK_ADDRESS } from '../utils/index.js';\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { OpenMoveTypeSignature, OpenMoveTypeSignatureBody } from './data/internal.js';\n\nconst OBJECT_MODULE_NAME = 'object';\nconst ID_STRUCT_NAME = 'ID';\n\nconst STD_ASCII_MODULE_NAME = 'ascii';\nconst STD_ASCII_STRUCT_NAME = 'String';\n\nconst STD_UTF8_MODULE_NAME = 'string';\nconst STD_UTF8_STRUCT_NAME = 'String';\n\nconst STD_OPTION_MODULE_NAME = 'option';\nconst STD_OPTION_STRUCT_NAME = 'Option';\n\nexport function isTxContext(param: OpenMoveTypeSignature): boolean {\n    const struct =\n        typeof param.body === 'object' && 'datatype' in param.body ? param.body.datatype : null;\n\n    return (\n        !!struct &&\n        normalizeIotaAddress(struct.package) === normalizeIotaAddress('0x2') &&\n        struct.module === 'tx_context' &&\n        struct.type === 'TxContext'\n    );\n}\n\nexport function getPureBcsSchema(typeSignature: OpenMoveTypeSignatureBody): BcsType<any> | null {\n    if (typeof typeSignature === 'string') {\n        switch (typeSignature) {\n            case 'address':\n                return bcs.Address;\n            case 'bool':\n                return bcs.Bool;\n            case 'u8':\n                return bcs.U8;\n            case 'u16':\n                return bcs.U16;\n            case 'u32':\n                return bcs.U32;\n            case 'u64':\n                return bcs.U64;\n            case 'u128':\n                return bcs.U128;\n            case 'u256':\n                return bcs.U256;\n            default:\n                throw new Error(`Unknown type signature ${typeSignature}`);\n        }\n    }\n\n    if ('vector' in typeSignature) {\n        if (typeSignature.vector === 'u8') {\n            return bcs.vector(bcs.U8).transform({\n                input: (val: string | Uint8Array) =>\n                    typeof val === 'string' ? new TextEncoder().encode(val) : val,\n                output: (val) => val,\n            });\n        }\n        const type = getPureBcsSchema(typeSignature.vector);\n        return type ? bcs.vector(type) : null;\n    }\n\n    if ('datatype' in typeSignature) {\n        const pkg = normalizeIotaAddress(typeSignature.datatype.package);\n\n        if (pkg === normalizeIotaAddress(MOVE_STDLIB_ADDRESS)) {\n            if (\n                typeSignature.datatype.module === STD_ASCII_MODULE_NAME &&\n                typeSignature.datatype.type === STD_ASCII_STRUCT_NAME\n            ) {\n                return bcs.String;\n            }\n\n            if (\n                typeSignature.datatype.module === STD_UTF8_MODULE_NAME &&\n                typeSignature.datatype.type === STD_UTF8_STRUCT_NAME\n            ) {\n                return bcs.String;\n            }\n\n            if (\n                typeSignature.datatype.module === STD_OPTION_MODULE_NAME &&\n                typeSignature.datatype.type === STD_OPTION_STRUCT_NAME\n            ) {\n                const type = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);\n                return type ? bcs.vector(type) : null;\n            }\n        }\n\n        if (\n            pkg === normalizeIotaAddress(IOTA_FRAMEWORK_ADDRESS) &&\n            typeSignature.datatype.module === OBJECT_MODULE_NAME &&\n            typeSignature.datatype.type === ID_STRUCT_NAME\n        ) {\n            return bcs.Address;\n        }\n    }\n\n    return null;\n}\n\nexport function normalizedTypeToMoveTypeSignature(\n    type: IotaMoveNormalizedType,\n): OpenMoveTypeSignature {\n    if (typeof type === 'object' && 'Reference' in type) {\n        return {\n            ref: '&',\n            body: normalizedTypeToMoveTypeSignatureBody(type.Reference),\n        };\n    }\n    if (typeof type === 'object' && 'MutableReference' in type) {\n        return {\n            ref: '&mut',\n            body: normalizedTypeToMoveTypeSignatureBody(type.MutableReference),\n        };\n    }\n\n    return {\n        ref: null,\n        body: normalizedTypeToMoveTypeSignatureBody(type),\n    };\n}\n\nfunction normalizedTypeToMoveTypeSignatureBody(\n    type: IotaMoveNormalizedType,\n): OpenMoveTypeSignatureBody {\n    if (typeof type === 'string') {\n        switch (type) {\n            case 'Address':\n                return 'address';\n            case 'Bool':\n                return 'bool';\n            case 'U8':\n                return 'u8';\n            case 'U16':\n                return 'u16';\n            case 'U32':\n                return 'u32';\n            case 'U64':\n                return 'u64';\n            case 'U128':\n                return 'u128';\n            case 'U256':\n                return 'u256';\n            default:\n                throw new Error(`Unexpected type ${type}`);\n        }\n    }\n\n    if ('Vector' in type) {\n        return { vector: normalizedTypeToMoveTypeSignatureBody(type.Vector) };\n    }\n\n    if ('Struct' in type) {\n        return {\n            datatype: {\n                package: type.Struct.address,\n                module: type.Struct.module,\n                type: type.Struct.name,\n                typeParameters: type.Struct.typeArguments.map(\n                    normalizedTypeToMoveTypeSignatureBody,\n                ),\n            },\n        };\n    }\n\n    if ('TypeParameter' in type) {\n        return { typeParameter: type.TypeParameter };\n    }\n\n    throw new Error(`Unexpected type ${JSON.stringify(type)}`);\n}\n\nexport function pureBcsSchemaFromOpenMoveTypeSignatureBody(\n    typeSignature: OpenMoveTypeSignatureBody,\n): BcsType<any> {\n    if (typeof typeSignature === 'string') {\n        switch (typeSignature) {\n            case 'address':\n                return bcs.Address;\n            case 'bool':\n                return bcs.Bool;\n            case 'u8':\n                return bcs.U8;\n            case 'u16':\n                return bcs.U16;\n            case 'u32':\n                return bcs.U32;\n            case 'u64':\n                return bcs.U64;\n            case 'u128':\n                return bcs.U128;\n            case 'u256':\n                return bcs.U256;\n            default:\n                throw new Error(`Unknown type signature ${typeSignature}`);\n        }\n    }\n\n    if ('vector' in typeSignature) {\n        return bcs.vector(pureBcsSchemaFromOpenMoveTypeSignatureBody(typeSignature.vector));\n    }\n\n    throw new Error(`Expected pure typeSignature, but got ${JSON.stringify(typeSignature)}`);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3135, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/transactions/json-rpc-resolver.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parse } from 'valibot';\n\nimport type { BcsType } from '../bcs/index.js';\nimport { bcs } from '../bcs/index.js';\nimport type { IotaClient } from '../client/client.js';\nimport { normalizeIotaAddress, normalizeIotaObjectId, IOTA_TYPE_ARG } from '../utils/index.js';\nimport { ObjectRef } from './data/internal.js';\nimport type { Argument, CallArg, Command, OpenMoveTypeSignature } from './data/internal.js';\nimport { Inputs } from './Inputs.js';\nimport { getPureBcsSchema, isTxContext, normalizedTypeToMoveTypeSignature } from './serializer.js';\nimport type { TransactionDataBuilder } from './TransactionData.js';\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_GAS = 50_000_000_000;\n\nexport interface BuildTransactionOptions {\n    client?: IotaClient;\n    onlyTransactionKind?: boolean;\n    maxSizeBytes?: number;\n}\n\nexport interface SerializeTransactionOptions extends BuildTransactionOptions {\n    supportedIntents?: string[];\n}\n\nexport type TransactionPlugin = (\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n    next: () => Promise<void>,\n) => Promise<void>;\n\nexport async function resolveTransactionData(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n    next: () => Promise<void>,\n) {\n    await normalizeInputs(transactionData, options);\n    await resolveObjectReferences(transactionData, options);\n\n    if (!options.onlyTransactionKind) {\n        await setGasPrice(transactionData, options);\n        await setGasBudget(transactionData, options);\n        await setGasPayment(transactionData, options);\n    }\n    await validate(transactionData);\n    return await next();\n}\n\nasync function setGasPrice(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    if (!transactionData.gasConfig.price) {\n        transactionData.gasConfig.price = String(await getClient(options).getReferenceGasPrice());\n    }\n}\n\nasync function setGasBudget(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    if (transactionData.gasConfig.budget) {\n        return;\n    }\n\n    const dryRunResult = await getClient(options).dryRunTransactionBlock({\n        transactionBlock: transactionData.build({\n            overrides: {\n                gasData: {\n                    budget: String(MAX_GAS),\n                    payment: [],\n                },\n            },\n        }),\n    });\n\n    if (dryRunResult.effects.status.status !== 'success') {\n        throw new Error(\n            `Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n            { cause: dryRunResult },\n        );\n    }\n\n    const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);\n\n    const baseComputationCostWithOverhead =\n        BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n    const gasBudget =\n        baseComputationCostWithOverhead +\n        BigInt(dryRunResult.effects.gasUsed.storageCost) -\n        BigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n    transactionData.gasConfig.budget = String(\n        gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n    );\n}\n\n// The current default is just picking _all_ coins we can which may not be ideal.\nasync function setGasPayment(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    if (!transactionData.gasConfig.payment) {\n        const coins = await getClient(options).getCoins({\n            owner: transactionData.gasConfig.owner || transactionData.sender!,\n            coinType: IOTA_TYPE_ARG,\n        });\n\n        const paymentCoins = coins.data\n            // Filter out coins that are also used as input:\n            .filter((coin) => {\n                const matchingInput = transactionData.inputs.find((input) => {\n                    if (input.Object?.ImmOrOwnedObject) {\n                        return coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;\n                    }\n\n                    return false;\n                });\n\n                return !matchingInput;\n            })\n            .map((coin) => ({\n                objectId: coin.coinObjectId,\n                digest: coin.digest,\n                version: coin.version,\n            }));\n\n        if (!paymentCoins.length) {\n            throw new Error('No valid gas coins found for the transaction.');\n        }\n\n        transactionData.gasConfig.payment = paymentCoins.map((payment) =>\n            parse(ObjectRef, payment),\n        );\n    }\n}\n\nasync function resolveObjectReferences(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    // Keep track of the object references that will need to be resolved at the end of the transaction.\n    // We keep the input by-reference to avoid needing to re-resolve it:\n    const objectsToResolve = transactionData.inputs.filter((input) => {\n        return (\n            input.UnresolvedObject &&\n            !(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion)\n        );\n    }) as Extract<CallArg, { UnresolvedObject: unknown }>[];\n\n    const dedupedIds = [\n        ...new Set(\n            objectsToResolve.map((input) => normalizeIotaObjectId(input.UnresolvedObject.objectId)),\n        ),\n    ];\n\n    const objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];\n\n    const resolvedObjects = new Map();\n    const erroredObjects = new Map();\n\n    await Promise.all(\n        objectChunks.map(async (chunk) => {\n            const chunkObjects = await getClient(options).multiGetObjects({\n                ids: chunk,\n                options: { showOwner: true },\n            });\n\n            for (const object of chunkObjects) {\n                const objectId = object.data?.objectId;\n                if (objectId) {\n                    if (object.error || !object.data) {\n                        erroredObjects.set(objectId, object.error);\n                        return;\n                    }\n                    const owner = object.data.owner;\n                    const initialSharedVersion =\n                        owner && typeof owner === 'object' && 'Shared' in owner\n                            ? owner.Shared.initial_shared_version\n                            : null;\n\n                    resolvedObjects.set(objectId, {\n                        objectId,\n                        digest: object.data.digest,\n                        version: object.data.version,\n                        initialSharedVersion,\n                    });\n                }\n            }\n        }),\n    );\n\n    if (erroredObjects.size > 0) {\n        throw new Error(\n            `The following input objects are invalid: ${Array.from(erroredObjects).join(', ')}`,\n        );\n    }\n\n    for (const [index, input] of transactionData.inputs.entries()) {\n        if (!input.UnresolvedObject) {\n            continue;\n        }\n\n        let updated: CallArg | undefined;\n        const id = normalizeIotaAddress(input.UnresolvedObject.objectId);\n        const object = resolvedObjects.get(id);\n\n        if (input.UnresolvedObject.initialSharedVersion ?? object?.initialSharedVersion) {\n            updated = Inputs.SharedObjectRef({\n                objectId: id,\n                initialSharedVersion:\n                    input.UnresolvedObject.initialSharedVersion ||\n                    (object?.initialSharedVersion as string),\n                mutable: isUsedAsMutable(transactionData, index),\n            });\n        } else if (isUsedAsReceiving(transactionData, index)) {\n            updated = Inputs.ReceivingRef(\n                {\n                    objectId: id,\n                    digest: input.UnresolvedObject.digest ?? (object?.digest as string),\n                    version: input.UnresolvedObject.version ?? (object?.version as string),\n                }!,\n            );\n        }\n\n        transactionData.inputs[transactionData.inputs.indexOf(input)] =\n            updated ??\n            Inputs.ObjectRef({\n                objectId: id,\n                digest: input.UnresolvedObject.digest ?? (object?.digest as string),\n                version: input.UnresolvedObject.version ?? (object?.version as string),\n            });\n    }\n}\n\nasync function normalizeInputs(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    const { inputs, commands } = transactionData;\n    const moveCallsToResolve: Extract<Command, { MoveCall: unknown }>['MoveCall'][] = [];\n    const moveFunctionsToResolve = new Set<string>();\n\n    commands.forEach((command) => {\n        // Special case move call:\n        if (command.MoveCall) {\n            // Determine if any of the arguments require encoding.\n            // - If they don't, then this is good to go.\n            // - If they do, then we need to fetch the normalized move module.\n\n            // If we already know the argument types, we don't need to resolve them again\n            if (command.MoveCall._argumentTypes) {\n                return;\n            }\n\n            const inputs = command.MoveCall.arguments.map((arg) => {\n                if (arg.$kind === 'Input') {\n                    return transactionData.inputs[arg.Input];\n                }\n                return null;\n            });\n            const needsResolution = inputs.some(\n                (input) => input?.UnresolvedPure || input?.UnresolvedObject,\n            );\n\n            if (needsResolution) {\n                const functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;\n                moveFunctionsToResolve.add(functionName);\n                moveCallsToResolve.push(command.MoveCall);\n            }\n        }\n\n        // Special handling for values that where previously encoded using the wellKnownEncoding pattern.\n        // This should only happen when transaction data was hydrated from an old version of the SDK\n        switch (command.$kind) {\n            case 'SplitCoins':\n                command.SplitCoins.amounts.forEach((amount) => {\n                    normalizeRawArgument(amount, bcs.U64, transactionData);\n                });\n                break;\n            case 'TransferObjects':\n                normalizeRawArgument(command.TransferObjects.address, bcs.Address, transactionData);\n                break;\n        }\n    });\n\n    const moveFunctionParameters = new Map<string, OpenMoveTypeSignature[]>();\n    if (moveFunctionsToResolve.size > 0) {\n        const client = getClient(options);\n        await Promise.all(\n            [...moveFunctionsToResolve].map(async (functionName) => {\n                const [packageId, moduleId, functionId] = functionName.split('::');\n                const def = await client.getNormalizedMoveFunction({\n                    package: packageId,\n                    module: moduleId,\n                    function: functionId,\n                });\n\n                moveFunctionParameters.set(\n                    functionName,\n                    def.parameters.map((param) => normalizedTypeToMoveTypeSignature(param)),\n                );\n            }),\n        );\n    }\n\n    if (moveCallsToResolve.length) {\n        await Promise.all(\n            moveCallsToResolve.map(async (moveCall) => {\n                const parameters = moveFunctionParameters.get(\n                    `${moveCall.package}::${moveCall.module}::${moveCall.function}`,\n                );\n\n                if (!parameters) {\n                    return;\n                }\n\n                // Entry functions can have a mutable reference to an instance of the TxContext\n                // struct defined in the TxContext module as the last parameter. The caller of\n                // the function does not need to pass it in as an argument.\n                const hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1)!);\n                const params = hasTxContext\n                    ? parameters.slice(0, parameters.length - 1)\n                    : parameters;\n\n                moveCall._argumentTypes = params;\n            }),\n        );\n    }\n\n    commands.forEach((command) => {\n        if (!command.MoveCall) {\n            return;\n        }\n\n        const moveCall = command.MoveCall;\n        const fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;\n        const params = moveCall._argumentTypes;\n\n        if (!params) {\n            return;\n        }\n\n        if (params.length !== command.MoveCall.arguments.length) {\n            throw new Error(`Incorrect number of arguments for ${fnName}`);\n        }\n\n        params.forEach((param, i) => {\n            const arg = moveCall.arguments[i];\n            if (arg.$kind !== 'Input') return;\n            const input = inputs[arg.Input];\n\n            // Skip if the input is already resolved\n            if (!input.UnresolvedPure && !input.UnresolvedObject) {\n                return;\n            }\n\n            const inputValue =\n                input.UnresolvedPure?.value ?? (input.UnresolvedObject?.objectId as string);\n\n            const inputIndex = inputs.indexOf(input);\n\n            const schema = getPureBcsSchema(param.body);\n            if (schema) {\n                arg.type = 'pure';\n                inputs[inputIndex] = Inputs.Pure(schema.serialize(inputValue));\n                return;\n            }\n\n            if (typeof inputValue !== 'string') {\n                throw new Error(\n                    `Expect the argument to be an object id string, got ${JSON.stringify(\n                        inputValue,\n                        null,\n                        2,\n                    )}`,\n                );\n            }\n\n            arg.type = 'object';\n            const unresolvedObject: typeof input = input.UnresolvedPure\n                ? {\n                      $kind: 'UnresolvedObject',\n                      UnresolvedObject: {\n                          objectId: inputValue,\n                      },\n                  }\n                : input;\n\n            inputs[inputIndex] = unresolvedObject;\n        });\n    });\n}\n\nfunction validate(transactionData: TransactionDataBuilder) {\n    transactionData.inputs.forEach((input, index) => {\n        if (input.$kind !== 'Object' && input.$kind !== 'Pure') {\n            throw new Error(\n                `Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(\n                    input,\n                )}`,\n            );\n        }\n    });\n}\n\nfunction normalizeRawArgument(\n    arg: Argument,\n    schema: BcsType<any>,\n    transactionData: TransactionDataBuilder,\n) {\n    if (arg.$kind !== 'Input') {\n        return;\n    }\n    const input = transactionData.inputs[arg.Input];\n\n    if (input.$kind !== 'UnresolvedPure') {\n        return;\n    }\n\n    transactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));\n}\n\nfunction isUsedAsMutable(transactionData: TransactionDataBuilder, index: number) {\n    let usedAsMutable = false;\n\n    transactionData.getInputUses(index, (arg, tx) => {\n        if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n            const argIndex = tx.MoveCall.arguments.indexOf(arg);\n            usedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== '&' || usedAsMutable;\n        }\n\n        if (tx.$kind === 'MakeMoveVec' || tx.$kind === 'MergeCoins' || tx.$kind === 'SplitCoins') {\n            usedAsMutable = true;\n        }\n    });\n\n    return usedAsMutable;\n}\n\nfunction isUsedAsReceiving(transactionData: TransactionDataBuilder, index: number) {\n    let usedAsReceiving = false;\n\n    transactionData.getInputUses(index, (arg, tx) => {\n        if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n            const argIndex = tx.MoveCall.arguments.indexOf(arg);\n            usedAsReceiving =\n                isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;\n        }\n    });\n\n    return usedAsReceiving;\n}\n\nfunction isReceivingType(type: OpenMoveTypeSignature): boolean {\n    if (typeof type.body !== 'object' || !('datatype' in type.body)) {\n        return false;\n    }\n\n    return (\n        type.body.datatype.package === '0x2' &&\n        type.body.datatype.module === 'transfer' &&\n        type.body.datatype.type === 'Receiving'\n    );\n}\n\nexport function getClient(options: BuildTransactionOptions): IotaClient {\n    if (!options.client) {\n        throw new Error(\n            `No iota client passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n        );\n    }\n\n    return options.client;\n}\n\nfunction chunk<T>(arr: T[], size: number): T[][] {\n    return Array.from({ length: Math.ceil(arr.length / size) }, (_, i) =>\n        arr.slice(i * size, i * size + size),\n    );\n}\n"],"names":["chunk", "inputs"],"mappings":"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"}},
    {"offset": {"line": 3451, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/transactions/object.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Transaction, TransactionObjectInput } from './Transaction.js';\n\nexport function createObjectMethods<T>(makeObject: (value: TransactionObjectInput) => T) {\n    function object(value: TransactionObjectInput) {\n        return makeObject(value);\n    }\n\n    object.system = () => object('0x5');\n    object.clock = () => object('0x6');\n    object.random = () => object('0x8');\n    object.denyList = () => object('0x403');\n    object.option =\n        ({ type, value }: { type: string; value: TransactionObjectInput | null }) =>\n        (tx: Transaction) =>\n            tx.moveCall({\n                typeArguments: [type],\n                target: `0x1::option::${value === null ? 'none' : 'some'}`,\n                arguments: value === null ? [] : [tx.object(value)],\n            });\n\n    return object;\n}\n"],"names":[],"mappings":";;;;AAMO,SAAS,oBAAuB,UAAA,EAAkD;IACrF,SAAS,OAAO,KAAA,EAA+B;QAC3C,OAAO,WAAW,KAAK;IAC3B;IAEA,OAAO,MAAA,GAAS,IAAM,OAAO,KAAK;IAClC,OAAO,KAAA,GAAQ,IAAM,OAAO,KAAK;IACjC,OAAO,MAAA,GAAS,IAAM,OAAO,KAAK;IAClC,OAAO,QAAA,GAAW,IAAM,OAAO,OAAO;IACtC,OAAO,MAAA,GACH,CAAC,EAAE,IAAA,EAAM,KAAA,CAAM,CAAA,GACf,CAAC,KACG,GAAG,QAAA,CAAS;gBACR,eAAe;oBAAC,IAAI;iBAAA;gBACpB,QAAQ,CAAA,aAAA,EAAgB,UAAU,OAAO,SAAS,MAAM,EAAA;gBACxD,WAAW,UAAU,OAAO,CAAC,CAAA,GAAI;oBAAC,GAAG,MAAA,CAAO,KAAK,CAAC;iBAAA;YACtD,CAAC;IAET,OAAO;AACX"}},
    {"offset": {"line": 3480, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/transactions/pure.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isSerializedBcs } from '@iota/bcs';\nimport type { BcsType, SerializedBcs } from '@iota/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport type { Argument } from './data/internal.js';\n\nexport function createPure<T>(makePure: (value: SerializedBcs<any, any> | Uint8Array) => T) {\n    function pure<T extends PureTypeName>(\n        type: T extends PureTypeName ? ValidPureTypeName<T> : T,\n        value: ShapeFromPureTypeName<T>,\n    ): T;\n\n    function pure(\n        /**\n         * The pure value, serialized to BCS. If this is a Uint8Array, then the value\n         * is assumed to be raw bytes, and will be used directly.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        value: SerializedBcs<any, any> | Uint8Array,\n    ): T;\n\n    function pure(\n        typeOrSerializedValue?: PureTypeName | SerializedBcs<any, any> | Uint8Array,\n        value?: unknown,\n    ): T {\n        if (typeof typeOrSerializedValue === 'string') {\n            return makePure(schemaFromName(typeOrSerializedValue).serialize(value as never));\n        }\n\n        if (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {\n            return makePure(typeOrSerializedValue);\n        }\n\n        throw new Error('tx.pure must be called either a bcs type name, or a serialized bcs value');\n    }\n\n    pure.u8 = (value: number) => makePure(bcs.U8.serialize(value));\n    pure.u16 = (value: number) => makePure(bcs.U16.serialize(value));\n    pure.u32 = (value: number) => makePure(bcs.U32.serialize(value));\n    pure.u64 = (value: bigint | number | string) => makePure(bcs.U64.serialize(value));\n    pure.u128 = (value: bigint | number | string) => makePure(bcs.U128.serialize(value));\n    pure.u256 = (value: bigint | number | string) => makePure(bcs.U256.serialize(value));\n    pure.bool = (value: boolean) => makePure(bcs.Bool.serialize(value));\n    pure.string = (value: string) => makePure(bcs.String.serialize(value));\n    pure.address = (value: string) => makePure(bcs.Address.serialize(value));\n    pure.id = pure.address;\n    pure.vector = <Type extends PureTypeName>(\n        type: T extends PureTypeName ? ValidPureTypeName<Type> : Type,\n        value: Iterable<ShapeFromPureTypeName<Type>> & { length: number },\n    ) => {\n        return makePure(bcs.vector(schemaFromName(type as BasePureType)).serialize(value as never));\n    };\n    pure.option = <Type extends PureTypeName>(\n        type: T extends PureTypeName ? ValidPureTypeName<Type> : Type,\n        value: ShapeFromPureTypeName<Type> | null | undefined,\n    ) => {\n        return makePure(bcs.option(schemaFromName(type)).serialize(value as never));\n    };\n\n    return pure;\n}\n\nexport type BasePureType =\n    | 'u8'\n    | 'u16'\n    | 'u32'\n    | 'u64'\n    | 'u128'\n    | 'u256'\n    | 'bool'\n    | 'id'\n    | 'string'\n    | 'address';\n\nexport type PureTypeName = BasePureType | `vector<${string}>` | `option<${string}>`;\nexport type ValidPureTypeName<T extends string> = T extends BasePureType\n    ? PureTypeName\n    : T extends `vector<${infer U}>`\n      ? ValidPureTypeName<U>\n      : T extends `option<${infer U}>`\n        ? ValidPureTypeName<U>\n        : PureTypeValidationError<T>;\n\ntype ShapeFromPureTypeName<T extends PureTypeName> = T extends BasePureType\n    ? Parameters<ReturnType<typeof createPure<Argument>>[T]>[0]\n    : T extends `vector<${infer U extends PureTypeName}>`\n      ? ShapeFromPureTypeName<U>[]\n      : T extends `option<${infer U extends PureTypeName}>`\n        ? ShapeFromPureTypeName<U> | null\n        : never;\n\ntype PureTypeValidationError<T extends string> = T & {\n    error: `Invalid Pure type name: ${T}`;\n};\n\nfunction schemaFromName<T extends PureTypeName>(\n    name: T extends PureTypeName ? ValidPureTypeName<T> : T,\n): BcsType<ShapeFromPureTypeName<T>> {\n    switch (name) {\n        case 'u8':\n            return bcs.u8() as never;\n        case 'u16':\n            return bcs.u16() as never;\n        case 'u32':\n            return bcs.u32() as never;\n        case 'u64':\n            return bcs.u64() as never;\n        case 'u128':\n            return bcs.u128() as never;\n        case 'u256':\n            return bcs.u256() as never;\n        case 'bool':\n            return bcs.bool() as never;\n        case 'string':\n            return bcs.string() as never;\n        case 'id':\n        case 'address':\n            return bcs.Address as never;\n    }\n\n    const generic = name.match(/^(vector|option)<(.+)>$/);\n    if (generic) {\n        const [kind, inner] = generic.slice(1);\n        if (kind === 'vector') {\n            return bcs.vector(schemaFromName(inner as PureTypeName)) as never;\n        } else {\n            return bcs.option(schemaFromName(inner as PureTypeName)) as never;\n        }\n    }\n\n    throw new Error(`Invalid Pure type name: ${name}`);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3555, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/transactions/hash.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { blake2b } from '@noble/hashes/blake2b';\n\n/**\n * Generates a Blake2b hash of typed data as a base64 string.\n *\n * @param typeTag type tag (e.g. TransactionData, SenderSignedData)\n * @param data data to hash\n */\nexport function hashTypedData(typeTag: string, data: Uint8Array): Uint8Array {\n    const typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));\n\n    const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);\n    dataWithTag.set(typeTagBytes);\n    dataWithTag.set(data, typeTagBytes.length);\n\n    return blake2b(dataWithTag, { dkLen: 32 });\n}\n"],"names":[],"mappings":";;;;AAIA,SAAS,eAAe;;AAQjB,SAAS,cAAc,OAAA,EAAiB,IAAA,EAA8B;IACzE,MAAM,eAAe,MAAM,IAAA,CAAK,GAAG,OAAO,CAAA,EAAA,CAAI,EAAE,GAAA,CAAI,CAAC,IAAM,EAAE,UAAA,CAAW,CAAC,CAAC;IAE1E,MAAM,cAAc,IAAI,WAAW,aAAa,MAAA,GAAS,KAAK,MAAM;IACpE,YAAY,GAAA,CAAI,YAAY;IAC5B,YAAY,GAAA,CAAI,MAAM,aAAa,MAAM;IAEzC,WAAO,iKAAA,EAAQ,aAAa;QAAE,OAAO;IAAG,CAAC;AAC7C"}},
    {"offset": {"line": 3576, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/transactions/TransactionData.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase58 } from '@iota/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type {\n    Argument,\n    CallArg,\n    Command,\n    GasData,\n    TransactionExpiration,\n} from './data/internal.js';\nimport { TransactionData } from './data/internal.js';\nimport { transactionDataFromV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV2 } from './data/v2.js';\nimport { hashTypedData } from './hash.js';\n\nfunction prepareIotaAddress(address: string) {\n    return normalizeIotaAddress(address).replace('0x', '');\n}\n\nexport class TransactionDataBuilder implements TransactionData {\n    static fromKindBytes(bytes: Uint8Array) {\n        const kind = bcs.TransactionKind.parse(bytes);\n\n        const programmableTx = kind.ProgrammableTransaction;\n        if (!programmableTx) {\n            throw new Error('Unable to deserialize from bytes.');\n        }\n\n        return TransactionDataBuilder.restore({\n            version: 2,\n            sender: null,\n            expiration: null,\n            gasData: {\n                budget: null,\n                owner: null,\n                payment: null,\n                price: null,\n            },\n            inputs: programmableTx.inputs,\n            commands: programmableTx.commands,\n        });\n    }\n\n    static fromBytes(bytes: Uint8Array) {\n        const rawData = bcs.TransactionData.parse(bytes);\n        const data = rawData?.V1;\n        const programmableTx = data.kind.ProgrammableTransaction;\n\n        if (!data || !programmableTx) {\n            throw new Error('Unable to deserialize from bytes.');\n        }\n\n        return TransactionDataBuilder.restore({\n            version: 2,\n            sender: data.sender,\n            expiration: data.expiration,\n            gasData: data.gasData,\n            inputs: programmableTx.inputs,\n            commands: programmableTx.commands,\n        });\n    }\n\n    static restore(\n        data:\n            | InferInput<typeof SerializedTransactionDataV2>\n            | InferInput<typeof SerializedTransactionDataV1>,\n    ) {\n        if (data.version === 2) {\n            return new TransactionDataBuilder(parse(TransactionData, data));\n        } else {\n            return new TransactionDataBuilder(parse(TransactionData, transactionDataFromV1(data)));\n        }\n    }\n\n    /**\n     * Generate transaction digest.\n     *\n     * @param bytes BCS serialized transaction data\n     * @returns transaction digest.\n     */\n    static getDigestFromBytes(bytes: Uint8Array) {\n        const hash = hashTypedData('TransactionData', bytes);\n        return toBase58(hash);\n    }\n\n    // @deprecated use gasData instead\n    get gasConfig() {\n        return this.gasData;\n    }\n    // @deprecated use gasData instead\n    set gasConfig(value) {\n        this.gasData = value;\n    }\n\n    version = 2 as const;\n    sender: string | null;\n    expiration: TransactionExpiration | null;\n    gasData: GasData;\n    inputs: CallArg[];\n    commands: Command[];\n\n    constructor(clone?: TransactionData) {\n        this.sender = clone?.sender ?? null;\n        this.expiration = clone?.expiration ?? null;\n        this.inputs = clone?.inputs ?? [];\n        this.commands = clone?.commands ?? [];\n        this.gasData = clone?.gasData ?? {\n            budget: null,\n            price: null,\n            owner: null,\n            payment: null,\n        };\n    }\n\n    build({\n        maxSizeBytes = Infinity,\n        overrides,\n        onlyTransactionKind,\n    }: {\n        maxSizeBytes?: number;\n        overrides?: {\n            expiration?: TransactionExpiration;\n            sender?: string;\n            // @deprecated use gasData instead\n            gasConfig?: Partial<GasData>;\n            gasData?: Partial<GasData>;\n        };\n        onlyTransactionKind?: boolean;\n    } = {}) {\n        // TODO validate that inputs and intents are actually resolved\n        const inputs = this.inputs as (typeof bcs.CallArg.$inferInput)[];\n        const commands = this.commands as Extract<\n            Command<Exclude<Argument, { IntentResult: unknown } | { NestedIntentResult: unknown }>>,\n            { Upgrade: unknown }\n        >[];\n\n        const kind = {\n            ProgrammableTransaction: {\n                inputs,\n                commands,\n            },\n        };\n\n        if (onlyTransactionKind) {\n            return bcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();\n        }\n\n        const expiration = overrides?.expiration ?? this.expiration;\n        const sender = overrides?.sender ?? this.sender;\n        const gasData = { ...this.gasData, ...overrides?.gasConfig, ...overrides?.gasData };\n\n        if (!sender) {\n            throw new Error('Missing transaction sender');\n        }\n\n        if (!gasData.budget) {\n            throw new Error('Missing gas budget');\n        }\n\n        if (!gasData.payment) {\n            throw new Error('Missing gas payment');\n        }\n\n        if (!gasData.price) {\n            throw new Error('Missing gas price');\n        }\n\n        const transactionData = {\n            sender: prepareIotaAddress(sender),\n            expiration: expiration ? expiration : { None: true },\n            gasData: {\n                payment: gasData.payment,\n                owner: prepareIotaAddress(this.gasData.owner ?? sender),\n                price: BigInt(gasData.price),\n                budget: BigInt(gasData.budget),\n            },\n            kind: {\n                ProgrammableTransaction: {\n                    inputs,\n                    commands,\n                },\n            },\n        };\n\n        return bcs.TransactionData.serialize(\n            { V1: transactionData },\n            { maxSize: maxSizeBytes },\n        ).toBytes();\n    }\n\n    addInput<T extends 'object' | 'pure'>(type: T, arg: CallArg) {\n        const index = this.inputs.length;\n        this.inputs.push(arg);\n        return { Input: index, type, $kind: 'Input' as const };\n    }\n\n    getInputUses(index: number, fn: (arg: Argument, command: Command) => void) {\n        this.mapArguments((arg, command) => {\n            if (arg.$kind === 'Input' && arg.Input === index) {\n                fn(arg, command);\n            }\n\n            return arg;\n        });\n    }\n\n    mapArguments(fn: (arg: Argument, command: Command) => Argument) {\n        for (const command of this.commands) {\n            switch (command.$kind) {\n                case 'MoveCall':\n                    command.MoveCall.arguments = command.MoveCall.arguments.map((arg) =>\n                        fn(arg, command),\n                    );\n                    break;\n                case 'TransferObjects':\n                    command.TransferObjects.objects = command.TransferObjects.objects.map((arg) =>\n                        fn(arg, command),\n                    );\n                    command.TransferObjects.address = fn(command.TransferObjects.address, command);\n                    break;\n                case 'SplitCoins':\n                    command.SplitCoins.coin = fn(command.SplitCoins.coin, command);\n                    command.SplitCoins.amounts = command.SplitCoins.amounts.map((arg) =>\n                        fn(arg, command),\n                    );\n                    break;\n                case 'MergeCoins':\n                    command.MergeCoins.destination = fn(command.MergeCoins.destination, command);\n                    command.MergeCoins.sources = command.MergeCoins.sources.map((arg) =>\n                        fn(arg, command),\n                    );\n                    break;\n                case 'MakeMoveVec':\n                    command.MakeMoveVec.elements = command.MakeMoveVec.elements.map((arg) =>\n                        fn(arg, command),\n                    );\n                    break;\n                case 'Upgrade':\n                    command.Upgrade.ticket = fn(command.Upgrade.ticket, command);\n                    break;\n                case '$Intent':\n                    const inputs = command.$Intent.inputs;\n                    command.$Intent.inputs = {};\n\n                    for (const [key, value] of Object.entries(inputs)) {\n                        command.$Intent.inputs[key] = Array.isArray(value)\n                            ? value.map((arg) => fn(arg, command))\n                            : fn(value, command);\n                    }\n\n                    break;\n                case 'Publish':\n                    break;\n                default:\n                    throw new Error(\n                        `Unexpected transaction kind: ${(command as { $kind: unknown }).$kind}`,\n                    );\n            }\n        }\n    }\n\n    replaceCommand(index: number, replacement: Command | Command[]) {\n        if (!Array.isArray(replacement)) {\n            this.commands[index] = replacement;\n            return;\n        }\n\n        const sizeDiff = replacement.length - 1;\n        this.commands.splice(index, 1, ...replacement);\n\n        if (sizeDiff !== 0) {\n            this.mapArguments((arg) => {\n                switch (arg.$kind) {\n                    case 'Result':\n                        if (arg.Result > index) {\n                            arg.Result += sizeDiff;\n                        }\n                        break;\n\n                    case 'NestedResult':\n                        if (arg.NestedResult[0] > index) {\n                            arg.NestedResult[0] += sizeDiff;\n                        }\n                        break;\n                }\n                return arg;\n            });\n        }\n    }\n\n    getDigest() {\n        const bytes = this.build({ onlyTransactionKind: false });\n        return TransactionDataBuilder.getDigestFromBytes(bytes);\n    }\n\n    snapshot(): TransactionData {\n        return parse(TransactionData, this);\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3824, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/transactions/utils.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { IotaMoveNormalizedType } from '../client/index.js';\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { CallArg } from './data/internal.js';\n\nexport function extractMutableReference(\n    normalizedType: IotaMoveNormalizedType,\n): IotaMoveNormalizedType | undefined {\n    return typeof normalizedType === 'object' && 'MutableReference' in normalizedType\n        ? normalizedType.MutableReference\n        : undefined;\n}\n\nexport function extractReference(\n    normalizedType: IotaMoveNormalizedType,\n): IotaMoveNormalizedType | undefined {\n    return typeof normalizedType === 'object' && 'Reference' in normalizedType\n        ? normalizedType.Reference\n        : undefined;\n}\n\nexport function extractStructTag(\n    normalizedType: IotaMoveNormalizedType,\n): Extract<IotaMoveNormalizedType, { Struct: unknown }> | undefined {\n    if (typeof normalizedType === 'object' && 'Struct' in normalizedType) {\n        return normalizedType;\n    }\n\n    const ref = extractReference(normalizedType);\n    const mutRef = extractMutableReference(normalizedType);\n\n    if (typeof ref === 'object' && 'Struct' in ref) {\n        return ref;\n    }\n\n    if (typeof mutRef === 'object' && 'Struct' in mutRef) {\n        return mutRef;\n    }\n    return undefined;\n}\n\nexport function getIdFromCallArg(arg: string | CallArg) {\n    if (typeof arg === 'string') {\n        return normalizeIotaAddress(arg);\n    }\n\n    if (arg.Object) {\n        if (arg.Object.ImmOrOwnedObject) {\n            return normalizeIotaAddress(arg.Object.ImmOrOwnedObject.objectId);\n        }\n\n        if (arg.Object.Receiving) {\n            return normalizeIotaAddress(arg.Object.Receiving.objectId);\n        }\n\n        return normalizeIotaAddress(arg.Object.SharedObject.objectId);\n    }\n\n    if (arg.UnresolvedObject) {\n        return normalizeIotaAddress(arg.UnresolvedObject.objectId);\n    }\n\n    return undefined;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAKA,SAAS,4BAA4B;;AAG9B,SAAS,wBACZ,cAAA,EACkC;IAClC,OAAO,OAAO,mBAAmB,YAAY,sBAAsB,iBAC7D,eAAe,gBAAA,GACf,KAAA;AACV;AAEO,SAAS,iBACZ,cAAA,EACkC;IAClC,OAAO,OAAO,mBAAmB,YAAY,eAAe,iBACtD,eAAe,SAAA,GACf,KAAA;AACV;AAEO,SAAS,iBACZ,cAAA,EACgE;IAChE,IAAI,OAAO,mBAAmB,YAAY,YAAY,gBAAgB;QAClE,OAAO;IACX;IAEA,MAAM,MAAM,iBAAiB,cAAc;IAC3C,MAAM,SAAS,wBAAwB,cAAc;IAErD,IAAI,OAAO,QAAQ,YAAY,YAAY,KAAK;QAC5C,OAAO;IACX;IAEA,IAAI,OAAO,WAAW,YAAY,YAAY,QAAQ;QAClD,OAAO;IACX;IACA,OAAO,KAAA;AACX;AAEO,SAAS,iBAAiB,GAAA,EAAuB;IACpD,IAAI,OAAO,QAAQ,UAAU;QACzB,WAAO,kPAAA,EAAqB,GAAG;IACnC;IAEA,IAAI,IAAI,MAAA,EAAQ;QACZ,IAAI,IAAI,MAAA,CAAO,gBAAA,EAAkB;YAC7B,WAAO,kPAAA,EAAqB,IAAI,MAAA,CAAO,gBAAA,CAAiB,QAAQ;QACpE;QAEA,IAAI,IAAI,MAAA,CAAO,SAAA,EAAW;YACtB,WAAO,kPAAA,EAAqB,IAAI,MAAA,CAAO,SAAA,CAAU,QAAQ;QAC7D;QAEA,WAAO,kPAAA,EAAqB,IAAI,MAAA,CAAO,YAAA,CAAa,QAAQ;IAChE;IAEA,IAAI,IAAI,gBAAA,EAAkB;QACtB,WAAO,kPAAA,EAAqB,IAAI,gBAAA,CAAiB,QAAQ;IAC7D;IAEA,OAAO,KAAA;AACX"}},
    {"offset": {"line": 3880, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/transactions/Transaction.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@iota/bcs';\nimport { fromBase64, isSerializedBcs } from '@iota/bcs';\nimport type { InferInput } from 'valibot';\nimport { is, parse } from 'valibot';\n\nimport type { IotaClient } from '../client/index.js';\nimport type { SignatureWithBytes, Signer } from '../cryptography/index.js';\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { TransactionArgument } from './Commands.js';\nimport { Commands } from './Commands.js';\nimport type { CallArg, Command } from './data/internal.js';\nimport { Argument, NormalizedCallArg, ObjectRef, TransactionExpiration } from './data/internal.js';\nimport { serializeV1TransactionData } from './data/v1.js';\nimport { SerializedTransactionDataV2 } from './data/v2.js';\nimport { Inputs } from './Inputs.js';\nimport type {\n    BuildTransactionOptions,\n    SerializeTransactionOptions,\n    TransactionPlugin,\n} from './json-rpc-resolver.js';\nimport { resolveTransactionData } from './json-rpc-resolver.js';\nimport { createObjectMethods } from './object.js';\nimport { createPure } from './pure.js';\nimport { TransactionDataBuilder } from './TransactionData.js';\nimport { getIdFromCallArg } from './utils.js';\n\nexport type TransactionObjectArgument =\n    | Exclude<InferInput<typeof Argument>, { Input: unknown; type?: 'pure' }>\n    | ((\n          tx: Transaction,\n      ) => Exclude<InferInput<typeof Argument>, { Input: unknown; type?: 'pure' }>);\n\nexport type TransactionResult = Extract<Argument, { Result: unknown }> &\n    Extract<Argument, { NestedResult: unknown }>[];\n\nfunction createTransactionResult(index: number) {\n    const baseResult = { $kind: 'Result' as const, Result: index };\n\n    const nestedResults: {\n        $kind: 'NestedResult';\n        NestedResult: [number, number];\n    }[] = [];\n    const nestedResultFor = (\n        resultIndex: number,\n    ): {\n        $kind: 'NestedResult';\n        NestedResult: [number, number];\n    } =>\n        (nestedResults[resultIndex] ??= {\n            $kind: 'NestedResult' as const,\n            NestedResult: [index, resultIndex],\n        });\n\n    return new Proxy(baseResult, {\n        set() {\n            throw new Error(\n                'The transaction result is a proxy, and does not support setting properties directly',\n            );\n        },\n        // TODO: Instead of making this return a concrete argument, we should ideally\n        // make it reference-based (so that this gets resolved at build-time), which\n        // allows re-ordering transactions.\n        get(target, property) {\n            // This allows this transaction argument to be used in the singular form:\n            if (property in target) {\n                return Reflect.get(target, property);\n            }\n\n            // Support destructuring:\n            if (property === Symbol.iterator) {\n                return function* () {\n                    let i = 0;\n                    while (true) {\n                        yield nestedResultFor(i);\n                        i++;\n                    }\n                };\n            }\n\n            if (typeof property === 'symbol') return;\n\n            const resultIndex = parseInt(property, 10);\n            if (Number.isNaN(resultIndex) || resultIndex < 0) return;\n            return nestedResultFor(resultIndex);\n        },\n    }) as TransactionResult;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@iota/transaction') as never;\n\ninterface SignOptions extends BuildTransactionOptions {\n    signer: Signer;\n}\n\nexport function isTransaction(obj: unknown): obj is Transaction {\n    return !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | CallArg | TransactionObjectArgument;\n\ninterface TransactionPluginRegistry {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    buildPlugins: Map<string | Function, TransactionPlugin>;\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    serializationPlugins: Map<string | Function, TransactionPlugin>;\n}\n\nconst modulePluginRegistry: TransactionPluginRegistry = {\n    buildPlugins: new Map(),\n    serializationPlugins: new Map(),\n};\n\nconst TRANSACTION_REGISTRY_KEY = Symbol.for('@iota/transaction/registry');\nfunction getGlobalPluginRegistry() {\n    try {\n        const target = globalThis as {\n            [TRANSACTION_REGISTRY_KEY]?: TransactionPluginRegistry;\n        };\n\n        if (!target[TRANSACTION_REGISTRY_KEY]) {\n            target[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;\n        }\n\n        return target[TRANSACTION_REGISTRY_KEY];\n    } catch (e) {\n        return modulePluginRegistry;\n    }\n}\n\n/**\n * Transaction Builder\n */\nexport class Transaction {\n    #serializationPlugins: TransactionPlugin[];\n    #buildPlugins: TransactionPlugin[];\n    #intentResolvers = new Map<string, TransactionPlugin>();\n\n    /**\n     * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n     * Supports either a byte array, or base64-encoded bytes.\n     */\n    static fromKind(serialized: string | Uint8Array) {\n        const tx = new Transaction();\n\n        tx.#data = TransactionDataBuilder.fromKindBytes(\n            typeof serialized === 'string' ? fromBase64(serialized) : serialized,\n        );\n\n        return tx;\n    }\n\n    /**\n     * Converts from a serialized transaction format to a `Transaction` class.\n     * There are two supported serialized formats:\n     * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n     * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n     */\n    static from(transaction: string | Uint8Array | Transaction) {\n        const newTransaction = new Transaction();\n\n        if (isTransaction(transaction)) {\n            newTransaction.#data = new TransactionDataBuilder(transaction.getData());\n        } else if (typeof transaction !== 'string' || !transaction.startsWith('{')) {\n            newTransaction.#data = TransactionDataBuilder.fromBytes(\n                typeof transaction === 'string' ? fromBase64(transaction) : transaction,\n            );\n        } else {\n            newTransaction.#data = TransactionDataBuilder.restore(JSON.parse(transaction));\n        }\n\n        return newTransaction;\n    }\n\n    /** @deprecated global plugins should be registered with a name */\n    static registerGlobalSerializationPlugin(step: TransactionPlugin): void;\n    static registerGlobalSerializationPlugin(name: string, step: TransactionPlugin): void;\n    static registerGlobalSerializationPlugin(\n        stepOrStep: TransactionPlugin | string,\n        step?: TransactionPlugin,\n    ) {\n        getGlobalPluginRegistry().serializationPlugins.set(\n            stepOrStep,\n            step ?? (stepOrStep as TransactionPlugin),\n        );\n    }\n\n    static unregisterGlobalSerializationPlugin(name: string) {\n        getGlobalPluginRegistry().serializationPlugins.delete(name);\n    }\n\n    /** @deprecated global plugins should be registered with a name */\n    static registerGlobalBuildPlugin(step: TransactionPlugin): void;\n    static registerGlobalBuildPlugin(name: string, step: TransactionPlugin): void;\n    static registerGlobalBuildPlugin(\n        stepOrStep: TransactionPlugin | string,\n        step?: TransactionPlugin,\n    ) {\n        getGlobalPluginRegistry().buildPlugins.set(\n            stepOrStep,\n            step ?? (stepOrStep as TransactionPlugin),\n        );\n    }\n\n    static unregisterGlobalBuildPlugin(name: string) {\n        getGlobalPluginRegistry().buildPlugins.delete(name);\n    }\n\n    addSerializationPlugin(step: TransactionPlugin) {\n        this.#serializationPlugins.push(step);\n    }\n\n    addBuildPlugin(step: TransactionPlugin) {\n        this.#buildPlugins.push(step);\n    }\n\n    addIntentResolver(intent: string, resolver: TransactionPlugin) {\n        if (this.#intentResolvers.has(intent) && this.#intentResolvers.get(intent) !== resolver) {\n            throw new Error(`Intent resolver for ${intent} already exists`);\n        }\n\n        this.#intentResolvers.set(intent, resolver);\n    }\n\n    setSender(sender: string) {\n        this.#data.sender = sender;\n    }\n    /**\n     * Sets the sender only if it has not already been set.\n     * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n     */\n    setSenderIfNotSet(sender: string) {\n        if (!this.#data.sender) {\n            this.#data.sender = sender;\n        }\n    }\n    setExpiration(expiration?: InferInput<typeof TransactionExpiration> | null) {\n        this.#data.expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n    }\n    setGasPrice(price: number | bigint) {\n        this.#data.gasConfig.price = String(price);\n    }\n    setGasBudget(budget: number | bigint) {\n        this.#data.gasConfig.budget = String(budget);\n    }\n\n    setGasBudgetIfNotSet(budget: number | bigint) {\n        if (this.#data.gasData.budget == null) {\n            this.#data.gasConfig.budget = String(budget);\n        }\n    }\n\n    setGasOwner(owner: string) {\n        this.#data.gasConfig.owner = owner;\n    }\n    setGasPayment(payments: ObjectRef[]) {\n        this.#data.gasConfig.payment = payments.map((payment) => parse(ObjectRef, payment));\n    }\n\n    #data: TransactionDataBuilder;\n\n    /** @deprecated Use `getData()` instead. */\n    get blockData() {\n        return serializeV1TransactionData(this.#data.snapshot());\n    }\n\n    /** Get a snapshot of the transaction data, in JSON form: */\n    getData() {\n        return this.#data.snapshot();\n    }\n\n    // Used to brand transaction classes so that they can be identified, even between multiple copies\n    // of the builder.\n    get [TRANSACTION_BRAND]() {\n        return true;\n    }\n\n    // Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n    get pure(): ReturnType<typeof createPure<Argument>> {\n        Object.defineProperty(this, 'pure', {\n            enumerable: false,\n            value: createPure<Argument>((value): Argument => {\n                if (isSerializedBcs(value)) {\n                    return this.#data.addInput('pure', {\n                        $kind: 'Pure',\n                        Pure: {\n                            bytes: value.toBase64(),\n                        },\n                    });\n                }\n\n                // TODO: we can also do some deduplication here\n                return this.#data.addInput(\n                    'pure',\n                    is(NormalizedCallArg, value)\n                        ? parse(NormalizedCallArg, value)\n                        : value instanceof Uint8Array\n                          ? Inputs.Pure(value)\n                          : { $kind: 'UnresolvedPure', UnresolvedPure: { value } },\n                );\n            }),\n        });\n\n        return this.pure;\n    }\n\n    constructor() {\n        const globalPlugins = getGlobalPluginRegistry();\n        this.#data = new TransactionDataBuilder();\n        this.#buildPlugins = [...globalPlugins.buildPlugins.values()];\n        this.#serializationPlugins = [...globalPlugins.serializationPlugins.values()];\n    }\n\n    /** Returns an argument for the gas coin, to be used in a transaction. */\n    get gas() {\n        return { $kind: 'GasCoin' as const, GasCoin: true as const };\n    }\n\n    /**\n     * Add a new object input to the transaction.\n     */\n    object = createObjectMethods(\n        (value: TransactionObjectInput): { $kind: 'Input'; Input: number; type?: 'object' } => {\n            if (typeof value === 'function') {\n                return this.object(value(this));\n            }\n\n            if (typeof value === 'object' && is(Argument, value)) {\n                return value as { $kind: 'Input'; Input: number; type?: 'object' };\n            }\n\n            const id = getIdFromCallArg(value);\n\n            const inserted = this.#data.inputs.find((i) => id === getIdFromCallArg(i));\n\n            // Upgrade shared object inputs to mutable if needed:\n            if (\n                inserted?.Object?.SharedObject &&\n                typeof value === 'object' &&\n                value.Object?.SharedObject\n            ) {\n                inserted.Object.SharedObject.mutable =\n                    inserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n            }\n\n            return inserted\n                ? { $kind: 'Input', Input: this.#data.inputs.indexOf(inserted), type: 'object' }\n                : this.#data.addInput(\n                      'object',\n                      typeof value === 'string'\n                          ? {\n                                $kind: 'UnresolvedObject',\n                                UnresolvedObject: { objectId: normalizeIotaAddress(value) },\n                            }\n                          : value,\n                  );\n        },\n    );\n\n    /**\n     * Add a new object input to the transaction using the fully-resolved object reference.\n     * If you only have an object ID, use `builder.object(id)` instead.\n     */\n    objectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n        return this.object(Inputs.ObjectRef(...args));\n    }\n\n    /**\n     * Add a new receiving input to the transaction using the fully-resolved object reference.\n     * If you only have an object ID, use `builder.object(id)` instead.\n     */\n    receivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n        return this.object(Inputs.ReceivingRef(...args));\n    }\n\n    /**\n     * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n     * If you only have an object ID, use `builder.object(id)` instead.\n     */\n    sharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n        return this.object(Inputs.SharedObjectRef(...args));\n    }\n\n    /** Add a transaction to the transaction */\n    add<T = TransactionResult>(command: Command | ((tx: Transaction) => T)): T {\n        if (typeof command === 'function') {\n            return command(this);\n        }\n\n        const index = this.#data.commands.push(command);\n\n        return createTransactionResult(index - 1) as T;\n    }\n\n    #normalizeTransactionArgument(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        arg: TransactionArgument | SerializedBcs<any>,\n    ) {\n        if (isSerializedBcs(arg)) {\n            return this.pure(arg);\n        }\n\n        return this.#resolveArgument(arg as TransactionArgument);\n    }\n\n    #resolveArgument(arg: TransactionArgument): Argument {\n        if (typeof arg === 'function') {\n            return parse(Argument, arg(this));\n        }\n\n        return parse(Argument, arg);\n    }\n\n    // Method shorthands:\n\n    splitCoins(\n        coin: TransactionObjectArgument | string,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        amounts: (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n    ) {\n        return this.add(\n            Commands.SplitCoins(\n                typeof coin === 'string' ? this.object(coin) : this.#resolveArgument(coin),\n                amounts.map((amount) =>\n                    typeof amount === 'number' ||\n                    typeof amount === 'bigint' ||\n                    typeof amount === 'string'\n                        ? this.pure.u64(amount)\n                        : this.#normalizeTransactionArgument(amount),\n                ),\n            ),\n        );\n    }\n    mergeCoins(\n        destination: TransactionObjectArgument | string,\n        sources: (TransactionObjectArgument | string)[],\n    ) {\n        return this.add(\n            Commands.MergeCoins(\n                this.object(destination),\n                sources.map((src) => this.object(src)),\n            ),\n        );\n    }\n    publish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n        return this.add(\n            Commands.Publish({\n                modules,\n                dependencies,\n            }),\n        );\n    }\n    upgrade({\n        modules,\n        dependencies,\n        package: packageId,\n        ticket,\n    }: {\n        modules: number[][] | string[];\n        dependencies: string[];\n        package: string;\n        ticket: TransactionObjectArgument | string;\n    }) {\n        return this.add(\n            Commands.Upgrade({\n                modules,\n                dependencies,\n                package: packageId,\n                ticket: this.object(ticket),\n            }),\n        );\n    }\n    moveCall({\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        arguments: args,\n        ...input\n    }:\n        | {\n              package: string;\n              module: string;\n              function: string;\n              arguments?: (TransactionArgument | SerializedBcs<any>)[];\n              typeArguments?: string[];\n          }\n        | {\n              target: string;\n              arguments?: (TransactionArgument | SerializedBcs<any>)[];\n              typeArguments?: string[];\n          }) {\n        return this.add(\n            Commands.MoveCall({\n                ...input,\n                arguments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n            } as Parameters<typeof Commands.MoveCall>[0]),\n        );\n    }\n    transferObjects(\n        objects: (TransactionObjectArgument | string)[],\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        address: TransactionArgument | SerializedBcs<any> | string,\n    ) {\n        return this.add(\n            Commands.TransferObjects(\n                objects.map((obj) => this.object(obj)),\n                typeof address === 'string'\n                    ? this.pure.address(address)\n                    : this.#normalizeTransactionArgument(address),\n            ),\n        );\n    }\n    makeMoveVec({\n        type,\n        elements,\n    }: {\n        elements: (TransactionObjectArgument | string)[];\n        type?: string;\n    }) {\n        return this.add(\n            Commands.MakeMoveVec({\n                type,\n                elements: elements.map((obj) => this.object(obj)),\n            }),\n        );\n    }\n\n    /**\n     * @deprecated Use toJSON instead.\n     * For synchronous serialization, you can use `getData()`\n     * */\n    serialize() {\n        return JSON.stringify(serializeV1TransactionData(this.#data.snapshot()));\n    }\n\n    async toJSON(options: SerializeTransactionOptions = {}): Promise<string> {\n        await this.prepareForSerialization(options);\n        return JSON.stringify(\n            parse(SerializedTransactionDataV2, this.#data.snapshot()),\n            (_key, value) => (typeof value === 'bigint' ? value.toString() : value),\n            2,\n        );\n    }\n\n    /** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n    async sign(options: SignOptions): Promise<SignatureWithBytes> {\n        const { signer, ...buildOptions } = options;\n        const bytes = await this.build(buildOptions);\n        return signer.signTransaction(bytes);\n    }\n\n    /** Build the transaction to BCS bytes. */\n    async build(options: BuildTransactionOptions = {}): Promise<Uint8Array> {\n        await this.prepareForSerialization(options);\n        await this.#prepareBuild(options);\n        return this.#data.build({\n            maxSizeBytes: options.maxSizeBytes,\n            onlyTransactionKind: options.onlyTransactionKind,\n        });\n    }\n\n    /** Derive transaction digest */\n    async getDigest(\n        options: {\n            client?: IotaClient;\n        } = {},\n    ): Promise<string> {\n        await this.#prepareBuild(options);\n        return this.#data.getDigest();\n    }\n\n    /**\n     * Prepare the transaction by validating the transaction data and resolving all inputs\n     * so that it can be built into bytes.\n     */\n    async #prepareBuild(options: BuildTransactionOptions) {\n        if (!options.onlyTransactionKind && !this.#data.sender) {\n            throw new Error('Missing transaction sender');\n        }\n\n        await this.#runPlugins([...this.#buildPlugins, resolveTransactionData], options);\n    }\n\n    async #runPlugins(plugins: TransactionPlugin[], options: SerializeTransactionOptions) {\n        const createNext = (i: number) => {\n            if (i >= plugins.length) {\n                return () => {};\n            }\n            const plugin = plugins[i];\n\n            return async () => {\n                const next = createNext(i + 1);\n                let calledNext = false;\n                let nextResolved = false;\n\n                await plugin(this.#data, options, async () => {\n                    if (calledNext) {\n                        throw new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n                    }\n\n                    calledNext = true;\n\n                    await next();\n\n                    nextResolved = true;\n                });\n\n                if (!calledNext) {\n                    throw new Error(`next() was not called in TransactionPlugin ${i}`);\n                }\n\n                if (!nextResolved) {\n                    throw new Error(`next() was not awaited in TransactionPlugin ${i}`);\n                }\n            };\n        };\n\n        await createNext(0)();\n    }\n\n    async prepareForSerialization(options: SerializeTransactionOptions) {\n        const intents = new Set<string>();\n        for (const command of this.#data.commands) {\n            if (command.$Intent) {\n                intents.add(command.$Intent.name);\n            }\n        }\n\n        const steps = [...this.#serializationPlugins];\n\n        for (const intent of intents) {\n            if (options.supportedIntents?.includes(intent)) {\n                continue;\n            }\n\n            if (!this.#intentResolvers.has(intent)) {\n                throw new Error(`Missing intent resolver for ${intent}`);\n            }\n\n            steps.push(this.#intentResolvers.get(intent)!);\n        }\n\n        await this.#runPlugins(steps, options);\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4314, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/version.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n// This file is generated by genversion.mjs. Do not edit it directly.\n\nexport const PACKAGE_VERSION = '1.7.0';\nexport const TARGETED_RPC_VERSION = '1.12.0-alpha';\n"],"names":[],"mappings":";;;;;;AAMO,MAAM,kBAAkB;AACxB,MAAM,uBAAuB"}},
    {"offset": {"line": 4328, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/client/errors.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nconst CODE_TO_ERROR_TYPE: Record<number, string> = {\n    '-32700': 'ParseError',\n    '-32701': 'OversizedRequest',\n    '-32702': 'OversizedResponse',\n    '-32600': 'InvalidRequest',\n    '-32601': 'MethodNotFound',\n    '-32602': 'InvalidParams',\n    '-32603': 'InternalError',\n    '-32604': 'ServerBusy',\n    '-32000': 'CallExecutionFailed',\n    '-32001': 'UnknownError',\n    '-32003': 'SubscriptionClosed',\n    '-32004': 'SubscriptionClosedWithError',\n    '-32005': 'BatchesNotSupported',\n    '-32006': 'TooManySubscriptions',\n    '-32050': 'TransientError',\n    '-32002': 'TransactionExecutionClientError',\n};\n\nexport class IotaHTTPTransportError extends Error {}\n\nexport class JsonRpcError extends IotaHTTPTransportError {\n    code: number;\n    type: string;\n\n    constructor(message: string, code: number) {\n        super(message);\n        this.code = code;\n        this.type = CODE_TO_ERROR_TYPE[code] ?? 'ServerError';\n    }\n}\n\nexport class IotaHTTPStatusError extends IotaHTTPTransportError {\n    status: number;\n    statusText: string;\n\n    constructor(message: string, status: number, statusText: string) {\n        super(message);\n        this.status = status;\n        this.statusText = statusText;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;AAIA,MAAM,qBAA6C;IAC/C,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;AACd;AAEO,MAAM,+BAA+B,MAAM;AAAC;AAE5C,MAAM,qBAAqB,uBAAuB;IAIrD,YAAY,OAAA,EAAiB,IAAA,CAAc;QACvC,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,IAAA,GAAO,kBAAA,CAAmB,IAAI,CAAA,IAAK;IAC5C;AACJ;AAEO,MAAM,4BAA4B,uBAAuB;IAI5D,YAAY,OAAA,EAAiB,MAAA,EAAgB,UAAA,CAAoB;QAC7D,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,UAAA,GAAa;IACtB;AACJ"}},
    {"offset": {"line": 4376, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/client/rpc-websocket-client.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { JsonRpcError } from './errors.js';\n\nfunction getWebsocketUrl(httpUrl: string): string {\n    const url = new URL(httpUrl);\n    url.protocol = url.protocol.replace('http', 'ws');\n    return url.toString();\n}\n\ntype JsonRpcMessage =\n    | {\n          id: number;\n          result: never;\n          error: {\n              code: number;\n              message: string;\n          };\n      }\n    | {\n          id: number;\n          result: unknown;\n          error: never;\n      }\n    | {\n          method: string;\n          params: NotificationMessageParams;\n      };\n\ntype NotificationMessageParams = {\n    subscription?: number;\n    result: object;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype SubscriptionRequest<T = any> = {\n    method: string;\n    unsubscribe: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    params: any[];\n    onMessage: (event: T) => void;\n};\n\n/**\n * Configuration options for the websocket connection\n */\nexport type WebsocketClientOptions = {\n    /**\n     * Custom WebSocket class to use. Defaults to the global WebSocket class, if available.\n     */\n    WebSocketConstructor?: typeof WebSocket;\n    /**\n     * Milliseconds before timing out while calling an RPC method\n     */\n    callTimeout?: number;\n    /**\n     * Milliseconds between attempts to connect\n     */\n    reconnectTimeout?: number;\n    /**\n     * Maximum number of times to try connecting before giving up\n     */\n    maxReconnects?: number;\n};\n\nexport const DEFAULT_CLIENT_OPTIONS = {\n    // We fudge the typing because we also check for undefined in the constructor:\n    WebSocketConstructor: (typeof WebSocket !== 'undefined'\n        ? WebSocket\n        : undefined) as typeof WebSocket,\n    callTimeout: 30000,\n    reconnectTimeout: 3000,\n    maxReconnects: 5,\n} satisfies WebsocketClientOptions;\n\nexport class WebsocketClient {\n    endpoint: string;\n    options: Required<WebsocketClientOptions>;\n    #requestId = 0;\n    #disconnects = 0;\n    #webSocket: WebSocket | null = null;\n    #connectionPromise: Promise<WebSocket> | null = null;\n    #subscriptions = new Set<RpcSubscription>();\n    #pendingRequests = new Map<\n        number,\n        {\n            resolve: (result: Extract<JsonRpcMessage, { id: number }>) => void;\n            reject: (reason: unknown) => void;\n            timeout: ReturnType<typeof setTimeout>;\n        }\n    >();\n\n    constructor(endpoint: string, options: WebsocketClientOptions = {}) {\n        this.endpoint = endpoint;\n        this.options = { ...DEFAULT_CLIENT_OPTIONS, ...options };\n\n        if (!this.options.WebSocketConstructor) {\n            throw new Error('Missing WebSocket constructor');\n        }\n\n        if (this.endpoint.startsWith('http')) {\n            this.endpoint = getWebsocketUrl(this.endpoint);\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async makeRequest<T>(method: string, params: any[]): Promise<T> {\n        const webSocket = await this.#setupWebSocket();\n\n        return new Promise<Extract<JsonRpcMessage, { id: number }>>((resolve, reject) => {\n            this.#requestId += 1;\n            this.#pendingRequests.set(this.#requestId, {\n                resolve: resolve,\n                reject,\n                timeout: setTimeout(() => {\n                    this.#pendingRequests.delete(this.#requestId);\n                    reject(new Error(`Request timeout: ${method}`));\n                }, this.options.callTimeout),\n            });\n\n            webSocket.send(JSON.stringify({ jsonrpc: '2.0', id: this.#requestId, method, params }));\n        }).then(({ error, result }) => {\n            if (error) {\n                throw new JsonRpcError(error.message, error.code);\n            }\n\n            return result as T;\n        });\n    }\n\n    #setupWebSocket() {\n        if (this.#connectionPromise) {\n            return this.#connectionPromise;\n        }\n\n        this.#connectionPromise = new Promise<WebSocket>((resolve) => {\n            this.#webSocket?.close();\n            this.#webSocket = new this.options.WebSocketConstructor(this.endpoint);\n\n            this.#webSocket.addEventListener('open', () => {\n                this.#disconnects = 0;\n                resolve(this.#webSocket!);\n            });\n\n            this.#webSocket.addEventListener('close', () => {\n                this.#disconnects++;\n                if (this.#disconnects <= this.options.maxReconnects) {\n                    setTimeout(() => {\n                        this.#reconnect();\n                    }, this.options.reconnectTimeout);\n                }\n            });\n\n            this.#webSocket.addEventListener('message', ({ data }: { data: string }) => {\n                let json: JsonRpcMessage;\n                try {\n                    json = JSON.parse(data) as JsonRpcMessage;\n                } catch (error) {\n                    console.error(\n                        new Error(`Failed to parse RPC message: ${data}`, { cause: error }),\n                    );\n                    return;\n                }\n\n                if ('id' in json && json.id != null && this.#pendingRequests.has(json.id)) {\n                    const { resolve, timeout } = this.#pendingRequests.get(json.id)!;\n\n                    clearTimeout(timeout);\n                    resolve(json);\n                } else if ('params' in json) {\n                    const { params } = json;\n                    this.#subscriptions.forEach((subscription) => {\n                        if (subscription.subscriptionId === params.subscription)\n                            if (params.subscription === subscription.subscriptionId) {\n                                subscription.onMessage(params.result);\n                            }\n                    });\n                }\n            });\n        });\n\n        return this.#connectionPromise;\n    }\n\n    async #reconnect() {\n        this.#webSocket?.close();\n        this.#connectionPromise = null;\n\n        return Promise.allSettled(\n            [...this.#subscriptions].map((subscription) => subscription.subscribe(this)),\n        );\n    }\n\n    async subscribe<T>(input: SubscriptionRequest<T>) {\n        const subscription = new RpcSubscription(input);\n        this.#subscriptions.add(subscription);\n        await subscription.subscribe(this);\n        return () => subscription.unsubscribe(this);\n    }\n}\n\nclass RpcSubscription {\n    subscriptionId: number | null = null;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input: SubscriptionRequest<any>;\n    subscribed = false;\n\n    constructor(input: SubscriptionRequest) {\n        this.input = input;\n    }\n\n    onMessage(message: unknown) {\n        if (this.subscribed) {\n            this.input.onMessage(message);\n        }\n    }\n\n    async unsubscribe(client: WebsocketClient) {\n        const { subscriptionId } = this;\n        this.subscribed = false;\n        if (subscriptionId == null) return false;\n        this.subscriptionId = null;\n\n        return client.makeRequest(this.input.unsubscribe, [subscriptionId]);\n    }\n\n    async subscribe(client: WebsocketClient) {\n        this.subscriptionId = null;\n        this.subscribed = true;\n        const newSubscriptionId = await client.makeRequest<number>(\n            this.input.method,\n            this.input.params,\n        );\n\n        if (this.subscribed) {\n            this.subscriptionId = newSubscriptionId;\n        }\n    }\n}\n"],"names":["resolve"],"mappings":"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"}},
    {"offset": {"line": 4563, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/client/http-transport.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { PACKAGE_VERSION, TARGETED_RPC_VERSION } from '../version.js';\nimport { JsonRpcError, IotaHTTPStatusError } from './errors.js';\nimport type { WebsocketClientOptions } from './rpc-websocket-client.js';\nimport { WebsocketClient } from './rpc-websocket-client.js';\n\n/**\n * An object defining headers to be passed to the RPC server\n */\nexport type HttpHeaders = { [header: string]: string };\n\nexport interface IotaHTTPTransportOptions {\n    fetch?: typeof fetch;\n    WebSocketConstructor?: typeof WebSocket;\n    url: string;\n    rpc?: {\n        headers?: HttpHeaders;\n        url?: string;\n    };\n    websocket?: WebsocketClientOptions & {\n        url?: string;\n    };\n}\n\nexport interface IotaTransportRequestOptions {\n    method: string;\n    params: unknown[];\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\n\nexport interface IotaTransportSubscribeOptions<T> {\n    method: string;\n    unsubscribe: string;\n    params: unknown[];\n    onMessage: (event: T) => void;\n}\n\nexport interface IotaTransport {\n    request<T = unknown>(input: IotaTransportRequestOptions): Promise<T>;\n    subscribe<T = unknown>(\n        input: IotaTransportSubscribeOptions<T>,\n    ): Promise<() => Promise<boolean>>;\n}\n\nexport class IotaHTTPTransport implements IotaTransport {\n    #requestId = 0;\n    #options: IotaHTTPTransportOptions;\n    #websocketClient?: WebsocketClient;\n\n    constructor(options: IotaHTTPTransportOptions) {\n        this.#options = options;\n    }\n\n    fetch(input: RequestInfo, init?: RequestInit): Promise<Response> {\n        const fetchFn = this.#options.fetch ?? fetch;\n\n        if (!fetchFn) {\n            throw new Error(\n                'The current environment does not support fetch, you can provide a fetch implementation in the options for IotaHTTPTransport.',\n            );\n        }\n\n        return fetchFn(input, init);\n    }\n\n    #getWebsocketClient(): WebsocketClient {\n        if (!this.#websocketClient) {\n            const WebSocketConstructor = this.#options.WebSocketConstructor ?? WebSocket;\n            if (!WebSocketConstructor) {\n                throw new Error(\n                    'The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for IotaHTTPTransport.',\n                );\n            }\n\n            this.#websocketClient = new WebsocketClient(\n                this.#options.websocket?.url ?? this.#options.url,\n                {\n                    WebSocketConstructor,\n                    ...this.#options.websocket,\n                },\n            );\n        }\n\n        return this.#websocketClient;\n    }\n\n    async request<T>(input: IotaTransportRequestOptions): Promise<T> {\n        this.#requestId += 1;\n\n        const res = await this.fetch(this.#options.rpc?.url ?? this.#options.url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Client-Sdk-Type': 'typescript',\n                'Client-Sdk-Version': PACKAGE_VERSION,\n                'Client-Target-Api-Version': TARGETED_RPC_VERSION,\n                ...this.#options.rpc?.headers,\n            },\n            body: JSON.stringify({\n                jsonrpc: '2.0',\n                id: this.#requestId,\n                method: input.method,\n                params: input.params,\n            }),\n        });\n\n        if (!res.ok) {\n            throw new IotaHTTPStatusError(\n                `Unexpected status code: ${res.status}`,\n                res.status,\n                res.statusText,\n            );\n        }\n\n        const data = await res.json();\n\n        if ('error' in data && data.error != null) {\n            throw new JsonRpcError(data.error.message, data.error.code);\n        }\n\n        return data.result;\n    }\n\n    async subscribe<T>(input: IotaTransportSubscribeOptions<T>): Promise<() => Promise<boolean>> {\n        const unsubscribe = await this.#getWebsocketClient().subscribe(input);\n\n        return async () => !!(await unsubscribe());\n    }\n}\n"],"names":[],"mappings":";;;;AAIA,SAAS,iBAAiB,4BAA4B;AACtD,SAAS,cAAc,2BAA2B;AAElD,SAAS,uBAAuB;;;;;;;;;AAPhC,IAAA,YAAA,UAAA,kBAAA,8BAAA;;;;AAgDO,MAAM,kBAA2C;IAKpD,YAAY,OAAA,CAAmC;QAL5C,aAAA,IAAA,EAAA;QACH,aAAA,IAAA,EAAA,YAAa;QACb,aAAA,IAAA,EAAA;QACA,aAAA,IAAA,EAAA;QAGI,aAAA,IAAA,EAAK,UAAW;IACpB;IAEA,MAAM,KAAA,EAAoB,IAAA,EAAuC;QAC7D,MAAM,UAAU,aAAA,IAAA,EAAK,UAAS,KAAA,IAAS;QAEvC,IAAI,CAAC,SAAS;YACV,MAAM,IAAI,MACN;QAER;QAEA,OAAO,QAAQ,OAAO,IAAI;IAC9B;IAuBA,MAAM,QAAW,KAAA,EAAgD;QAC7D,aAAA,IAAA,EAAK,YAAL,aAAA,IAAA,EAAK,cAAc;QAEnB,MAAM,MAAM,MAAM,IAAA,CAAK,KAAA,CAAM,aAAA,IAAA,EAAK,UAAS,GAAA,EAAK,OAAO,aAAA,IAAA,EAAK,UAAS,GAAA,EAAK;YACtE,QAAQ;YACR,SAAS;gBACL,gBAAgB;gBAChB,mBAAmB;gBACnB,sBAAsB,8NAAA;gBACtB,6BAA6B,mOAAA;gBAC7B,GAAG,aAAA,IAAA,EAAK,UAAS,GAAA,EAAK,OAAA;YAC1B;YACA,MAAM,KAAK,SAAA,CAAU;gBACjB,SAAS;gBACT,IAAI,aAAA,IAAA,EAAK;gBACT,QAAQ,MAAM,MAAA;gBACd,QAAQ,MAAM,MAAA;YAClB,CAAC;QACL,CAAC;QAED,IAAI,CAAC,IAAI,EAAA,EAAI;YACT,MAAM,IAAI,2OAAA,CACN,CAAA,wBAAA,EAA2B,IAAI,MAAM,EAAA,EACrC,IAAI,MAAA,EACJ,IAAI,UAAA;QAEZ;QAEA,MAAM,OAAO,MAAM,IAAI,IAAA,CAAK;QAE5B,IAAI,WAAW,QAAQ,KAAK,KAAA,IAAS,MAAM;YACvC,MAAM,IAAI,oOAAA,CAAa,KAAK,KAAA,CAAM,OAAA,EAAS,KAAK,KAAA,CAAM,IAAI;QAC9D;QAEA,OAAO,KAAK,MAAA;IAChB;IAEA,MAAM,UAAa,KAAA,EAA0E;QACzF,MAAM,cAAc,MAAM,gBAAA,IAAA,EAAK,8BAAA,uBAAL,IAAA,CAAA,IAAA,EAA2B,SAAA,CAAU,KAAK;QAEpE,OAAO,UAAY,CAAC,CAAE,MAAM,YAAY;IAC5C;AACJ;AAnFI,aAAA,IAAA;AACA,WAAA,IAAA;AACA,mBAAA,IAAA;AAHG,+BAAA,IAAA;AAqBH,wBAAmB,WAAoB;IACnC,IAAI,CAAC,aAAA,IAAA,EAAK,mBAAkB;QACxB,MAAM,uBAAuB,aAAA,IAAA,EAAK,UAAS,oBAAA,IAAwB;QACnE,IAAI,CAAC,sBAAsB;YACvB,MAAM,IAAI,MACN;QAER;QAEA,aAAA,IAAA,EAAK,kBAAmB,IAAI,2PAAA,CACxB,aAAA,IAAA,EAAK,UAAS,SAAA,EAAW,OAAO,aAAA,IAAA,EAAK,UAAS,GAAA,EAC9C;YACI;YACA,GAAG,aAAA,IAAA,EAAK,UAAS,SAAA;QACrB;IAER;IAEA,OAAO,aAAA,IAAA,EAAK;AAChB"}},
    {"offset": {"line": 4652, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/client/client.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\nimport { toBase64 } from '@iota/bcs';\n\nimport type { Signer } from '../cryptography/index.js';\nimport type { Transaction } from '../transactions/index.js';\nimport { isTransaction } from '../transactions/index.js';\nimport {\n    isValidIotaAddress,\n    isValidIotaObjectId,\n    isValidTransactionDigest,\n    normalizeIotaAddress,\n    normalizeIotaObjectId,\n} from '../utils/iota-types.js';\nimport { IotaHTTPTransport } from './http-transport.js';\nimport type { IotaTransport } from './http-transport.js';\nimport type {\n    AddressMetrics,\n    AllEpochsAddressMetrics,\n    Checkpoint,\n    CheckpointPage,\n    CoinBalance,\n    CoinMetadata,\n    CoinSupply,\n    CommitteeInfo,\n    DelegatedStake,\n    DevInspectResults,\n    DevInspectTransactionBlockParams,\n    DryRunTransactionBlockParams,\n    DryRunTransactionBlockResponse,\n    DynamicFieldPage,\n    EpochInfo,\n    EpochMetricsPage,\n    EpochPage,\n    ExecuteTransactionBlockParams,\n    GetAllBalancesParams,\n    GetAllCoinsParams,\n    GetBalanceParams,\n    GetCheckpointParams,\n    GetCheckpointsParams,\n    GetCoinMetadataParams,\n    GetCoinsParams,\n    GetCommitteeInfoParams,\n    GetDynamicFieldObjectParams,\n    GetDynamicFieldsParams,\n    GetMoveFunctionArgTypesParams,\n    GetNormalizedMoveFunctionParams,\n    GetNormalizedMoveModuleParams,\n    GetNormalizedMoveModulesByPackageParams,\n    GetNormalizedMoveStructParams,\n    GetObjectParams,\n    GetOwnedObjectsParams,\n    GetProtocolConfigParams,\n    GetStakesByIdsParams,\n    GetStakesParams,\n    GetTotalSupplyParams,\n    GetTransactionBlockParams,\n    MoveCallMetrics,\n    MultiGetObjectsParams,\n    MultiGetTransactionBlocksParams,\n    NetworkMetrics,\n    ObjectRead,\n    Order,\n    PaginatedCoins,\n    PaginatedEvents,\n    PaginatedObjectsResponse,\n    PaginatedTransactionResponse,\n    ProtocolConfig,\n    QueryEventsParams,\n    QueryTransactionBlocksParams,\n    SubscribeEventParams,\n    SubscribeTransactionParams,\n    IotaEvent,\n    IotaMoveFunctionArgType,\n    IotaMoveNormalizedFunction,\n    IotaMoveNormalizedModule,\n    IotaMoveNormalizedModules,\n    IotaMoveNormalizedStruct,\n    IotaObjectResponse,\n    IotaObjectResponseQuery,\n    IotaSystemStateSummary,\n    IotaTransactionBlockResponse,\n    IotaTransactionBlockResponseQuery,\n    TransactionEffects,\n    TryGetPastObjectParams,\n    Unsubscribe,\n    ValidatorsApy,\n    GetTimelockedStakesParams,\n    DelegatedTimelockedStake,\n    GetTimelockedStakesByIdsParams,\n    IotaSystemStateSummaryV1,\n    LatestIotaSystemStateSummary,\n    ParticipationMetrics,\n    IotaCirculatingSupply,\n    GetDynamicFieldObjectV2Params,\n    IotaNamesLookupParams,\n    IotaNameRecord,\n    IotaNamesReverseLookupParams,\n    IotaNamesFindAllRegistrationNFTsParams,\n    IsTransactionIndexedOnNodeParams,\n    IotaMoveViewCallResults,\n    ViewParams,\n} from './types/index.js';\n\nexport interface PaginationArguments<Cursor> {\n    /** Optional paging cursor */\n    cursor?: Cursor;\n    /** Maximum item returned per page */\n    limit?: number | null;\n}\n\nexport interface OrderArguments {\n    order?: Order | null;\n}\n\n/**\n * Configuration options for the IotaClient\n * You must provide either a `url` or a `transport`\n */\nexport type IotaClientOptions = NetworkOrTransport;\n\ntype NetworkOrTransport =\n    | {\n          url: string;\n          transport?: never;\n      }\n    | {\n          transport: IotaTransport;\n          url?: never;\n      };\n\nconst IOTA_CLIENT_BRAND = Symbol.for('@iota/IotaClient') as never;\n\nexport function isIotaClient(client: unknown): client is IotaClient {\n    return (\n        typeof client === 'object' && client !== null && (client as any)[IOTA_CLIENT_BRAND] === true\n    );\n}\n\nexport class IotaClient {\n    protected transport: IotaTransport;\n\n    get [IOTA_CLIENT_BRAND]() {\n        return true;\n    }\n\n    /**\n     * Establish a connection to an IOTA RPC endpoint\n     *\n     * @param options configuration options for the API Client\n     */\n    constructor(options: IotaClientOptions) {\n        this.transport = options.transport ?? new IotaHTTPTransport({ url: options.url });\n    }\n\n    async getRpcApiVersion(): Promise<string | undefined> {\n        const resp = await this.transport.request<{ info: { version: string } }>({\n            method: 'rpc.discover',\n            params: [],\n        });\n\n        return resp.info.version;\n    }\n\n    /**\n     * Get all Coin<`coin_type`> objects owned by an address.\n     */\n    async getCoins(input: GetCoinsParams): Promise<PaginatedCoins> {\n        if (!input.owner || !isValidIotaAddress(normalizeIotaAddress(input.owner))) {\n            throw new Error('Invalid IOTA address');\n        }\n\n        return await this.transport.request({\n            method: 'iotax_getCoins',\n            params: [input.owner, input.coinType, input.cursor, input.limit],\n        });\n    }\n\n    /**\n     * Get all Coin objects owned by an address.\n     */\n    async getAllCoins(input: GetAllCoinsParams): Promise<PaginatedCoins> {\n        if (!input.owner || !isValidIotaAddress(normalizeIotaAddress(input.owner))) {\n            throw new Error('Invalid IOTA address');\n        }\n\n        return await this.transport.request({\n            method: 'iotax_getAllCoins',\n            params: [input.owner, input.cursor, input.limit],\n        });\n    }\n\n    /**\n     * Get the total coin balance for one coin type, owned by the address owner.\n     */\n    async getBalance(input: GetBalanceParams): Promise<CoinBalance> {\n        if (!input.owner || !isValidIotaAddress(normalizeIotaAddress(input.owner))) {\n            throw new Error('Invalid IOTA address');\n        }\n        return await this.transport.request({\n            method: 'iotax_getBalance',\n            params: [input.owner, input.coinType],\n        });\n    }\n\n    /**\n     * Get the total coin balance for all coin types, owned by the address owner.\n     */\n    async getAllBalances(input: GetAllBalancesParams): Promise<CoinBalance[]> {\n        if (!input.owner || !isValidIotaAddress(normalizeIotaAddress(input.owner))) {\n            throw new Error('Invalid IOTA address');\n        }\n        return await this.transport.request({\n            method: 'iotax_getAllBalances',\n            params: [input.owner],\n        });\n    }\n\n    /**\n     * Fetch CoinMetadata for a given coin type\n     */\n    async getCoinMetadata(input: GetCoinMetadataParams): Promise<CoinMetadata | null> {\n        return await this.transport.request({\n            method: 'iotax_getCoinMetadata',\n            params: [input.coinType],\n        });\n    }\n\n    /**\n     *  Fetch total supply for a coin\n     */\n    async getTotalSupply(input: GetTotalSupplyParams): Promise<CoinSupply> {\n        return await this.transport.request({\n            method: 'iotax_getTotalSupply',\n            params: [input.coinType],\n        });\n    }\n\n    /**\n     *  Fetch circulating supply for a coin\n     */\n    async getCirculatingSupply(): Promise<IotaCirculatingSupply> {\n        return await this.transport.request({\n            method: 'iotax_getCirculatingSupply',\n            params: [],\n        });\n    }\n\n    /**\n     * Invoke any RPC method\n     * @param method the method to be invoked\n     * @param args the arguments to be passed to the RPC request\n     */\n    async call<T = unknown>(method: string, params: unknown[]): Promise<T> {\n        return await this.transport.request({ method, params });\n    }\n\n    /**\n     * Get Move function argument types like read, write and full access\n     */\n    async getMoveFunctionArgTypes(\n        input: GetMoveFunctionArgTypesParams,\n    ): Promise<IotaMoveFunctionArgType[]> {\n        return await this.transport.request({\n            method: 'iota_getMoveFunctionArgTypes',\n            params: [input.package, input.module, input.function],\n        });\n    }\n\n    /**\n     * Get a map from module name to\n     * structured representations of Move modules\n     */\n    async getNormalizedMoveModulesByPackage(\n        input: GetNormalizedMoveModulesByPackageParams,\n    ): Promise<IotaMoveNormalizedModules> {\n        return await this.transport.request({\n            method: 'iota_getNormalizedMoveModulesByPackage',\n            params: [input.package],\n        });\n    }\n\n    /**\n     * Get a structured representation of Move module\n     */\n    async getNormalizedMoveModule(\n        input: GetNormalizedMoveModuleParams,\n    ): Promise<IotaMoveNormalizedModule> {\n        return await this.transport.request({\n            method: 'iota_getNormalizedMoveModule',\n            params: [input.package, input.module],\n        });\n    }\n\n    /**\n     * Get a structured representation of Move function\n     */\n    async getNormalizedMoveFunction(\n        input: GetNormalizedMoveFunctionParams,\n    ): Promise<IotaMoveNormalizedFunction> {\n        return await this.transport.request({\n            method: 'iota_getNormalizedMoveFunction',\n            params: [input.package, input.module, input.function],\n        });\n    }\n\n    /**\n     * Get a structured representation of Move struct\n     */\n    async getNormalizedMoveStruct(\n        input: GetNormalizedMoveStructParams,\n    ): Promise<IotaMoveNormalizedStruct> {\n        return await this.transport.request({\n            method: 'iota_getNormalizedMoveStruct',\n            params: [input.package, input.module, input.struct],\n        });\n    }\n\n    /**\n     * Get all objects owned by an address\n     */\n    async getOwnedObjects(input: GetOwnedObjectsParams): Promise<PaginatedObjectsResponse> {\n        if (!input.owner || !isValidIotaAddress(normalizeIotaAddress(input.owner))) {\n            throw new Error('Invalid IOTA address');\n        }\n\n        return await this.transport.request({\n            method: 'iotax_getOwnedObjects',\n            params: [\n                input.owner,\n                {\n                    filter: input.filter,\n                    options: input.options,\n                } as IotaObjectResponseQuery,\n                input.cursor,\n                input.limit,\n            ],\n        });\n    }\n\n    /**\n     * Get details about an object\n     */\n    async getObject(input: GetObjectParams): Promise<IotaObjectResponse> {\n        if (!input.id || !isValidIotaObjectId(normalizeIotaObjectId(input.id))) {\n            throw new Error('Invalid IOTA Object id');\n        }\n        return await this.transport.request({\n            method: 'iota_getObject',\n            params: [input.id, input.options],\n        });\n    }\n\n    async tryGetPastObject(input: TryGetPastObjectParams): Promise<ObjectRead> {\n        return await this.transport.request({\n            method: 'iota_tryGetPastObject',\n            params: [input.id, input.version, input.options],\n        });\n    }\n\n    /**\n     * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail\n     */\n    async multiGetObjects(input: MultiGetObjectsParams): Promise<IotaObjectResponse[]> {\n        input.ids.forEach((id) => {\n            if (!id || !isValidIotaObjectId(normalizeIotaObjectId(id))) {\n                throw new Error(`Invalid IOTA Object id ${id}`);\n            }\n        });\n        const hasDuplicates = input.ids.length !== new Set(input.ids).size;\n        if (hasDuplicates) {\n            throw new Error(`Duplicate object ids in batch call ${input.ids}`);\n        }\n\n        return await this.transport.request({\n            method: 'iota_multiGetObjects',\n            params: [input.ids, input.options],\n        });\n    }\n\n    /**\n     * Get transaction blocks for a given query criteria\n     */\n    async queryTransactionBlocks(\n        input: QueryTransactionBlocksParams,\n    ): Promise<PaginatedTransactionResponse> {\n        return await this.transport.request({\n            method: 'iotax_queryTransactionBlocks',\n            params: [\n                {\n                    filter: input.filter,\n                    options: input.options,\n                } as IotaTransactionBlockResponseQuery,\n                input.cursor,\n                input.limit,\n                (input.order || 'descending') === 'descending',\n            ],\n        });\n    }\n\n    async getTransactionBlock(\n        input: GetTransactionBlockParams,\n    ): Promise<IotaTransactionBlockResponse> {\n        if (!isValidTransactionDigest(input.digest)) {\n            throw new Error('Invalid Transaction digest');\n        }\n        return await this.transport.request({\n            method: 'iota_getTransactionBlock',\n            params: [input.digest, input.options],\n        });\n    }\n\n    async multiGetTransactionBlocks(\n        input: MultiGetTransactionBlocksParams,\n    ): Promise<IotaTransactionBlockResponse[]> {\n        input.digests.forEach((d) => {\n            if (!isValidTransactionDigest(d)) {\n                throw new Error(`Invalid Transaction digest ${d}`);\n            }\n        });\n\n        const hasDuplicates = input.digests.length !== new Set(input.digests).size;\n        if (hasDuplicates) {\n            throw new Error(`Duplicate digests in batch call ${input.digests}`);\n        }\n\n        return await this.transport.request({\n            method: 'iota_multiGetTransactionBlocks',\n            params: [input.digests, input.options],\n        });\n    }\n\n    async executeTransactionBlock({\n        transactionBlock,\n        signature,\n        options,\n    }: ExecuteTransactionBlockParams): Promise<IotaTransactionBlockResponse> {\n        const result: IotaTransactionBlockResponse = await this.transport.request({\n            method: 'iota_executeTransactionBlock',\n            params: [\n                typeof transactionBlock === 'string'\n                    ? transactionBlock\n                    : toBase64(transactionBlock),\n                Array.isArray(signature) ? signature : [signature],\n                options,\n            ],\n        });\n\n        return result;\n    }\n\n    async signAndExecuteTransaction({\n        transaction,\n        signer,\n        ...input\n    }: {\n        transaction: Uint8Array | Transaction;\n        signer: Signer;\n    } & Omit<\n        ExecuteTransactionBlockParams,\n        'transactionBlock' | 'signature'\n    >): Promise<IotaTransactionBlockResponse> {\n        let transactionBytes;\n\n        if (transaction instanceof Uint8Array) {\n            transactionBytes = transaction;\n        } else {\n            transaction.setSenderIfNotSet(signer.toIotaAddress());\n            transactionBytes = await transaction.build({ client: this });\n        }\n\n        const { signature, bytes } = await signer.signTransaction(transactionBytes);\n\n        return this.executeTransactionBlock({\n            transactionBlock: bytes,\n            signature,\n            ...input,\n        });\n    }\n\n    /**\n     * Get total number of transactions\n     */\n\n    async getTotalTransactionBlocks(): Promise<bigint> {\n        const resp = await this.transport.request<string>({\n            method: 'iota_getTotalTransactionBlocks',\n            params: [],\n        });\n        return BigInt(resp);\n    }\n\n    /**\n     * Getting the reference gas price for the network\n     */\n    async getReferenceGasPrice(): Promise<bigint> {\n        const resp = await this.transport.request<string>({\n            method: 'iotax_getReferenceGasPrice',\n            params: [],\n        });\n        return BigInt(resp);\n    }\n\n    /**\n     * Return the delegated stakes for an address\n     */\n    async getStakes(input: GetStakesParams): Promise<DelegatedStake[]> {\n        if (!input.owner || !isValidIotaAddress(normalizeIotaAddress(input.owner))) {\n            throw new Error('Invalid IOTA address');\n        }\n        return await this.transport.request({ method: 'iotax_getStakes', params: [input.owner] });\n    }\n\n    /**\n     * Return the timelocked delegated stakes for an address\n     */\n    async getTimelockedStakes(\n        input: GetTimelockedStakesParams,\n    ): Promise<DelegatedTimelockedStake[]> {\n        if (!input.owner || !isValidIotaAddress(normalizeIotaAddress(input.owner))) {\n            throw new Error('Invalid IOTA address');\n        }\n        return await this.transport.request({\n            method: 'iotax_getTimelockedStakes',\n            params: [input.owner],\n        });\n    }\n\n    /**\n     * Return the delegated stakes queried by id.\n     */\n    async getStakesByIds(input: GetStakesByIdsParams): Promise<DelegatedStake[]> {\n        input.stakedIotaIds.forEach((id) => {\n            if (!id || !isValidIotaObjectId(normalizeIotaObjectId(id))) {\n                throw new Error(`Invalid IOTA Stake id ${id}`);\n            }\n        });\n        return await this.transport.request({\n            method: 'iotax_getStakesByIds',\n            params: [input.stakedIotaIds],\n        });\n    }\n\n    /**\n     * Return the timelocked delegated stakes queried by id.\n     */\n    async getTimelockedStakesByIds(\n        input: GetTimelockedStakesByIdsParams,\n    ): Promise<DelegatedTimelockedStake[]> {\n        input.timelockedStakedIotaIds.forEach((id) => {\n            if (!id || !isValidIotaObjectId(normalizeIotaObjectId(id))) {\n                throw new Error(`Invalid IOTA Timelocked Stake id ${id}`);\n            }\n        });\n        return await this.transport.request({\n            method: 'iotax_getTimelockedStakesByIds',\n            params: [input.timelockedStakedIotaIds],\n        });\n    }\n\n    /**\n     * Return the latest IOTA system state object on networks supporting protocol version `< 5`.\n     * These are networks with node software release version `< 0.11`.\n     * @deprecated Use `getLatestIotaSystemState` instead.\n     */\n    async getLatestIotaSystemStateV1(): Promise<IotaSystemStateSummaryV1> {\n        return await this.transport.request({\n            method: 'iotax_getLatestIotaSystemState',\n            params: [],\n        });\n    }\n\n    /**\n     * Return the latest IOTA system state object on networks supporting protocol version `>= 5`.\n     * These are networks with node software release version `>= 0.11`.\n     *\n     * You probably want to use `getLatestIotaSystemState` instead to prevent issues with future deprecations\n     * or in case the node does not support protocol version `>= 5`.\n     */\n    async getLatestIotaSystemStateV2(): Promise<IotaSystemStateSummary> {\n        return await this.transport.request<IotaSystemStateSummary>({\n            method: 'iotax_getLatestIotaSystemStateV2',\n            params: [],\n        });\n    }\n\n    /**\n     * Return the latest supported IOTA system state object.\n     *\n     * This returns a backwards-compatible system state object that dynamically uses the V1 or V2\n     * depending on the protocol version supported by the node. This method will continue to be supported\n     * as more protocol versions are released with changes to the system state.\n     *\n     * This is quite useful in case your app does not know in advance what node is it going to be using,\n     * this way you as developer dont need to handle each possible system state variant,\n     * this is already handled by this method.\n     */\n    async getLatestIotaSystemState(): Promise<LatestIotaSystemStateSummary> {\n        const protocolConfig = await this.getProtocolConfig();\n        const isV2Supported = Number(protocolConfig.maxSupportedProtocolVersion) >= 5;\n\n        const iotaSystemStateSummary: IotaSystemStateSummary = isV2Supported\n            ? await this.getLatestIotaSystemStateV2()\n            : {\n                  V1: await this.getLatestIotaSystemStateV1(),\n              };\n\n        return 'V2' in iotaSystemStateSummary\n            ? {\n                  ...iotaSystemStateSummary.V2,\n                  committeeMembers: iotaSystemStateSummary.V2.committeeMembers.map(\n                      (committeeMemberIndex) =>\n                          iotaSystemStateSummary.V2.activeValidators[Number(committeeMemberIndex)],\n                  ),\n              }\n            : {\n                  ...iotaSystemStateSummary.V1,\n                  committeeMembers: iotaSystemStateSummary.V1.activeValidators,\n                  safeModeComputationCharges: iotaSystemStateSummary.V1.safeModeComputationRewards,\n                  safeModeComputationChargesBurned:\n                      iotaSystemStateSummary.V1.safeModeComputationRewards,\n              };\n    }\n\n    /**\n     * Get events for a given query criteria\n     */\n    async queryEvents(input: QueryEventsParams): Promise<PaginatedEvents> {\n        return await this.transport.request({\n            method: 'iotax_queryEvents',\n            params: [\n                input.query,\n                input.cursor,\n                input.limit,\n                (input.order || 'descending') === 'descending',\n            ],\n        });\n    }\n\n    /**\n     * Subscribe to get notifications whenever an event matching the filter occurs\n     *\n     * @deprecated\n     */\n    async subscribeEvent(\n        input: SubscribeEventParams & {\n            /** function to run when we receive a notification of a new event matching the filter */\n            onMessage: (event: IotaEvent) => void;\n        },\n    ): Promise<Unsubscribe> {\n        return this.transport.subscribe({\n            method: 'iotax_subscribeEvent',\n            unsubscribe: 'iotax_unsubscribeEvent',\n            params: [input.filter],\n            onMessage: input.onMessage,\n        });\n    }\n\n    /**\n     * @deprecated\n     */\n    async subscribeTransaction(\n        input: SubscribeTransactionParams & {\n            /** function to run when we receive a notification of a new event matching the filter */\n            onMessage: (event: TransactionEffects) => void;\n        },\n    ): Promise<Unsubscribe> {\n        return this.transport.subscribe({\n            method: 'iotax_subscribeTransaction',\n            unsubscribe: 'iotax_unsubscribeTransaction',\n            params: [input.filter],\n            onMessage: input.onMessage,\n        });\n    }\n\n    /**\n     * Runs the transaction block in dev-inspect mode. Which allows for nearly any\n     * transaction (or Move call) with any arguments. Detailed results are\n     * provided, including both the transaction effects and any return values.\n     */\n    async devInspectTransactionBlock(\n        input: DevInspectTransactionBlockParams,\n    ): Promise<DevInspectResults> {\n        let devInspectTxBytes;\n        if (isTransaction(input.transactionBlock)) {\n            input.transactionBlock.setSenderIfNotSet(input.sender);\n            devInspectTxBytes = toBase64(\n                await input.transactionBlock.build({\n                    client: this,\n                    onlyTransactionKind: true,\n                }),\n            );\n        } else if (typeof input.transactionBlock === 'string') {\n            devInspectTxBytes = input.transactionBlock;\n        } else if (input.transactionBlock instanceof Uint8Array) {\n            devInspectTxBytes = toBase64(input.transactionBlock);\n        } else {\n            throw new Error('Unknown transaction block format.');\n        }\n\n        return await this.transport.request({\n            method: 'iota_devInspectTransactionBlock',\n            params: [input.sender, devInspectTxBytes, input.gasPrice?.toString(), input.epoch],\n        });\n    }\n\n    /**\n     * Dry run a transaction block and return the result.\n     */\n    async dryRunTransactionBlock(\n        input: DryRunTransactionBlockParams,\n    ): Promise<DryRunTransactionBlockResponse> {\n        return await this.transport.request({\n            method: 'iota_dryRunTransactionBlock',\n            params: [\n                typeof input.transactionBlock === 'string'\n                    ? input.transactionBlock\n                    : toBase64(input.transactionBlock),\n            ],\n        });\n    }\n\n    /**\n     * Return the list of dynamic field objects owned by an object\n     */\n    async getDynamicFields(input: GetDynamicFieldsParams): Promise<DynamicFieldPage> {\n        if (!input.parentId || !isValidIotaObjectId(normalizeIotaObjectId(input.parentId))) {\n            throw new Error('Invalid IOTA Object id');\n        }\n        return await this.transport.request({\n            method: 'iotax_getDynamicFields',\n            params: [input.parentId, input.cursor, input.limit],\n        });\n    }\n\n    /**\n     * Return the dynamic field object information for a specified object\n     * Uses the V2.\n     */\n    async getDynamicFieldObject(input: GetDynamicFieldObjectV2Params): Promise<IotaObjectResponse> {\n        return await this.transport.request({\n            method: 'iotax_getDynamicFieldObjectV2',\n            params: [input.parentObjectId, input.name, input.options],\n        });\n    }\n\n    /**\n     * Return the dynamic field object information for a specified object\n     * @deprecated `getDynamicFieldObjectV1` is deprecated, prefer to use `getDynamicFieldObject` which uses V2.\n     */\n    async getDynamicFieldObjectV1(input: GetDynamicFieldObjectParams): Promise<IotaObjectResponse> {\n        return await this.transport.request({\n            method: 'iotax_getDynamicFieldObject',\n            params: [input.parentId, input.name],\n        });\n    }\n\n    /**\n     * Return the dynamic field object information for a specified object with content options.\n     */\n    async getDynamicFieldObjectV2(\n        input: GetDynamicFieldObjectV2Params,\n    ): Promise<IotaObjectResponse> {\n        return await this.transport.request({\n            method: 'iotax_getDynamicFieldObjectV2',\n            params: [input.parentObjectId, input.name, input.options],\n        });\n    }\n\n    /**\n     * Get the sequence number of the latest checkpoint that has been executed\n     */\n    async getLatestCheckpointSequenceNumber(): Promise<string> {\n        const resp = await this.transport.request({\n            method: 'iota_getLatestCheckpointSequenceNumber',\n            params: [],\n        });\n        return String(resp);\n    }\n\n    /**\n     * Returns information about a given checkpoint\n     */\n    async getCheckpoint(input: GetCheckpointParams): Promise<Checkpoint> {\n        return await this.transport.request({ method: 'iota_getCheckpoint', params: [input.id] });\n    }\n\n    /**\n     * Returns historical checkpoints paginated\n     */\n    async getCheckpoints(\n        input: PaginationArguments<CheckpointPage['nextCursor']> & GetCheckpointsParams,\n    ): Promise<CheckpointPage> {\n        return await this.transport.request({\n            method: 'iota_getCheckpoints',\n            params: [input.cursor, input?.limit, input.descendingOrder],\n        });\n    }\n\n    /**\n     * Return the committee information for the asked epoch\n     */\n    async getCommitteeInfo(input?: GetCommitteeInfoParams): Promise<CommitteeInfo> {\n        return await this.transport.request({\n            method: 'iotax_getCommitteeInfo',\n            params: [input?.epoch],\n        });\n    }\n\n    async getNetworkMetrics(): Promise<NetworkMetrics> {\n        return await this.transport.request({ method: 'iotax_getNetworkMetrics', params: [] });\n    }\n\n    async getAddressMetrics(): Promise<AddressMetrics> {\n        return await this.transport.request({\n            method: 'iotax_getLatestAddressMetrics',\n            params: [],\n        });\n    }\n\n    async getEpochMetrics(\n        input?: { descendingOrder?: boolean } & PaginationArguments<EpochMetricsPage['nextCursor']>,\n    ): Promise<EpochMetricsPage> {\n        return await this.transport.request({\n            method: 'iotax_getEpochMetrics',\n            params: [input?.cursor, input?.limit, input?.descendingOrder],\n        });\n    }\n\n    async getAllEpochAddressMetrics(input?: {\n        descendingOrder?: boolean;\n    }): Promise<AllEpochsAddressMetrics> {\n        return await this.transport.request({\n            method: 'iotax_getAllEpochAddressMetrics',\n            params: [input?.descendingOrder],\n        });\n    }\n\n    async getCheckpointAddressMetrics(input?: { checkpoint: string }): Promise<AddressMetrics> {\n        return await this.transport.request({\n            method: 'iotax_getCheckpointAddressMetrics',\n            params: [input?.checkpoint],\n        });\n    }\n\n    /**\n     * Return the committee information for the asked epoch\n     */\n    async getEpochs(\n        input?: {\n            descendingOrder?: boolean;\n        } & PaginationArguments<EpochPage['nextCursor']>,\n    ): Promise<EpochPage> {\n        return await this.transport.request({\n            method: 'iotax_getEpochs',\n            params: [input?.cursor, input?.limit, input?.descendingOrder],\n        });\n    }\n\n    /**\n     * Returns list of top move calls by usage\n     */\n    async getMoveCallMetrics(): Promise<MoveCallMetrics> {\n        return await this.transport.request({ method: 'iotax_getMoveCallMetrics', params: [] });\n    }\n\n    /**\n     * Return the committee information for the asked epoch\n     */\n    async getCurrentEpoch(): Promise<EpochInfo> {\n        return await this.transport.request({ method: 'iotax_getCurrentEpoch', params: [] });\n    }\n\n    async getTotalTransactions(): Promise<string> {\n        const resp = await this.transport.request({\n            method: 'iotax_getTotalTransactions',\n            params: [],\n        });\n        return String(resp);\n    }\n\n    /**\n     * Return the Validators APYs\n     */\n    async getValidatorsApy(): Promise<ValidatorsApy> {\n        return await this.transport.request({ method: 'iotax_getValidatorsApy', params: [] });\n    }\n\n    async getChainIdentifier(): Promise<string> {\n        return await this.transport.request({\n            method: 'iota_getChainIdentifier',\n            params: [],\n        });\n    }\n\n    async getProtocolConfig(input?: GetProtocolConfigParams): Promise<ProtocolConfig> {\n        return await this.transport.request({\n            method: 'iota_getProtocolConfig',\n            params: [input?.version],\n        });\n    }\n\n    /**\n     * Returns the participation metrics (total unique addresses with delegated stake in the current epoch).\n     */\n    async getParticipationMetrics(): Promise<ParticipationMetrics> {\n        return await this.transport.request({\n            method: 'iotax_getParticipationMetrics',\n            params: [],\n        });\n    }\n\n    /**\n     * Wait for a transaction block result to be available over the API.\n     * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to\n     * be available via the API.\n     * This currently polls the `getTransactionBlock` API to check for the transaction.\n     */\n    async waitForTransaction({\n        signal,\n        timeout = 60 * 1000,\n        pollInterval = 2 * 1000,\n        waitMode,\n        ...input\n    }: {\n        /** An optional abort signal that can be used to cancel */\n        signal?: AbortSignal;\n        /** The amount of time to wait for a transaction block. Defaults to one minute. */\n        timeout?: number;\n        /** The amount of time to wait between checks for the transaction block. Defaults to 2 seconds. */\n        pollInterval?: number;\n        /** Whether to wait the transaction to have been checkpointed or indexed on the node.\n         * A transaction might be indexed but not checkpointed yet, but a checkpointed transaction is guaranteed to be indexed.\n         */\n        waitMode?: 'checkpoint' | 'indexed-on-node';\n    } & Parameters<IotaClient['getTransactionBlock']>[0]): Promise<IotaTransactionBlockResponse> {\n        const timeoutSignal = AbortSignal.timeout(timeout);\n        const timeoutPromise = new Promise((_, reject) => {\n            timeoutSignal.addEventListener('abort', () => reject(timeoutSignal.reason));\n        });\n\n        timeoutPromise.catch(() => {\n            // Swallow unhandled rejections that might be thrown after early return\n        });\n\n        while (!timeoutSignal.aborted) {\n            signal?.throwIfAborted();\n            const wait = async () => {\n                // Wait for either the next poll interval, or the timeout.\n                await Promise.race([\n                    new Promise((resolve) => setTimeout(resolve, pollInterval)),\n                    timeoutPromise,\n                ]);\n            };\n            try {\n                if (waitMode === 'indexed-on-node') {\n                    const isIndexedOnNode = await this.isTransactionIndexedOnNode({\n                        digest: input.digest,\n                    });\n                    if (isIndexedOnNode) {\n                        return await this.getTransactionBlock(input);\n                    }\n                } else if (waitMode === 'checkpoint') {\n                    const transaction = await this.getTransactionBlock(input);\n                    if (transaction.checkpoint) {\n                        return transaction;\n                    }\n                } else {\n                    return await this.getTransactionBlock(input);\n                }\n                await wait();\n            } catch (e) {\n                await wait();\n            }\n        }\n\n        timeoutSignal.throwIfAborted();\n\n        // This should never happen, because the above case should always throw, but just adding it in the event that something goes horribly wrong.\n        throw new Error('Unexpected error while waiting for transaction block.');\n    }\n\n    /**\n     * Return the resolved record for the given name.\n     */\n    async iotaNamesLookup(input: IotaNamesLookupParams): Promise<IotaNameRecord | undefined> {\n        return await this.transport.request({\n            method: 'iotax_iotaNamesLookup',\n            params: [input.name],\n        });\n    }\n\n    /**\n     * Return the resolved name for the given address.\n     */\n    async iotaNamesReverseLookup(input: IotaNamesReverseLookupParams): Promise<string | undefined> {\n        return await this.transport.request({\n            method: 'iotax_iotaNamesReverseLookup',\n            params: [input.address],\n        });\n    }\n\n    /**\n     * Find all registration NFTs for the given address.\n     */\n    async iotaNamesFindAllRegistrationNFTs(\n        input: IotaNamesFindAllRegistrationNFTsParams,\n    ): Promise<PaginatedObjectsResponse> {\n        return await this.transport.request({\n            method: 'iotax_iotaNamesFindAllRegistrationNFTs',\n            params: [input.address, input.cursor, input.limit, input.options],\n        });\n    }\n\n    /**\n     * Check if a Transaction has been indexed on the Node.\n     */\n    async isTransactionIndexedOnNode(input: IsTransactionIndexedOnNodeParams): Promise<boolean> {\n        return await this.transport.request({\n            method: 'iota_isTransactionIndexedOnNode',\n            params: [input.digest],\n        });\n    }\n\n    /**\n     * Calls a move view function.\n     */\n    async view(input: ViewParams): Promise<IotaMoveViewCallResults> {\n        return await this.transport.request({\n            method: 'iota_view',\n            params: [input.functionName, input.typeArgs, input.callArgs],\n        });\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5484, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/graphql/client.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport type { TadaDocumentNode } from 'gql.tada';\nimport type { DocumentNode } from 'graphql';\nimport { print } from 'graphql';\n\nexport type GraphQLDocument<\n    Result = Record<string, unknown>,\n    Variables = Record<string, unknown>,\n> =\n    | string\n    | DocumentNode\n    | TypedDocumentNode<Result, Variables>\n    | TadaDocumentNode<Result, Variables>;\n\nexport type GraphQLQueryOptions<\n    Result = Record<string, unknown>,\n    Variables = Record<string, unknown>,\n> = {\n    query: GraphQLDocument<Result, Variables>;\n    operationName?: string;\n    extensions?: Record<string, unknown>;\n} & (Variables extends { [key: string]: never }\n    ? { variables?: Variables }\n    : {\n          variables: Variables;\n      });\n\nexport type GraphQLQueryResult<Result = Record<string, unknown>> = {\n    data?: Result;\n    errors?: GraphQLResponseErrors;\n    extensions?: Record<string, unknown>;\n};\n\nexport type GraphQLResponseErrors = Array<{\n    message: string;\n    locations?: { line: number; column: number }[];\n    path?: (string | number)[];\n}>;\n\nexport interface IotaGraphQLClientOptions<Queries extends Record<string, GraphQLDocument>> {\n    url: string;\n    fetch?: typeof fetch;\n    headers?: Record<string, string>;\n    queries?: Queries;\n}\n\nexport class IotaGraphQLRequestError extends Error {}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport class IotaGraphQLClient<Queries extends Record<string, GraphQLDocument> = {}> {\n    #url: string;\n    #queries: Queries;\n    #headers: Record<string, string>;\n    #fetch: typeof fetch;\n\n    constructor({\n        url,\n        fetch: fetchFn = fetch,\n        headers = {},\n        queries = {} as Queries,\n    }: IotaGraphQLClientOptions<Queries>) {\n        this.#url = url;\n        this.#queries = queries;\n        this.#headers = headers;\n        this.#fetch = (...args) => fetchFn(...args);\n    }\n\n    async query<Result = Record<string, unknown>, Variables = Record<string, unknown>>(\n        options: GraphQLQueryOptions<Result, Variables>,\n    ): Promise<GraphQLQueryResult<Result>> {\n        const res = await this.#fetch(this.#url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                ...this.#headers,\n            },\n            body: JSON.stringify({\n                query:\n                    typeof options.query === 'string'\n                        ? String(options.query)\n                        : print(options.query),\n                variables: options.variables,\n                extensions: options.extensions,\n                operationName: options.operationName,\n            }),\n        });\n\n        if (!res.ok) {\n            throw new IotaGraphQLRequestError(\n                `GraphQL request failed: ${res.statusText} (${res.status})`,\n            );\n        }\n\n        return await res.json();\n    }\n\n    async execute<\n        const Query extends Extract<keyof Queries, string>,\n        Result = Queries[Query] extends GraphQLDocument<infer R, unknown>\n            ? R\n            : Record<string, unknown>,\n        Variables = Queries[Query] extends GraphQLDocument<unknown, infer V>\n            ? V\n            : Record<string, unknown>,\n    >(\n        query: Query,\n        options: Omit<GraphQLQueryOptions<Result, Variables>, 'query'>,\n    ): Promise<GraphQLQueryResult<Result>> {\n        return this.query({\n            ...(options as { variables: Record<string, unknown> }),\n            query: this.#queries[query]!,\n        }) as Promise<GraphQLQueryResult<Result>>;\n    }\n}\n"],"names":[],"mappings":";;;;;;AAOA,SAAS,aAAa;;;;;;;;AAPtB,IAAA,MAAA,UAAA,UAAA;;AAkDO,MAAM,gCAAgC,MAAM;AAAC;AAG7C,MAAM,kBAAwE;IAMjF,YAAY,EACR,GAAA,EACA,OAAO,UAAU,KAAA,EACjB,UAAU,CAAC,CAAA,EACX,UAAU,CAAC,CAAA,EACf,CAAsC;QAVtC,aAAA,IAAA,EAAA;QACA,aAAA,IAAA,EAAA;QACA,aAAA,IAAA,EAAA;QACA,aAAA,IAAA,EAAA;QAQI,aAAA,IAAA,EAAK,MAAO;QACZ,aAAA,IAAA,EAAK,UAAW;QAChB,aAAA,IAAA,EAAK,UAAW;QAChB,aAAA,IAAA,EAAK,QAAS,CAAA,GAAI,OAAS,QAAQ,GAAG,IAAI;IAC9C;IAEA,MAAM,MACF,OAAA,EACmC;QACnC,MAAM,MAAM,MAAM,aAAA,IAAA,EAAK,QAAL,IAAA,CAAA,IAAA,EAAY,aAAA,IAAA,EAAK,OAAM;YACrC,QAAQ;YACR,SAAS;gBACL,gBAAgB;gBAChB,GAAG,aAAA,IAAA,EAAK,SAAA;YACZ;YACA,MAAM,KAAK,SAAA,CAAU;gBACjB,OACI,OAAO,QAAQ,KAAA,KAAU,WACnB,OAAO,QAAQ,KAAK,QACpB,2JAAA,EAAM,QAAQ,KAAK;gBAC7B,WAAW,QAAQ,SAAA;gBACnB,YAAY,QAAQ,UAAA;gBACpB,eAAe,QAAQ,aAAA;YAC3B,CAAC;QACL;QAEA,IAAI,CAAC,IAAI,EAAA,EAAI;YACT,MAAM,IAAI,wBACN,CAAA,wBAAA,EAA2B,IAAI,UAAU,CAAA,EAAA,EAAK,IAAI,MAAM,CAAA,CAAA,CAAA;QAEhE;QAEA,OAAO,MAAM,IAAI,IAAA,CAAK;IAC1B;IAEA,MAAM,QASF,KAAA,EACA,OAAA,EACmC;QACnC,OAAO,IAAA,CAAK,KAAA,CAAM;YACd,GAAI,OAAA;YACJ,OAAO,aAAA,IAAA,EAAK,SAAA,CAAS,KAAK,CAAA;QAC9B,CAAC;IACL;AACJ;AA/DI,OAAA,IAAA;AACA,WAAA,IAAA;AACA,WAAA,IAAA;AACA,SAAA,IAAA"}},
    {"offset": {"line": 5549, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/cryptography/intent.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '../bcs/index.js';\n\nexport type IntentScope = Exclude<keyof typeof bcs.IntentScope.$inferType, '$kind'>;\n/**\n * Inserts a domain separator for a message that is being signed\n */\nexport function messageWithIntent(scope: IntentScope, message: Uint8Array) {\n    return bcs\n        .IntentMessage(bcs.fixedArray(message.length, bcs.u8()))\n        .serialize({\n            intent: {\n                scope: { [scope as 'PersonalMessage']: true },\n                version: { V0: true },\n                appId: { Iota: true },\n            },\n            value: message,\n        })\n        .toBytes();\n}\n"],"names":[],"mappings":";;;;AAIA,SAAS,WAAW;;AAMb,SAAS,kBAAkB,KAAA,EAAoB,OAAA,EAAqB;IACvE,OAAO,uOAAA,CACF,aAAA,CAAc,uOAAA,CAAI,UAAA,CAAW,QAAQ,MAAA,EAAQ,uOAAA,CAAI,EAAA,CAAG,CAAC,CAAC,EACtD,SAAA,CAAU;QACP,QAAQ;YACJ,OAAO;gBAAE,CAAC,KAA0B,CAAA,EAAG;YAAK;YAC5C,SAAS;gBAAE,IAAI;YAAK;YACpB,OAAO;gBAAE,MAAM;YAAK;QACxB;QACA,OAAO;IACX,CAAC,EACA,OAAA,CAAQ;AACjB"}},
    {"offset": {"line": 5577, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/cryptography/signature-scheme.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nexport const SIGNATURE_SCHEME_TO_FLAG = {\n    ED25519: 0x00,\n    Secp256k1: 0x01,\n    Secp256r1: 0x02,\n    MultiSig: 0x03,\n    Passkey: 0x06,\n} as const;\n\nexport const SIGNATURE_SCHEME_TO_SIZE = {\n    ED25519: 32,\n    Secp256k1: 33,\n    Secp256r1: 33,\n};\n\nexport const SIGNATURE_FLAG_TO_SCHEME = {\n    0x00: 'ED25519',\n    0x01: 'Secp256k1',\n    0x02: 'Secp256r1',\n    0x03: 'MultiSig',\n    0x06: 'Passkey',\n} as const;\n\nexport type SignatureScheme = 'ED25519' | 'Secp256k1' | 'Secp256r1' | 'MultiSig' | 'Passkey';\n\nexport type SignatureFlag = keyof typeof SIGNATURE_FLAG_TO_SCHEME;\n"],"names":[],"mappings":";;;;;;;;AAIO,MAAM,2BAA2B;IACpC,SAAS;IACT,WAAW;IACX,WAAW;IACX,UAAU;IACV,SAAS;AACb;AAEO,MAAM,2BAA2B;IACpC,SAAS;IACT,WAAW;IACX,WAAW;AACf;AAEO,MAAM,2BAA2B;IACpC,GAAM;IACN,GAAM;IACN,GAAM;IACN,GAAM;IACN,GAAM;AACV"}},
    {"offset": {"line": 5610, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/cryptography/publickey.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@iota/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bytesToHex } from '@noble/hashes/utils';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeIotaAddress, IOTA_ADDRESS_LENGTH } from '../utils/iota-types.js';\nimport type { IntentScope } from './intent.js';\nimport { messageWithIntent } from './intent.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from './signature-scheme.js';\n\n/**\n * Value to be converted into public key.\n */\nexport type PublicKeyInitData = string | Uint8Array | Iterable<number>;\n\nexport function bytesEqual(a: Uint8Array, b: Uint8Array) {\n    if (a === b) return true;\n\n    if (a.length !== b.length) {\n        return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * A public key\n */\nexport abstract class PublicKey {\n    /**\n     * Checks if two public keys are equal\n     */\n    equals(publicKey: PublicKey) {\n        return bytesEqual(this.toRawBytes(), publicKey.toRawBytes());\n    }\n\n    /**\n     * Return the base-64 representation of the public key\n     */\n    toBase64() {\n        return toBase64(this.toRawBytes());\n    }\n\n    toString(): never {\n        throw new Error(\n            '`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead.',\n        );\n    }\n\n    /**\n     * Return the IOTA representation of the public key encoded in\n     * base-64. An IOTA public key is formed by the concatenation\n     * of the scheme flag with the raw bytes of the public key\n     */\n    toIotaPublicKey(): string {\n        const bytes = this.toIotaBytes();\n        return toBase64(bytes);\n    }\n\n    verifyWithIntent(\n        bytes: Uint8Array,\n        signature: Uint8Array | string,\n        intent: IntentScope,\n    ): Promise<boolean> {\n        const intentMessage = messageWithIntent(intent, bytes);\n        const digest = blake2b(intentMessage, { dkLen: 32 });\n\n        return this.verify(digest, signature);\n    }\n\n    /**\n     * Verifies that the signature is valid for the provided PersonalMessage\n     */\n    verifyPersonalMessage(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n        return this.verifyWithIntent(\n            bcs.vector(bcs.u8()).serialize(message).toBytes(),\n            signature,\n            'PersonalMessage',\n        );\n    }\n\n    /**\n     * Verifies that the signature is valid for the provided Transaction\n     */\n    verifyTransaction(transaction: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n        return this.verifyWithIntent(transaction, signature, 'TransactionData');\n    }\n\n    /**\n     * Returns the bytes representation of the public key\n     * prefixed with the signature scheme flag\n     */\n    toIotaBytes(): Uint8Array {\n        const rawBytes = this.toRawBytes();\n        const iotaBytes = new Uint8Array(rawBytes.length + 1);\n        iotaBytes.set([this.flag()]);\n        iotaBytes.set(rawBytes, 1);\n\n        return iotaBytes;\n    }\n\n    /**\n     * Returns the bytes representation of the public key\n     * prefixed with the signature scheme flag. If the\n     * signature scheme is ED25519, no prefix is set.\n     */\n    toIotaBytesForAddress(): Uint8Array {\n        const rawBytes = this.toRawBytes();\n        if (this.flag() === SIGNATURE_SCHEME_TO_FLAG['ED25519']) {\n            return rawBytes;\n        } else {\n            const iotaBytes = new Uint8Array(rawBytes.length + 1);\n            iotaBytes.set([this.flag()]);\n            iotaBytes.set(rawBytes, 1);\n\n            return iotaBytes;\n        }\n    }\n\n    /**\n     * Return the IOTA address associated with this Ed25519 public key\n     */\n    toIotaAddress(): string {\n        // Each hex char represents half a byte, hence hex address doubles the length\n        return normalizeIotaAddress(\n            bytesToHex(blake2b(this.toIotaBytesForAddress(), { dkLen: 32 })).slice(\n                0,\n                IOTA_ADDRESS_LENGTH * 2,\n            ),\n        );\n    }\n\n    /**\n     * Return the byte array representation of the public key\n     */\n    abstract toRawBytes(): Uint8Array;\n\n    /**\n     * Return signature scheme flag of the public key\n     */\n    abstract flag(): number;\n\n    /**\n     * Verifies that the signature is valid for the provided message\n     */\n    abstract verify(data: Uint8Array, signature: Uint8Array | string): Promise<boolean>;\n}\n"],"names":[],"mappings":";;;;;;AAIA,SAAS,gBAAgB;AACzB,SAAS,eAAe;AACxB,SAAS,kBAAkB;AAE3B,SAAS,WAAW;AACpB,SAAS,sBAAsB,2BAA2B;AAE1D,SAAS,yBAAyB;AAClC,SAAS,gCAAgC;;;;;;;;AAOlC,SAAS,WAAW,CAAA,EAAe,CAAA,EAAe;IACrD,IAAI,MAAM,EAAG,CAAA,OAAO;IAEpB,IAAI,EAAE,MAAA,KAAW,EAAE,MAAA,EAAQ;QACvB,OAAO;IACX;IAEA,IAAA,IAAS,IAAI,GAAG,IAAI,EAAE,MAAA,EAAQ,IAAK;QAC/B,IAAI,CAAA,CAAE,CAAC,CAAA,KAAM,CAAA,CAAE,CAAC,CAAA,EAAG;YACf,OAAO;QACX;IACJ;IACA,OAAO;AACX;AAKO,MAAe,UAAU;IAAA;;GAAA,GAI5B,OAAO,SAAA,EAAsB;QACzB,OAAO,WAAW,IAAA,CAAK,UAAA,CAAW,GAAG,UAAU,UAAA,CAAW,CAAC;IAC/D;IAAA;;GAAA,GAKA,WAAW;QACP,WAAO,2MAAA,EAAS,IAAA,CAAK,UAAA,CAAW,CAAC;IACrC;IAEA,WAAkB;QACd,MAAM,IAAI,MACN;IAER;IAAA;;;;GAAA,GAOA,kBAA0B;QACtB,MAAM,QAAQ,IAAA,CAAK,WAAA,CAAY;QAC/B,WAAO,2MAAA,EAAS,KAAK;IACzB;IAEA,iBACI,KAAA,EACA,SAAA,EACA,MAAA,EACgB;QAChB,MAAM,oBAAgB,+OAAA,EAAkB,QAAQ,KAAK;QACrD,MAAM,aAAS,iKAAA,EAAQ,eAAe;YAAE,OAAO;QAAG,CAAC;QAEnD,OAAO,IAAA,CAAK,MAAA,CAAO,QAAQ,SAAS;IACxC;IAAA;;GAAA,GAKA,sBAAsB,OAAA,EAAqB,SAAA,EAAkD;QACzF,OAAO,IAAA,CAAK,gBAAA,CACR,uOAAA,CAAI,MAAA,CAAO,uOAAA,CAAI,EAAA,CAAG,CAAC,EAAE,SAAA,CAAU,OAAO,EAAE,OAAA,CAAQ,GAChD,WACA;IAER;IAAA;;GAAA,GAKA,kBAAkB,WAAA,EAAyB,SAAA,EAAkD;QACzF,OAAO,IAAA,CAAK,gBAAA,CAAiB,aAAa,WAAW,iBAAiB;IAC1E;IAAA;;;GAAA,GAMA,cAA0B;QACtB,MAAM,WAAW,IAAA,CAAK,UAAA,CAAW;QACjC,MAAM,YAAY,IAAI,WAAW,SAAS,MAAA,GAAS,CAAC;QACpD,UAAU,GAAA,CAAI;YAAC,IAAA,CAAK,IAAA,CAAK,CAAC;SAAC;QAC3B,UAAU,GAAA,CAAI,UAAU,CAAC;QAEzB,OAAO;IACX;IAAA;;;;GAAA,GAOA,wBAAoC;QAChC,MAAM,WAAW,IAAA,CAAK,UAAA,CAAW;QACjC,IAAI,IAAA,CAAK,IAAA,CAAK,MAAM,mQAAA,CAAyB,SAAS,CAAA,EAAG;YACrD,OAAO;QACX,OAAO;YACH,MAAM,YAAY,IAAI,WAAW,SAAS,MAAA,GAAS,CAAC;YACpD,UAAU,GAAA,CAAI;gBAAC,IAAA,CAAK,IAAA,CAAK,CAAC;aAAC;YAC3B,UAAU,GAAA,CAAI,UAAU,CAAC;YAEzB,OAAO;QACX;IACJ;IAAA;;GAAA,GAKA,gBAAwB;QAEpB,WAAO,kPAAA,MACH,kKAAA,MAAW,iKAAA,EAAQ,IAAA,CAAK,qBAAA,CAAsB,GAAG;YAAE,OAAO;QAAG,CAAC,CAAC,EAAE,KAAA,CAC7D,GACA,iPAAA,GAAsB;IAGlC;AAgBJ"}},
    {"offset": {"line": 5724, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/keypairs/passkey/publickey.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2025 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64, toB64 } from '@iota/bcs';\nimport { secp256r1 } from '@noble/curves/p256';\nimport { sha256 } from '@noble/hashes/sha256';\n\nimport { PasskeyAuthenticator } from '../../bcs/bcs.js';\nimport { bytesEqual, PublicKey } from '../../cryptography/publickey.js';\nimport type { PublicKeyInitData } from '../../cryptography/publickey.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from '../../cryptography/signature-scheme.js';\n\nexport const PASSKEY_PUBLIC_KEY_SIZE = 33;\nexport const PASSKEY_UNCOMPRESSED_PUBLIC_KEY_SIZE = 65;\nexport const PASSKEY_SIGNATURE_SIZE = 64;\n/** Fixed DER header for secp256r1 SubjectPublicKeyInfo\nDER structure for P-256 SPKI:\n30 -- SEQUENCE\n  59 -- length (89 bytes)\n  30 -- SEQUENCE\n    13 -- length (19 bytes)\n    06 -- OBJECT IDENTIFIER\n      07 -- length\n      2A 86 48 CE 3D 02 01 -- id-ecPublicKey\n    06 -- OBJECT IDENTIFIER\n      08 -- length\n      2A 86 48 CE 3D 03 01 07 -- secp256r1/prime256v1\n  03 -- BIT STRING\n    42 -- length (66 bytes)\n    00 -- padding\n\t===== above bytes are considered header =====\n    04 || x || y -- uncompressed point (65 bytes: 0x04 || 32-byte x || 32-byte y)\n*/\nexport const SECP256R1_SPKI_HEADER = new Uint8Array([\n    0x30,\n    0x59, // SEQUENCE, length 89\n    0x30,\n    0x13, // SEQUENCE, length 19\n    0x06,\n    0x07, // OID, length 7\n    0x2a,\n    0x86,\n    0x48,\n    0xce,\n    0x3d,\n    0x02,\n    0x01, // OID: 1.2.840.10045.2.1 (ecPublicKey)\n    0x06,\n    0x08, // OID, length 8\n    0x2a,\n    0x86,\n    0x48,\n    0xce,\n    0x3d,\n    0x03,\n    0x01,\n    0x07, // OID: 1.2.840.10045.3.1.7 (prime256v1/secp256r1)\n    0x03,\n    0x42, // BIT STRING, length 66\n    0x00, // no unused bits\n] as const);\n\n/**\n * A passkey public key\n */\nexport class PasskeyPublicKey extends PublicKey {\n    static SIZE = PASSKEY_PUBLIC_KEY_SIZE;\n    private data: Uint8Array;\n\n    /**\n     * Create a new PasskeyPublicKey object\n     * @param value passkey public key as buffer or base-64 encoded string\n     */\n    constructor(value: PublicKeyInitData) {\n        super();\n\n        if (typeof value === 'string') {\n            this.data = fromB64(value);\n        } else if (value instanceof Uint8Array) {\n            this.data = value;\n        } else {\n            this.data = Uint8Array.from(value);\n        }\n\n        if (this.data.length !== PASSKEY_PUBLIC_KEY_SIZE) {\n            throw new Error(\n                `Invalid public key input. Expected ${PASSKEY_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`,\n            );\n        }\n    }\n\n    /**\n     * Checks if two passkey public keys are equal\n     */\n    override equals(publicKey: PasskeyPublicKey): boolean {\n        return super.equals(publicKey);\n    }\n\n    /**\n     * Return the byte array representation of the Secp256r1 public key\n     */\n    toRawBytes(): Uint8Array {\n        return this.data;\n    }\n\n    /**\n     * Return the IOTA address associated with this Secp256r1 public key\n     */\n    flag(): number {\n        return SIGNATURE_SCHEME_TO_FLAG['Passkey'];\n    }\n\n    /**\n     * Verifies that the signature is valid for for the provided message\n     */\n    async verify(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n        const parsed = parseSerializedPasskeySignature(signature);\n        const clientDataJSON = JSON.parse(parsed.clientDataJson);\n\n        if (clientDataJSON.type !== 'webauthn.get') {\n            return false;\n        }\n\n        // parse challenge from base64 url\n        const parsedChallenge = fromB64(\n            clientDataJSON.challenge.replace(/-/g, '+').replace(/_/g, '/'),\n        );\n        if (!bytesEqual(message, parsedChallenge)) {\n            return false;\n        }\n\n        const pk = parsed.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE);\n        if (!bytesEqual(this.toRawBytes(), pk)) {\n            return false;\n        }\n\n        const payload = new Uint8Array([\n            ...parsed.authenticatorData,\n            ...sha256(parsed.clientDataJson),\n        ]);\n        const sig = parsed.userSignature.slice(1, PASSKEY_SIGNATURE_SIZE + 1);\n        return secp256r1.verify(sig, sha256(payload), pk);\n    }\n}\n\n/**\n * Parses a DER SubjectPublicKeyInfo into an uncompressed public key. This also verifies\n * that the curve used is P-256 (secp256r1).\n *\n * @param data: DER SubjectPublicKeyInfo\n * @returns uncompressed public key (`0x04 || x || y`)\n */\nexport function parseDerSPKI(derBytes: Uint8Array): Uint8Array {\n    // Verify length and header bytes are expected\n    if (derBytes.length !== SECP256R1_SPKI_HEADER.length + PASSKEY_UNCOMPRESSED_PUBLIC_KEY_SIZE) {\n        throw new Error('Invalid DER length');\n    }\n    for (let i = 0; i < SECP256R1_SPKI_HEADER.length; i++) {\n        if (derBytes[i] !== SECP256R1_SPKI_HEADER[i]) {\n            throw new Error('Invalid spki header');\n        }\n    }\n\n    if (derBytes[SECP256R1_SPKI_HEADER.length] !== 0x04) {\n        throw new Error('Invalid point marker');\n    }\n\n    // Returns the last 65 bytes `04 || x || y`\n    return derBytes.slice(SECP256R1_SPKI_HEADER.length);\n}\n\n/**\n * Parse signature from bytes or base64 string into the following fields.\n */\nexport function parseSerializedPasskeySignature(signature: Uint8Array | string) {\n    const bytes = typeof signature === 'string' ? fromB64(signature) : signature;\n\n    if (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.Passkey) {\n        throw new Error('Invalid signature scheme');\n    }\n    const dec = PasskeyAuthenticator.parse(bytes.slice(1));\n    return {\n        signatureScheme: 'Passkey' as const,\n        serializedSignature: toB64(bytes),\n        signature: bytes,\n        authenticatorData: dec.authenticatorData,\n        clientDataJson: dec.clientDataJson,\n        userSignature: new Uint8Array(dec.userSignature),\n        publicKey: new Uint8Array(dec.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE)),\n    };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5883, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/cryptography/signature.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@iota/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport type { MultiSigStruct } from '../multisig/publickey.js';\nimport type { PublicKey } from './publickey.js';\nimport type { SignatureScheme } from './signature-scheme.js';\nimport {\n    SIGNATURE_FLAG_TO_SCHEME,\n    SIGNATURE_SCHEME_TO_FLAG,\n    SIGNATURE_SCHEME_TO_SIZE,\n} from './signature-scheme.js';\nimport { parseSerializedPasskeySignature } from '../keypairs/passkey/publickey.js';\n\n/**\n * Pair of signature and corresponding public key\n */\nexport type SerializeSignatureInput = {\n    signatureScheme: SignatureScheme;\n    /** Base64-encoded signature */\n    signature: Uint8Array;\n    /** Base64-encoded public key */\n    publicKey?: PublicKey;\n};\n\n/**\n * Takes in a signature, its associated signing scheme and a public key, then serializes this data\n */\nexport function toSerializedSignature({\n    signature,\n    signatureScheme,\n    publicKey,\n}: SerializeSignatureInput): string {\n    if (!publicKey) {\n        throw new Error('`publicKey` is required');\n    }\n\n    const pubKeyBytes = publicKey.toRawBytes();\n    const serializedSignature = new Uint8Array(1 + signature.length + pubKeyBytes.length);\n    serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[signatureScheme]]);\n    serializedSignature.set(signature, 1);\n    serializedSignature.set(pubKeyBytes, 1 + signature.length);\n    return toBase64(serializedSignature);\n}\n\n/**\n * Decodes a serialized signature into its constituent components: the signature scheme, the actual signature, and the public key\n */\nexport function parseSerializedSignature(serializedSignature: string) {\n    const bytes = fromBase64(serializedSignature);\n\n    const signatureScheme =\n        SIGNATURE_FLAG_TO_SCHEME[bytes[0] as keyof typeof SIGNATURE_FLAG_TO_SCHEME];\n\n    switch (signatureScheme) {\n        case 'Passkey':\n            return parseSerializedPasskeySignature(serializedSignature);\n        case 'MultiSig':\n            const multisig: MultiSigStruct = bcs.MultiSig.parse(bytes.slice(1));\n            return {\n                serializedSignature,\n                signatureScheme,\n                multisig,\n                bytes,\n            };\n        case 'ED25519':\n        case 'Secp256k1':\n        case 'Secp256r1':\n            const size =\n                SIGNATURE_SCHEME_TO_SIZE[signatureScheme as keyof typeof SIGNATURE_SCHEME_TO_SIZE];\n            const signature = bytes.slice(1, bytes.length - size);\n            const publicKey = bytes.slice(1 + signature.length);\n\n            return {\n                serializedSignature,\n                signatureScheme,\n                signature,\n                publicKey,\n                bytes,\n            };\n\n        default:\n            throw new Error('Unsupported signature scheme');\n    }\n}\n"],"names":[],"mappings":";;;;;;AAIA,SAAS,YAAY,gBAAgB;AAErC,SAAS,WAAW;AAIpB;AAKA,SAAS,uCAAuC;;;;;AAgBzC,SAAS,sBAAsB,EAClC,SAAA,EACA,eAAA,EACA,SAAA,EACJ,EAAoC;IAChC,IAAI,CAAC,WAAW;QACZ,MAAM,IAAI,MAAM,yBAAyB;IAC7C;IAEA,MAAM,cAAc,UAAU,UAAA,CAAW;IACzC,MAAM,sBAAsB,IAAI,WAAW,IAAI,UAAU,MAAA,GAAS,YAAY,MAAM;IACpF,oBAAoB,GAAA,CAAI;QAAC,mQAAA,CAAyB,eAAe,CAAC;KAAC;IACnE,oBAAoB,GAAA,CAAI,WAAW,CAAC;IACpC,oBAAoB,GAAA,CAAI,aAAa,IAAI,UAAU,MAAM;IACzD,WAAO,2MAAA,EAAS,mBAAmB;AACvC;AAKO,SAAS,yBAAyB,mBAAA,EAA6B;IAClE,MAAM,YAAQ,6MAAA,EAAW,mBAAmB;IAE5C,MAAM,kBACF,mQAAA,CAAyB,KAAA,CAAM,CAAC,CAA0C,CAAA;IAE9E,OAAQ,iBAAiB;QACrB,KAAK;YACD,WAAO,uQAAA,EAAgC,mBAAmB;QAC9D,KAAK;YACD,MAAM,WAA2B,uOAAA,CAAI,QAAA,CAAS,KAAA,CAAM,MAAM,KAAA,CAAM,CAAC,CAAC;YAClE,OAAO;gBACH;gBACA;gBACA;gBACA;YACJ;QACJ,KAAK;QACL,KAAK;QACL,KAAK;YACD,MAAM,OACF,mQAAA,CAAyB,eAAwD,CAAA;YACrF,MAAM,YAAY,MAAM,KAAA,CAAM,GAAG,MAAM,MAAA,GAAS,IAAI;YACpD,MAAM,YAAY,MAAM,KAAA,CAAM,IAAI,UAAU,MAAM;YAElD,OAAO;gBACH;gBACA;gBACA;gBACA;gBACA;YACJ;QAEJ;YACI,MAAM,IAAI,MAAM,8BAA8B;IACtD;AACJ"}},
    {"offset": {"line": 5947, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/cryptography/keypair.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs, toBase64 } from '@iota/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bech32 } from 'bech32';\n\nimport type { IntentScope } from './intent.js';\nimport { messageWithIntent } from './intent.js';\nimport type { PublicKey } from './publickey.js';\nimport { SIGNATURE_FLAG_TO_SCHEME, SIGNATURE_SCHEME_TO_FLAG } from './signature-scheme.js';\nimport type { SignatureScheme } from './signature-scheme.js';\nimport { toSerializedSignature } from './signature.js';\n\nexport const PRIVATE_KEY_SIZE = 32;\nexport const LEGACY_PRIVATE_KEY_SIZE = 64;\nexport const IOTA_PRIVATE_KEY_PREFIX = 'iotaprivkey';\n\nexport type ParsedKeypair = {\n    schema: SignatureScheme;\n    secretKey: Uint8Array;\n};\n\nexport interface SignatureWithBytes {\n    bytes: string;\n    signature: string;\n}\n\n/**\n * TODO: Document\n */\nexport abstract class Signer {\n    abstract sign(bytes: Uint8Array): Promise<Uint8Array>;\n    /**\n     * Sign messages with a specific intent. By combining the message bytes with the intent before hashing and signing,\n     * it ensures that a signed message is tied to a specific purpose and domain separator is provided\n     */\n    async signWithIntent(bytes: Uint8Array, intent: IntentScope): Promise<SignatureWithBytes> {\n        const intentMessage = messageWithIntent(intent, bytes);\n        const digest = blake2b(intentMessage, { dkLen: 32 });\n\n        const signature = toSerializedSignature({\n            signature: await this.sign(digest),\n            signatureScheme: this.getKeyScheme(),\n            publicKey: this.getPublicKey(),\n        });\n\n        return {\n            signature,\n            bytes: toBase64(bytes),\n        };\n    }\n    /**\n     * Signs provided transaction by calling `signWithIntent()` with a `TransactionData` provided as intent scope\n     */\n    async signTransaction(bytes: Uint8Array) {\n        return this.signWithIntent(bytes, 'TransactionData');\n    }\n    /**\n     * Signs provided personal message by calling `signWithIntent()` with a `PersonalMessage` provided as intent scope\n     */\n    async signPersonalMessage(bytes: Uint8Array) {\n        const { signature } = await this.signWithIntent(\n            bcs.vector(bcs.u8()).serialize(bytes).toBytes(),\n            'PersonalMessage',\n        );\n\n        return {\n            bytes: toBase64(bytes),\n            signature,\n        };\n    }\n\n    toIotaAddress(): string {\n        return this.getPublicKey().toIotaAddress();\n    }\n\n    /**\n     * Get the key scheme of the keypair: Secp256k1 or ED25519\n     */\n    abstract getKeyScheme(): SignatureScheme;\n\n    /**\n     * The public key for this keypair\n     */\n    abstract getPublicKey(): PublicKey;\n}\n\nexport abstract class Keypair extends Signer {\n    /**\n     * This returns the Bech32 secret key string for this keypair.\n     */\n    abstract getSecretKey(): string;\n}\n\n/**\n * This returns an ParsedKeypair object based by validating the\n * 33-byte Bech32 encoded string starting with `iotaprivkey`, and\n * parse out the signature scheme and the private key in bytes.\n */\nexport function decodeIotaPrivateKey(value: string): ParsedKeypair {\n    const { prefix, words } = bech32.decode(value);\n    if (prefix !== IOTA_PRIVATE_KEY_PREFIX) {\n        throw new Error('invalid private key prefix');\n    }\n    const extendedSecretKey = new Uint8Array(bech32.fromWords(words));\n    const secretKey = extendedSecretKey.slice(1);\n    const signatureScheme =\n        SIGNATURE_FLAG_TO_SCHEME[extendedSecretKey[0] as keyof typeof SIGNATURE_FLAG_TO_SCHEME];\n    return {\n        schema: signatureScheme,\n        secretKey: secretKey,\n    };\n}\n\n/**\n * This returns a Bech32 encoded string starting with `iotaprivkey`,\n * encoding 33-byte `flag || bytes` for the given the 32-byte private\n * key and its signature scheme.\n */\nexport function encodeIotaPrivateKey(bytes: Uint8Array, scheme: SignatureScheme): string {\n    if (bytes.length !== PRIVATE_KEY_SIZE) {\n        throw new Error('Invalid bytes length');\n    }\n    const flag = SIGNATURE_SCHEME_TO_FLAG[scheme];\n    const privKeyBytes = new Uint8Array(bytes.length + 1);\n    privKeyBytes.set([flag]);\n    privKeyBytes.set(bytes, 1);\n    return bech32.encode(IOTA_PRIVATE_KEY_PREFIX, bech32.toWords(privKeyBytes));\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAIA,SAAS,KAAK,gBAAgB;AAC9B,SAAS,eAAe;AACxB,SAAS,cAAc;AAGvB,SAAS,yBAAyB;AAElC,SAAS,0BAA0B,gCAAgC;AAEnE,SAAS,6BAA6B;;;;;;;AAE/B,MAAM,mBAAmB;AACzB,MAAM,0BAA0B;AAChC,MAAM,0BAA0B;AAehC,MAAe,OAAO;IAAA;;;GAAA,GAMzB,MAAM,eAAe,KAAA,EAAmB,MAAA,EAAkD;QACtF,MAAM,oBAAgB,+OAAA,EAAkB,QAAQ,KAAK;QACrD,MAAM,aAAS,iKAAA,EAAQ,eAAe;YAAE,OAAO;QAAG,CAAC;QAEnD,MAAM,gBAAY,sPAAA,EAAsB;YACpC,WAAW,MAAM,IAAA,CAAK,IAAA,CAAK,MAAM;YACjC,iBAAiB,IAAA,CAAK,YAAA,CAAa;YACnC,WAAW,IAAA,CAAK,YAAA,CAAa;QACjC,CAAC;QAED,OAAO;YACH;YACA,WAAO,2MAAA,EAAS,KAAK;QACzB;IACJ;IAAA;;GAAA,GAIA,MAAM,gBAAgB,KAAA,EAAmB;QACrC,OAAO,IAAA,CAAK,cAAA,CAAe,OAAO,iBAAiB;IACvD;IAAA;;GAAA,GAIA,MAAM,oBAAoB,KAAA,EAAmB;QACzC,MAAM,EAAE,SAAA,CAAU,CAAA,GAAI,MAAM,IAAA,CAAK,cAAA,CAC7B,sMAAA,CAAI,MAAA,CAAO,sMAAA,CAAI,EAAA,CAAG,CAAC,EAAE,SAAA,CAAU,KAAK,EAAE,OAAA,CAAQ,GAC9C;QAGJ,OAAO;YACH,WAAO,2MAAA,EAAS,KAAK;YACrB;QACJ;IACJ;IAEA,gBAAwB;QACpB,OAAO,IAAA,CAAK,YAAA,CAAa,EAAE,aAAA,CAAc;IAC7C;AAWJ;AAEO,MAAe,gBAAgB,OAAO;AAK7C;AAOO,SAAS,qBAAqB,KAAA,EAA8B;IAC/D,MAAM,EAAE,MAAA,EAAQ,KAAA,CAAM,CAAA,GAAI,oJAAA,CAAO,MAAA,CAAO,KAAK;IAC7C,IAAI,WAAW,yBAAyB;QACpC,MAAM,IAAI,MAAM,4BAA4B;IAChD;IACA,MAAM,oBAAoB,IAAI,WAAW,oJAAA,CAAO,SAAA,CAAU,KAAK,CAAC;IAChE,MAAM,YAAY,kBAAkB,KAAA,CAAM,CAAC;IAC3C,MAAM,kBACF,mQAAA,CAAyB,iBAAA,CAAkB,CAAC,CAA0C,CAAA;IAC1F,OAAO;QACH,QAAQ;QACR;IACJ;AACJ;AAOO,SAAS,qBAAqB,KAAA,EAAmB,MAAA,EAAiC;IACrF,IAAI,MAAM,MAAA,KAAW,kBAAkB;QACnC,MAAM,IAAI,MAAM,sBAAsB;IAC1C;IACA,MAAM,OAAO,mQAAA,CAAyB,MAAM,CAAA;IAC5C,MAAM,eAAe,IAAI,WAAW,MAAM,MAAA,GAAS,CAAC;IACpD,aAAa,GAAA,CAAI;QAAC,IAAI;KAAC;IACvB,aAAa,GAAA,CAAI,OAAO,CAAC;IACzB,OAAO,oJAAA,CAAO,MAAA,CAAO,yBAAyB,oJAAA,CAAO,OAAA,CAAQ,YAAY,CAAC;AAC9E"}},
    {"offset": {"line": 6049, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/cryptography/mnemonics.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\nimport { toHex } from '@iota/bcs';\nimport { mnemonicToSeedSync as bip39MnemonicToSeedSync } from '@scure/bip39';\n\n/**\n * Parse and validate a path that is compliant to SLIP-0010 in form m/44'/4218'/{account_index}'/{change_index}'/{address_index}'.\n *\n * @param path path string (e.g. `m/44'/4218'/0'/0'/0'`).\n */\nexport function isValidHardenedPath(path: string): boolean {\n    if (!new RegExp(\"^m\\\\/44'\\\\/4218'\\\\/[0-9]+'\\\\/[0-9]+'\\\\/[0-9]+'+$\").test(path)) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * Parse and validate a path that is compliant to BIP-32 in form m/54'/4218'/{account_index}'/{change_index}/{address_index}\n * for Secp256k1 and m/74'/4218'/{account_index}'/{change_index}/{address_index} for Secp256r1.\n *\n * Note that the purpose for Secp256k1 is registered as 54, to differentiate from Ed25519 with purpose 44.\n *\n * @param path path string (e.g. `m/54'/4218'/0'/0/0`).\n */\nexport function isValidBIP32Path(path: string): boolean {\n    if (!new RegExp(\"^m\\\\/(54|74)'\\\\/4218'\\\\/[0-9]+'\\\\/[0-9]+\\\\/[0-9]+$\").test(path)) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * Uses KDF to derive 64 bytes of key data from mnemonic with empty password.\n *\n * @param mnemonics 24 words string split by spaces.\n */\nexport function mnemonicToSeed(mnemonics: string): Uint8Array {\n    return bip39MnemonicToSeedSync(mnemonics, '');\n}\n\n/**\n * Derive the seed in hex format from a 24-word mnemonic string.\n *\n * @param mnemonics 24 words string split by spaces.\n */\nexport function mnemonicToSeedHex(mnemonics: string): string {\n    return toHex(mnemonicToSeed(mnemonics));\n}\n"],"names":[],"mappings":";;;;;;;;;;AAGA,SAAS,aAAa;AACtB,SAAS,sBAAsB,+BAA+B;;;AAOvD,SAAS,oBAAoB,IAAA,EAAuB;IACvD,IAAI,CAAC,IAAI,OAAO,kDAAkD,EAAE,IAAA,CAAK,IAAI,GAAG;QAC5E,OAAO;IACX;IACA,OAAO;AACX;AAUO,SAAS,iBAAiB,IAAA,EAAuB;IACpD,IAAI,CAAC,IAAI,OAAO,oDAAoD,EAAE,IAAA,CAAK,IAAI,GAAG;QAC9E,OAAO;IACX;IACA,OAAO;AACX;AAOO,SAAS,eAAe,SAAA,EAA+B;IAC1D,WAAO,yKAAA,EAAwB,WAAW,EAAE;AAChD;AAOO,SAAS,kBAAkB,SAAA,EAA2B;IACzD,WAAO,wMAAA,EAAM,eAAe,SAAS,CAAC;AAC1C"}},
    {"offset": {"line": 6087, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/keypairs/ed25519/ed25519-hd-key.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n// This is adapted from https://github.com/alepop/ed25519-hd-key replacing create-hmac\n// with @noble/hashes to be browser compatible.\n\nimport { fromHex } from '@iota/bcs';\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha512 } from '@noble/hashes/sha512';\nimport nacl from 'tweetnacl';\n\ntype Hex = string;\ntype Path = string;\n\ntype Keys = {\n    key: Uint8Array;\n    chainCode: Uint8Array;\n};\n\nconst ED25519_CURVE = 'ed25519 seed';\nconst HARDENED_OFFSET = 0x80000000;\n\nexport const pathRegex = new RegExp(\"^m(\\\\/[0-9]+')+$\");\n\nexport const replaceDerive = (val: string): string => val.replace(\"'\", '');\n\nexport const getMasterKeyFromSeed = (seed: Hex): Keys => {\n    const h = hmac.create(sha512, ED25519_CURVE);\n    const I = h.update(fromHex(seed)).digest();\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return {\n        key: IL,\n        chainCode: IR,\n    };\n};\n\nconst CKDPriv = ({ key, chainCode }: Keys, index: number): Keys => {\n    const indexBuffer = new ArrayBuffer(4);\n    const cv = new DataView(indexBuffer);\n    cv.setUint32(0, index);\n\n    const data = new Uint8Array(1 + key.length + indexBuffer.byteLength);\n    data.set(new Uint8Array(1).fill(0));\n    data.set(key, 1);\n    data.set(new Uint8Array(indexBuffer, 0, indexBuffer.byteLength), key.length + 1);\n\n    const I = hmac.create(sha512, chainCode).update(data).digest();\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return {\n        key: IL,\n        chainCode: IR,\n    };\n};\n\nexport const getPublicKey = (privateKey: Uint8Array, withZeroByte = true): Uint8Array => {\n    const keyPair = nacl.sign.keyPair.fromSeed(privateKey);\n    const signPk = keyPair.secretKey.subarray(32);\n    const newArr = new Uint8Array(signPk.length + 1);\n    newArr.set([0]);\n    newArr.set(signPk, 1);\n    return withZeroByte ? newArr : signPk;\n};\n\nexport const isValidPath = (path: string): boolean => {\n    if (!pathRegex.test(path)) {\n        return false;\n    }\n    return !path\n        .split('/')\n        .slice(1)\n        .map(replaceDerive)\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        .some(isNaN as any /* ts T_T*/);\n};\n\nexport const derivePath = (path: Path, seed: Hex, offset = HARDENED_OFFSET): Keys => {\n    if (!isValidPath(path)) {\n        throw new Error('Invalid derivation path');\n    }\n\n    const { key, chainCode } = getMasterKeyFromSeed(seed);\n    const segments = path\n        .split('/')\n        .slice(1)\n        .map(replaceDerive)\n        .map((el) => parseInt(el, 10));\n\n    return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), {\n        key,\n        chainCode,\n    });\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAOA,SAAS,eAAe;AACxB,SAAS,YAAY;AACrB,SAAS,cAAc;AACvB,OAAO,UAAU;;;;;AAUjB,MAAM,gBAAgB;AACtB,MAAM,kBAAkB;AAEjB,MAAM,YAAY,IAAI,OAAO,kBAAkB;AAE/C,MAAM,gBAAgB,CAAC,MAAwB,IAAI,OAAA,CAAQ,KAAK,EAAE;AAElE,MAAM,uBAAuB,CAAC,SAAoB;IACrD,MAAM,IAAI,2JAAA,CAAK,MAAA,CAAO,+JAAA,EAAQ,aAAa;IAC3C,MAAM,IAAI,EAAE,MAAA,KAAO,0MAAA,EAAQ,IAAI,CAAC,EAAE,MAAA,CAAO;IACzC,MAAM,KAAK,EAAE,KAAA,CAAM,GAAG,EAAE;IACxB,MAAM,KAAK,EAAE,KAAA,CAAM,EAAE;IACrB,OAAO;QACH,KAAK;QACL,WAAW;IACf;AACJ;AAEA,MAAM,UAAU,CAAC,EAAE,GAAA,EAAK,SAAA,CAAU,CAAA,EAAS,UAAwB;IAC/D,MAAM,cAAc,IAAI,YAAY,CAAC;IACrC,MAAM,KAAK,IAAI,SAAS,WAAW;IACnC,GAAG,SAAA,CAAU,GAAG,KAAK;IAErB,MAAM,OAAO,IAAI,WAAW,IAAI,IAAI,MAAA,GAAS,YAAY,UAAU;IACnE,KAAK,GAAA,CAAI,IAAI,WAAW,CAAC,EAAE,IAAA,CAAK,CAAC,CAAC;IAClC,KAAK,GAAA,CAAI,KAAK,CAAC;IACf,KAAK,GAAA,CAAI,IAAI,WAAW,aAAa,GAAG,YAAY,UAAU,GAAG,IAAI,MAAA,GAAS,CAAC;IAE/E,MAAM,IAAI,2JAAA,CAAK,MAAA,CAAO,+JAAA,EAAQ,SAAS,EAAE,MAAA,CAAO,IAAI,EAAE,MAAA,CAAO;IAC7D,MAAM,KAAK,EAAE,KAAA,CAAM,GAAG,EAAE;IACxB,MAAM,KAAK,EAAE,KAAA,CAAM,EAAE;IACrB,OAAO;QACH,KAAK;QACL,WAAW;IACf;AACJ;AAEO,MAAM,eAAe,CAAC,YAAwB,eAAe,IAAA,KAAqB;IACrF,MAAM,UAAU,uJAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,QAAA,CAAS,UAAU;IACrD,MAAM,SAAS,QAAQ,SAAA,CAAU,QAAA,CAAS,EAAE;IAC5C,MAAM,SAAS,IAAI,WAAW,OAAO,MAAA,GAAS,CAAC;IAC/C,OAAO,GAAA,CAAI;QAAC,CAAC;KAAC;IACd,OAAO,GAAA,CAAI,QAAQ,CAAC;IACpB,OAAO,eAAe,SAAS;AACnC;AAEO,MAAM,cAAc,CAAC,SAA0B;IAClD,IAAI,CAAC,UAAU,IAAA,CAAK,IAAI,GAAG;QACvB,OAAO;IACX;IACA,OAAO,CAAC,KACH,KAAA,CAAM,GAAG,EACT,KAAA,CAAM,CAAC,EACP,GAAA,CAAI,aAAa,EAEjB,IAAA,CAAK;AACd;AAEO,MAAM,aAAa,CAAC,MAAY,MAAW,SAAS,eAAA,KAA0B;IACjF,IAAI,CAAC,YAAY,IAAI,GAAG;QACpB,MAAM,IAAI,MAAM,yBAAyB;IAC7C;IAEA,MAAM,EAAE,GAAA,EAAK,SAAA,CAAU,CAAA,GAAI,qBAAqB,IAAI;IACpD,MAAM,WAAW,KACZ,KAAA,CAAM,GAAG,EACT,KAAA,CAAM,CAAC,EACP,GAAA,CAAI,aAAa,EACjB,GAAA,CAAI,CAAC,KAAO,SAAS,IAAI,EAAE,CAAC;IAEjC,OAAO,SAAS,MAAA,CAAO,CAAC,YAAY,UAAY,QAAQ,YAAY,UAAU,MAAM,GAAG;QACnF;QACA;IACJ,CAAC;AACL"}},
    {"offset": {"line": 6172, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/keypairs/ed25519/publickey.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64 } from '@iota/bcs';\nimport nacl from 'tweetnacl';\n\nimport type { PublicKeyInitData } from '../../cryptography/publickey.js';\nimport { bytesEqual, PublicKey } from '../../cryptography/publickey.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from '../../cryptography/signature-scheme.js';\nimport { parseSerializedSignature } from '../../cryptography/signature.js';\n\nconst PUBLIC_KEY_SIZE = 32;\n\n/**\n * An Ed25519 public key\n */\nexport class Ed25519PublicKey extends PublicKey {\n    static SIZE = PUBLIC_KEY_SIZE;\n    private data: Uint8Array;\n\n    /**\n     * Create a new Ed25519PublicKey object\n     * @param value ed25519 public key as buffer or base-64 encoded string\n     */\n    constructor(value: PublicKeyInitData) {\n        super();\n\n        if (typeof value === 'string') {\n            this.data = fromBase64(value);\n        } else if (value instanceof Uint8Array) {\n            this.data = value;\n        } else {\n            this.data = Uint8Array.from(value);\n        }\n\n        if (this.data.length !== PUBLIC_KEY_SIZE) {\n            throw new Error(\n                `Invalid public key input. Expected ${PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`,\n            );\n        }\n    }\n\n    /**\n     * Checks if two Ed25519 public keys are equal\n     */\n    override equals(publicKey: Ed25519PublicKey): boolean {\n        return super.equals(publicKey);\n    }\n\n    /**\n     * Return the byte array representation of the Ed25519 public key\n     */\n    toRawBytes(): Uint8Array {\n        return this.data;\n    }\n\n    /**\n     * Return the IOTA address associated with this Ed25519 public key\n     */\n    flag(): number {\n        return SIGNATURE_SCHEME_TO_FLAG['ED25519'];\n    }\n\n    /**\n     * Verifies that the signature is valid for the provided message\n     */\n    async verify(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n        let bytes;\n        if (typeof signature === 'string') {\n            const parsed = parseSerializedSignature(signature);\n            if (parsed.signatureScheme !== 'ED25519') {\n                throw new Error('Invalid signature scheme');\n            }\n\n            if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {\n                throw new Error('Signature does not match public key');\n            }\n\n            bytes = parsed.signature;\n        } else {\n            bytes = signature;\n        }\n\n        return nacl.sign.detached.verify(message, bytes, this.toRawBytes());\n    }\n}\n"],"names":[],"mappings":";;;;AAIA,SAAS,kBAAkB;AAC3B,OAAO,UAAU;AAGjB,SAAS,YAAY,iBAAiB;AACtC,SAAS,gCAAgC;AACzC,SAAS,gCAAgC;;;;;;AAEzC,MAAM,kBAAkB;AAKjB,MAAM,yBAAyB,0OAAA,CAAU;IAAA;;;GAAA,GAQ5C,YAAY,KAAA,CAA0B;QAClC,KAAA,CAAM;QAEN,IAAI,OAAO,UAAU,UAAU;YAC3B,IAAA,CAAK,IAAA,OAAO,6MAAA,EAAW,KAAK;QAChC,OAAA,IAAW,iBAAiB,YAAY;YACpC,IAAA,CAAK,IAAA,GAAO;QAChB,OAAO;YACH,IAAA,CAAK,IAAA,GAAO,WAAW,IAAA,CAAK,KAAK;QACrC;QAEA,IAAI,IAAA,CAAK,IAAA,CAAK,MAAA,KAAW,iBAAiB;YACtC,MAAM,IAAI,MACN,CAAA,mCAAA,EAAsC,eAAe,CAAA,YAAA,EAAe,IAAA,CAAK,IAAA,CAAK,MAAM,EAAA;QAE5F;IACJ;IAAA;;GAAA,GAKS,OAAO,SAAA,EAAsC;QAClD,OAAO,KAAA,CAAM,OAAO,SAAS;IACjC;IAAA;;GAAA,GAKA,aAAyB;QACrB,OAAO,IAAA,CAAK,IAAA;IAChB;IAAA;;GAAA,GAKA,OAAe;QACX,OAAO,mQAAA,CAAyB,SAAS,CAAA;IAC7C;IAAA;;GAAA,GAKA,MAAM,OAAO,OAAA,EAAqB,SAAA,EAAkD;QAChF,IAAI;QACJ,IAAI,OAAO,cAAc,UAAU;YAC/B,MAAM,aAAS,yPAAA,EAAyB,SAAS;YACjD,IAAI,OAAO,eAAA,KAAoB,WAAW;gBACtC,MAAM,IAAI,MAAM,0BAA0B;YAC9C;YAEA,IAAI,KAAC,2OAAA,EAAW,IAAA,CAAK,UAAA,CAAW,GAAG,OAAO,SAAS,GAAG;gBAClD,MAAM,IAAI,MAAM,qCAAqC;YACzD;YAEA,QAAQ,OAAO,SAAA;QACnB,OAAO;YACH,QAAQ;QACZ;QAEA,OAAO,uJAAA,CAAK,IAAA,CAAK,QAAA,CAAS,MAAA,CAAO,SAAS,OAAO,IAAA,CAAK,UAAA,CAAW,CAAC;IACtE;AACJ;AArEa,iBACF,IAAA,GAAO"}},
    {"offset": {"line": 6245, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/iota-sdk/src/keypairs/ed25519/keypair.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport nacl from 'tweetnacl';\n\nimport {\n    decodeIotaPrivateKey,\n    encodeIotaPrivateKey,\n    Keypair,\n    PRIVATE_KEY_SIZE,\n} from '../../cryptography/keypair.js';\nimport { isValidHardenedPath, mnemonicToSeedHex } from '../../cryptography/mnemonics.js';\nimport type { SignatureScheme } from '../../cryptography/signature-scheme.js';\nimport { derivePath } from './ed25519-hd-key.js';\nimport { Ed25519PublicKey } from './publickey.js';\n\nexport const DEFAULT_ED25519_DERIVATION_PATH = \"m/44'/4218'/0'/0'/0'\";\n\n/**\n * Ed25519 Keypair data. The publickey is the 32-byte public key and\n * the secretkey is 64-byte, where the first 32 bytes is the secret\n * key and the last 32 bytes is the public key.\n */\nexport interface Ed25519KeypairData {\n    publicKey: Uint8Array;\n    secretKey: Uint8Array;\n}\n\n/**\n * An Ed25519 Keypair used for signing transactions.\n */\nexport class Ed25519Keypair extends Keypair {\n    private keypair: Ed25519KeypairData;\n\n    /**\n     * Create a new Ed25519 keypair instance.\n     * Generate random keypair if no {@link Ed25519Keypair} is provided.\n     *\n     * @param keypair Ed25519 keypair\n     */\n    constructor(keypair?: Ed25519KeypairData) {\n        super();\n        if (keypair) {\n            this.keypair = keypair;\n        } else {\n            this.keypair = nacl.sign.keyPair();\n        }\n    }\n\n    /**\n     * Get the key scheme of the keypair ED25519\n     */\n    getKeyScheme(): SignatureScheme {\n        return 'ED25519';\n    }\n\n    /**\n     * Generate a new random Ed25519 keypair\n     */\n    static generate(): Ed25519Keypair {\n        return new Ed25519Keypair(nacl.sign.keyPair());\n    }\n\n    /**\n     * Create a Ed25519 keypair from a raw secret key byte array, also known as seed.\n     * This is NOT the private scalar which is result of hashing and bit clamping of\n     * the raw secret key.\n     *\n     * @throws error if the provided secret key is invalid and validation is not skipped.\n     *\n     * @param secretKey secret key as a byte array or Bech32 secret key string\n     * @param options: skip secret key validation\n     */\n    static fromSecretKey(\n        secretKey: Uint8Array | string,\n        options?: { skipValidation?: boolean },\n    ): Ed25519Keypair {\n        if (typeof secretKey === 'string') {\n            const decoded = decodeIotaPrivateKey(secretKey);\n\n            if (decoded.schema !== 'ED25519') {\n                throw new Error(`Expected a ED25519 keypair, got ${decoded.schema}`);\n            }\n\n            return this.fromSecretKey(decoded.secretKey, options);\n        }\n\n        const secretKeyLength = secretKey.length;\n        if (secretKeyLength !== PRIVATE_KEY_SIZE) {\n            throw new Error(\n                `Wrong secretKey size. Expected ${PRIVATE_KEY_SIZE} bytes, got ${secretKeyLength}.`,\n            );\n        }\n        const keypair = nacl.sign.keyPair.fromSeed(secretKey);\n        if (!options || !options.skipValidation) {\n            const encoder = new TextEncoder();\n            const signData = encoder.encode('iota validation');\n            const signature = nacl.sign.detached(signData, keypair.secretKey);\n            if (!nacl.sign.detached.verify(signData, signature, keypair.publicKey)) {\n                throw new Error('provided secretKey is invalid');\n            }\n        }\n        return new Ed25519Keypair(keypair);\n    }\n\n    /**\n     * The public key for this Ed25519 keypair\n     */\n    getPublicKey(): Ed25519PublicKey {\n        return new Ed25519PublicKey(this.keypair.publicKey);\n    }\n\n    /**\n     * The Bech32 secret key string for this Ed25519 keypair\n     */\n    getSecretKey(): string {\n        return encodeIotaPrivateKey(\n            this.keypair.secretKey.slice(0, PRIVATE_KEY_SIZE),\n            this.getKeyScheme(),\n        );\n    }\n\n    /**\n     * Return the signature for the provided data using Ed25519.\n     */\n    async sign(data: Uint8Array) {\n        return nacl.sign.detached(data, this.keypair.secretKey);\n    }\n\n    /**\n     * Derive Ed25519 keypair from mnemonics and path. The mnemonics must be normalized\n     * and validated against the english wordlist.\n     *\n     * If path is none, it will default to m/44'/4218'/0'/0'/0', otherwise the path must\n     * be compliant to SLIP-0010 in form m/44'/4218'/{account_index}'/{change_index}'/{address_index}'.\n     */\n    static deriveKeypair(mnemonics: string, path?: string): Ed25519Keypair {\n        if (path == null) {\n            path = DEFAULT_ED25519_DERIVATION_PATH;\n        }\n        if (!isValidHardenedPath(path)) {\n            throw new Error('Invalid derivation path');\n        }\n        const { key } = derivePath(path, mnemonicToSeedHex(mnemonics));\n\n        return Ed25519Keypair.fromSecretKey(key);\n    }\n\n    /**\n     * Derive Ed25519 keypair from mnemonicSeed and path.\n     *\n     * If path is none, it will default to m/44'/4218'/0'/0'/0', otherwise the path must\n     * be compliant to SLIP-0010 in form m/44'/4218'/{account_index}'/{change_index}'/{address_index}'.\n     */\n    static deriveKeypairFromSeed(seedHex: string, path?: string): Ed25519Keypair {\n        if (path == null) {\n            path = DEFAULT_ED25519_DERIVATION_PATH;\n        }\n        if (!isValidHardenedPath(path)) {\n            throw new Error('Invalid derivation path');\n        }\n        const { key } = derivePath(path, seedHex);\n\n        return Ed25519Keypair.fromSecretKey(key);\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6371, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/iota-sdk/src/client/network.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nexport enum Network {\n    Mainnet = 'mainnet',\n    Devnet = 'devnet',\n    Testnet = 'testnet',\n    Localnet = 'localnet',\n    Custom = 'custom',\n}\n\n// We also accept `string` in case we want to use a network not supported by the SDK\nexport type NetworkId = Network | string;\n\nexport type ChainType = `${string}:${string}`;\n\nexport interface NetworkConfiguration<Metadata = undefined> {\n    id: Network;\n    name: string;\n    url: string;\n    explorer: string;\n    chain: ChainType;\n    faucet?: string;\n    kiosk?: KioskConfiguration;\n    graphql?: string;\n    metadata?: Metadata;\n}\n\nexport interface KioskConfiguration {\n    royaltyRulePackageId: string;\n    kioskLockRulePackageId: string;\n    floorPriceRulePackageId: string;\n    personalKioskRulePackageId: string;\n}\n\ntype NetworksConfiguration = Record<NetworkId, NetworkConfiguration>;\n\nexport function getAllNetworks(): NetworksConfiguration {\n    const networksStringified = process.env.IOTA_NETWORKS;\n\n    if (!networksStringified) {\n        throw new Error('\"IOTA_NETWORKS\" env var is not set.');\n    }\n\n    let networks;\n\n    try {\n        networks = JSON.parse(networksStringified);\n    } catch {\n        throw new Error('Failed to parse env var \"IOTA_NETWORKS\".');\n    }\n\n    return networks;\n}\n\nexport function getNetwork<T>(network: NetworkId): NetworkConfiguration<T> {\n    const networks = getAllNetworks();\n\n    const requestedNetwork = (networks[network] ?? network) as NetworkConfiguration<T>;\n\n    return requestedNetwork;\n}\n\nexport function getDefaultNetwork(): Network {\n    return (process.env.DEFAULT_NETWORK as Network) || Network.Mainnet;\n}\n\nexport function getFullnodeUrl(network: NetworkId): string {\n    return getNetwork(network).url;\n}\n\nexport function getGraphQLUrl(network: NetworkId): string | undefined {\n    return getNetwork(network).graphql;\n}\n"],"names":["Network"],"mappings":";;;;;;;;;;;;;;AAIO,IAAK,UAAL,aAAA,GAAA,CAAA,CAAKA,aAAL;IACHA,QAAAA,CAAA,UAAA,GAAU;IACVA,QAAAA,CAAA,SAAA,GAAS;IACTA,QAAAA,CAAA,UAAA,GAAU;IACVA,QAAAA,CAAA,WAAA,GAAW;IACXA,QAAAA,CAAA,SAAA,GAAS;IALD,OAAAA;AAAA,CAAA,EAAA,WAAA,CAAA;AAkCL,SAAS,iBAAwC;IACpD,MAAM,sBAAsB;IAE5B,IAAI,CAAC,qBAAqB;;IAI1B,IAAI;IAEJ,IAAI;QACA,WAAW,KAAK,KAAA,CAAM,mBAAmB;IAC7C,EAAA,OAAQ;QACJ,MAAM,IAAI,MAAM,0CAA0C;IAC9D;IAEA,OAAO;AACX;AAEO,SAAS,WAAc,OAAA,EAA6C;IACvE,MAAM,WAAW,eAAe;IAEhC,MAAM,mBAAoB,QAAA,CAAS,OAAO,CAAA,IAAK;IAE/C,OAAO;AACX;AAEO,SAAS,oBAA6B;IACzC,OAAQ;AACZ;AAEO,SAAS,eAAe,OAAA,EAA4B;IACvD,OAAO,WAAW,OAAO,EAAE,GAAA;AAC/B;AAEO,SAAS,cAAc,OAAA,EAAwC;IAClE,OAAO,WAAW,OAAO,EAAE,OAAA;AAC/B"}}]
}