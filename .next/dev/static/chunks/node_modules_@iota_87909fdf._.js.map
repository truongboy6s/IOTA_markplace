{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/wallet-standard/src/chains.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { getAllNetworks } from '@iota/iota-sdk/client';\nimport type { IdentifierString } from '@wallet-standard/core';\n\nexport const SUPPORTED_CHAINS = Object.values(getAllNetworks()).map((network) => network.chain);\n\n/**\n * Utility that returns whether or not a chain identifier is a supported chain.\n * @param chain a chain identifier in the form of `${string}:{$string}`\n */\nexport function isSupportedChain(chain: IdentifierString): boolean {\n    return SUPPORTED_CHAINS.includes(chain) || chain.split(':')[0] === 'iota';\n}\n"],"names":[],"mappings":";;;;;;AAIA,SAAS,sBAAsB;;AAGxB,MAAM,mBAAmB,OAAO,MAAA,KAAO,8OAAA,CAAe,CAAC,GAAE,GAAA,CAAI,CAAC,UAAY,QAAQ,KAAK;AAMvF,SAAS,iBAAiB,KAAA,EAAkC;IAC/D,OAAO,iBAAiB,QAAA,CAAS,KAAK,KAAK,MAAM,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAA,KAAM;AACvE"}},
    {"offset": {"line": 22, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/wallet-standard/src/detect.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Wallet, WalletWithFeatures } from '@wallet-standard/core';\n\nimport type { MinimallyRequiredFeatures } from './features/index.js';\n\n// These features are absolutely required for wallets to function in the IOTA ecosystem.\n// Eventually, as wallets have more consistent support of features, we may want to extend this list.\nconst REQUIRED_FEATURES: (keyof MinimallyRequiredFeatures)[] = [\n    'standard:connect',\n    'standard:events',\n];\n\nexport function isWalletWithRequiredFeatureSet<AdditionalFeatures extends Wallet['features']>(\n    wallet: Wallet,\n    additionalFeatures: (keyof AdditionalFeatures)[] = [],\n): wallet is WalletWithFeatures<MinimallyRequiredFeatures & AdditionalFeatures> {\n    return [...REQUIRED_FEATURES, ...additionalFeatures].every(\n        (feature) => feature in wallet.features,\n    );\n}\n"],"names":[],"mappings":";;;;AAUA,MAAM,oBAAyD;IAC3D;IACA;CACJ;AAEO,SAAS,+BACZ,MAAA,EACA,qBAAmD,CAAC,CAAA,EACwB;IAC5E,OAAO,CAAC;WAAG,mBAAmB;WAAG,kBAAkB;KAAA,CAAE,KAAA,CACjD,CAAC,UAAY,WAAW,OAAO,QAAA;AAEvC"}},
    {"offset": {"line": 42, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/wallet-standard/src/wallet.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { WalletWithFeatures } from '@wallet-standard/core';\n\nimport type {\n    IotaSignAndExecuteTransactionInput,\n    IotaSignTransactionInput,\n    IotaWalletFeatures,\n} from './features/index.js';\n\ndeclare module '@wallet-standard/core' {\n    export interface Wallet {\n        /**\n         * Unique identifier of the Wallet.\n         *\n         * If not provided, the wallet name will be used as the identifier.\n         */\n        readonly id?: string;\n    }\n\n    export interface StandardConnectOutput {\n        supportedIntents?: string[];\n    }\n}\n\nexport type { Wallet } from '@wallet-standard/core';\n\nexport async function signAndExecuteTransaction(\n    wallet: WalletWithFeatures<Partial<IotaWalletFeatures>>,\n    input: IotaSignAndExecuteTransactionInput,\n) {\n    if (!wallet.features['iota:signAndExecuteTransaction']) {\n        throw new Error(\n            `Provided wallet (${wallet.name}) does not support the signAndExecuteTransaction feature.`,\n        );\n    }\n\n    return wallet.features['iota:signAndExecuteTransaction'].signAndExecuteTransaction(input);\n}\n\nexport async function signTransaction(\n    wallet: WalletWithFeatures<Partial<IotaWalletFeatures>>,\n    input: IotaSignTransactionInput,\n) {\n    if (!wallet.features['iota:signTransaction']) {\n        throw new Error(\n            `Provided wallet (${wallet.name}) does not support the signTransaction feature.`,\n        );\n    }\n\n    return wallet.features['iota:signTransaction'].signTransaction(input);\n}\n"],"names":[],"mappings":";;;;;;AA6BA,eAAsB,0BAClB,MAAA,EACA,KAAA,EACF;IACE,IAAI,CAAC,OAAO,QAAA,CAAS,gCAAgC,CAAA,EAAG;QACpD,MAAM,IAAI,MACN,CAAA,iBAAA,EAAoB,OAAO,IAAI,CAAA,yDAAA,CAAA;IAEvC;IAEA,OAAO,OAAO,QAAA,CAAS,gCAAgC,CAAA,CAAE,yBAAA,CAA0B,KAAK;AAC5F;AAEA,eAAsB,gBAClB,MAAA,EACA,KAAA,EACF;IACE,IAAI,CAAC,OAAO,QAAA,CAAS,sBAAsB,CAAA,EAAG;QAC1C,MAAM,IAAI,MACN,CAAA,iBAAA,EAAoB,OAAO,IAAI,CAAA,+CAAA,CAAA;IAEvC;IAEA,OAAO,OAAO,QAAA,CAAS,sBAAsB,CAAA,CAAE,eAAA,CAAgB,KAAK;AACxE"}},
    {"offset": {"line": 66, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/bcs/src/b58.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport bs58 from 'bs58';\n\nexport const toBase58 = (buffer: Uint8Array) => bs58.encode(buffer);\nexport const fromBase58 = (str: string) => bs58.decode(str);\n\n/** @deprecated use toBase58 instead */\nexport const toB58 = toBase58;\n\n/** @deprecated use fromBase58 instead */\nexport const fromB58 = fromBase58;\n"],"names":[],"mappings":";;;;;;;;;;AAIA,OAAO,UAAU;;AAEV,MAAM,WAAW,CAAC,SAAuB,yJAAA,CAAK,MAAA,CAAO,MAAM;AAC3D,MAAM,aAAa,CAAC,MAAgB,yJAAA,CAAK,MAAA,CAAO,GAAG;AAGnD,MAAM,QAAQ;AAGd,MAAM,UAAU"}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/bcs/src/b64.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromBase64(base64String: string): Uint8Array {\n    return Uint8Array.from(atob(base64String), (char) => char.charCodeAt(0));\n}\n\nconst CHUNK_SIZE = 8192;\nexport function toBase64(bytes: Uint8Array): string {\n    // Special-case the simple case for speed's sake.\n    if (bytes.length < CHUNK_SIZE) {\n        return btoa(String.fromCharCode(...bytes));\n    }\n\n    let output = '';\n    for (let i = 0; i < bytes.length; i += CHUNK_SIZE) {\n        const chunk = bytes.slice(i, i + CHUNK_SIZE);\n        output += String.fromCharCode(...chunk);\n    }\n\n    return btoa(output);\n}\n\n/** @deprecated use toBase64 instead */\nexport const toB64 = toBase64;\n\n/** @deprecated use fromBase64 instead */\nexport const fromB64 = fromBase64;\n"],"names":[],"mappings":";;;;;;;;;;AAIO,SAAS,WAAW,YAAA,EAAkC;IACzD,OAAO,WAAW,IAAA,CAAK,KAAK,YAAY,GAAG,CAAC,OAAS,KAAK,UAAA,CAAW,CAAC,CAAC;AAC3E;AAEA,MAAM,aAAa;AACZ,SAAS,SAAS,KAAA,EAA2B;IAEhD,IAAI,MAAM,MAAA,GAAS,YAAY;QAC3B,OAAO,KAAK,OAAO,YAAA,CAAa,GAAG,KAAK,CAAC;IAC7C;IAEA,IAAI,SAAS;IACb,IAAA,IAAS,IAAI,GAAG,IAAI,MAAM,MAAA,EAAQ,KAAK,WAAY;QAC/C,MAAM,QAAQ,MAAM,KAAA,CAAM,GAAG,IAAI,UAAU;QAC3C,UAAU,OAAO,YAAA,CAAa,GAAG,KAAK;IAC1C;IAEA,OAAO,KAAK,MAAM;AACtB;AAGO,MAAM,QAAQ;AAGd,MAAM,UAAU"}},
    {"offset": {"line": 121, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/bcs/src/hex.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromHex(hexStr: string): Uint8Array {\n    const normalized = hexStr.startsWith('0x') ? hexStr.slice(2) : hexStr;\n    const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;\n    const intArr = padded.match(/.{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\n\n    return Uint8Array.from(intArr);\n}\n\nexport function toHex(bytes: Uint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n\n/** @deprecated use toHex instead */\nexport const toHEX = toHex;\n\n/** @deprecated use fromHex instead */\nexport const fromHEX = fromHex;\n"],"names":[],"mappings":";;;;;;;;;;AAIO,SAAS,QAAQ,MAAA,EAA4B;IAChD,MAAM,aAAa,OAAO,UAAA,CAAW,IAAI,IAAI,OAAO,KAAA,CAAM,CAAC,IAAI;IAC/D,MAAM,SAAS,WAAW,MAAA,GAAS,MAAM,IAAI,aAAa,CAAA,CAAA,EAAI,UAAU,CAAA,CAAA,CAAA;IACxE,MAAM,SAAS,OAAO,KAAA,CAAM,OAAO,GAAG,IAAI,CAAC,OAAS,SAAS,MAAM,EAAE,CAAC,KAAK,CAAC,CAAA;IAE5E,OAAO,WAAW,IAAA,CAAK,MAAM;AACjC;AAEO,SAAS,MAAM,KAAA,EAA2B;IAC7C,OAAO,MAAM,MAAA,CAAO,CAAC,KAAK,OAAS,MAAM,KAAK,QAAA,CAAS,EAAE,EAAE,QAAA,CAAS,GAAG,GAAG,GAAG,EAAE;AACnF;AAGO,MAAM,QAAQ;AAGd,MAAM,UAAU"}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/bcs/src/utils.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, toBase58 } from './b58.js';\nimport { fromBase64, toBase64 } from './b64.js';\nimport { fromHex, toHex } from './hex.js';\nimport type { Encoding } from './types.js';\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n    switch (encoding) {\n        case 'base58':\n            return toBase58(data);\n        case 'base64':\n            return toBase64(data);\n        case 'hex':\n            return toHex(data);\n        default:\n            throw new Error('Unsupported encoding, supported values are: base64, hex');\n    }\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n    switch (encoding) {\n        case 'base58':\n            return fromBase58(data);\n        case 'base64':\n            return fromBase64(data);\n        case 'hex':\n            return fromHex(data);\n        default:\n            throw new Error('Unsupported encoding, supported values are: base64, hex');\n    }\n}\n\nexport function splitGenericParameters(\n    str: string,\n    genericSeparators: [string, string] = ['<', '>'],\n) {\n    const [left, right] = genericSeparators;\n    const tok = [];\n    let word = '';\n    let nestedAngleBrackets = 0;\n\n    for (let i = 0; i < str.length; i++) {\n        const char = str[i];\n        if (char === left) {\n            nestedAngleBrackets++;\n        }\n        if (char === right) {\n            nestedAngleBrackets--;\n        }\n        if (nestedAngleBrackets === 0 && char === ',') {\n            tok.push(word.trim());\n            word = '';\n            continue;\n        }\n        word += char;\n    }\n\n    tok.push(word.trim());\n\n    return tok;\n}\n"],"names":[],"mappings":";;;;;;;;AAIA,SAAS,YAAY,gBAAgB;AACrC,SAAS,YAAY,gBAAgB;AACrC,SAAS,SAAS,aAAa;;;;AAUxB,SAAS,UAAU,IAAA,EAAkB,QAAA,EAA4B;IACpE,OAAQ,UAAU;QACd,KAAK;YACD,WAAO,2MAAA,EAAS,IAAI;QACxB,KAAK;YACD,WAAO,2MAAA,EAAS,IAAI;QACxB,KAAK;YACD,WAAO,wMAAA,EAAM,IAAI;QACrB;YACI,MAAM,IAAI,MAAM,yDAAyD;IACjF;AACJ;AASO,SAAS,UAAU,IAAA,EAAc,QAAA,EAAgC;IACpE,OAAQ,UAAU;QACd,KAAK;YACD,WAAO,6MAAA,EAAW,IAAI;QAC1B,KAAK;YACD,WAAO,6MAAA,EAAW,IAAI;QAC1B,KAAK;YACD,WAAO,0MAAA,EAAQ,IAAI;QACvB;YACI,MAAM,IAAI,MAAM,yDAAyD;IACjF;AACJ;AAEO,SAAS,uBACZ,GAAA,EACA,oBAAsC;IAAC;IAAK,GAAG;CAAA,EACjD;IACE,MAAM,CAAC,MAAM,KAAK,CAAA,GAAI;IACtB,MAAM,MAAM,CAAC,CAAA;IACb,IAAI,OAAO;IACX,IAAI,sBAAsB;IAE1B,IAAA,IAAS,IAAI,GAAG,IAAI,IAAI,MAAA,EAAQ,IAAK;QACjC,MAAM,OAAO,GAAA,CAAI,CAAC,CAAA;QAClB,IAAI,SAAS,MAAM;YACf;QACJ;QACA,IAAI,SAAS,OAAO;YAChB;QACJ;QACA,IAAI,wBAAwB,KAAK,SAAS,KAAK;YAC3C,IAAI,IAAA,CAAK,KAAK,IAAA,CAAK,CAAC;YACpB,OAAO;YACP;QACJ;QACA,QAAQ;IACZ;IAEA,IAAI,IAAA,CAAK,KAAK,IAAA,CAAK,CAAC;IAEpB,OAAO;AACX"}},
    {"offset": {"line": 218, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/bcs/src/b58.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport bs58 from 'bs58';\n\nexport const toBase58 = (buffer: Uint8Array) => bs58.encode(buffer);\nexport const fromBase58 = (str: string) => bs58.decode(str);\n\n/** @deprecated use toBase58 instead */\nexport const toB58 = toBase58;\n\n/** @deprecated use fromBase58 instead */\nexport const fromB58 = fromBase58;\n"],"names":[],"mappings":";;;;;;;;;;AAIA,OAAO,UAAU;;AAEV,MAAM,WAAW,CAAC,SAAuB,yJAAA,CAAK,MAAA,CAAO,MAAM;AAC3D,MAAM,aAAa,CAAC,MAAgB,yJAAA,CAAK,MAAA,CAAO,GAAG;AAGnD,MAAM,QAAQ;AAGd,MAAM,UAAU"}},
    {"offset": {"line": 240, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/bcs/src/b64.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromBase64(base64String: string): Uint8Array {\n    return Uint8Array.from(atob(base64String), (char) => char.charCodeAt(0));\n}\n\nconst CHUNK_SIZE = 8192;\nexport function toBase64(bytes: Uint8Array): string {\n    // Special-case the simple case for speed's sake.\n    if (bytes.length < CHUNK_SIZE) {\n        return btoa(String.fromCharCode(...bytes));\n    }\n\n    let output = '';\n    for (let i = 0; i < bytes.length; i += CHUNK_SIZE) {\n        const chunk = bytes.slice(i, i + CHUNK_SIZE);\n        output += String.fromCharCode(...chunk);\n    }\n\n    return btoa(output);\n}\n\n/** @deprecated use toBase64 instead */\nexport const toB64 = toBase64;\n\n/** @deprecated use fromBase64 instead */\nexport const fromB64 = fromBase64;\n"],"names":[],"mappings":";;;;;;;;;;AAIO,SAAS,WAAW,YAAA,EAAkC;IACzD,OAAO,WAAW,IAAA,CAAK,KAAK,YAAY,GAAG,CAAC,OAAS,KAAK,UAAA,CAAW,CAAC,CAAC;AAC3E;AAEA,MAAM,aAAa;AACZ,SAAS,SAAS,KAAA,EAA2B;IAEhD,IAAI,MAAM,MAAA,GAAS,YAAY;QAC3B,OAAO,KAAK,OAAO,YAAA,CAAa,GAAG,KAAK,CAAC;IAC7C;IAEA,IAAI,SAAS;IACb,IAAA,IAAS,IAAI,GAAG,IAAI,MAAM,MAAA,EAAQ,KAAK,WAAY;QAC/C,MAAM,QAAQ,MAAM,KAAA,CAAM,GAAG,IAAI,UAAU;QAC3C,UAAU,OAAO,YAAA,CAAa,GAAG,KAAK;IAC1C;IAEA,OAAO,KAAK,MAAM;AACtB;AAGO,MAAM,QAAQ;AAGd,MAAM,UAAU"}},
    {"offset": {"line": 273, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/bcs/src/hex.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromHex(hexStr: string): Uint8Array {\n    const normalized = hexStr.startsWith('0x') ? hexStr.slice(2) : hexStr;\n    const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;\n    const intArr = padded.match(/.{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\n\n    return Uint8Array.from(intArr);\n}\n\nexport function toHex(bytes: Uint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n\n/** @deprecated use toHex instead */\nexport const toHEX = toHex;\n\n/** @deprecated use fromHex instead */\nexport const fromHEX = fromHex;\n"],"names":[],"mappings":";;;;;;;;;;AAIO,SAAS,QAAQ,MAAA,EAA4B;IAChD,MAAM,aAAa,OAAO,UAAA,CAAW,IAAI,IAAI,OAAO,KAAA,CAAM,CAAC,IAAI;IAC/D,MAAM,SAAS,WAAW,MAAA,GAAS,MAAM,IAAI,aAAa,CAAA,CAAA,EAAI,UAAU,CAAA,CAAA,CAAA;IACxE,MAAM,SAAS,OAAO,KAAA,CAAM,OAAO,GAAG,IAAI,CAAC,OAAS,SAAS,MAAM,EAAE,CAAC,KAAK,CAAC,CAAA;IAE5E,OAAO,WAAW,IAAA,CAAK,MAAM;AACjC;AAEO,SAAS,MAAM,KAAA,EAA2B;IAC7C,OAAO,MAAM,MAAA,CAAO,CAAC,KAAK,OAAS,MAAM,KAAK,QAAA,CAAS,EAAE,EAAE,QAAA,CAAS,GAAG,GAAG,GAAG,EAAE;AACnF;AAGO,MAAM,QAAQ;AAGd,MAAM,UAAU"}},
    {"offset": {"line": 300, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/bcs/src/uleb.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebEncode(num: number): number[] {\n    const arr = [];\n    let len = 0;\n\n    if (num === 0) {\n        return [0];\n    }\n\n    while (num > 0) {\n        arr[len] = num & 0x7f;\n        if ((num >>= 7)) {\n            arr[len] |= 0x80;\n        }\n        len += 1;\n    }\n\n    return arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebDecode(arr: number[] | Uint8Array): {\n    value: number;\n    length: number;\n} {\n    let total = 0;\n    let shift = 0;\n    let len = 0;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const byte = arr[len];\n        len += 1;\n        total |= (byte & 0x7f) << shift;\n        if ((byte & 0x80) === 0) {\n            break;\n        }\n        shift += 7;\n    }\n\n    return {\n        value: total,\n        length: len,\n    };\n}\n"],"names":[],"mappings":";;;;;;AAMO,SAAS,WAAW,GAAA,EAAuB;IAC9C,MAAM,MAAM,CAAC,CAAA;IACb,IAAI,MAAM;IAEV,IAAI,QAAQ,GAAG;QACX,OAAO;YAAC,CAAC;SAAA;IACb;IAEA,MAAO,MAAM,EAAG;QACZ,GAAA,CAAI,GAAG,CAAA,GAAI,MAAM;QACjB,IAAK,QAAQ,GAAI;YACb,GAAA,CAAI,GAAG,CAAA,IAAK;QAChB;QACA,OAAO;IACX;IAEA,OAAO;AACX;AAIO,SAAS,WAAW,GAAA,EAGzB;IACE,IAAI,QAAQ;IACZ,IAAI,QAAQ;IACZ,IAAI,MAAM;IAGV,MAAO,KAAM;QACT,MAAM,OAAO,GAAA,CAAI,GAAG,CAAA;QACpB,OAAO;QACP,SAAA,CAAU,OAAO,GAAA,KAAS;QAC1B,IAAA,CAAK,OAAO,GAAA,MAAU,GAAG;YACrB;QACJ;QACA,SAAS;IACb;IAEA,OAAO;QACH,OAAO;QACP,QAAQ;IACZ;AACJ"}},
    {"offset": {"line": 347, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/bcs/src/reader.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n    private dataView: DataView;\n    private bytePosition: number = 0;\n\n    /**\n     * @param {Uint8Array} data Data to use as a buffer.\n     */\n    constructor(data: Uint8Array) {\n        this.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    }\n    /**\n     * Shift current cursor position by `bytes`.\n     *\n     * @param {Number} bytes Number of bytes to\n     * @returns {this} Self for possible chaining.\n     */\n    shift(bytes: number) {\n        this.bytePosition += bytes;\n        return this;\n    }\n    /**\n     * Read U8 value from the buffer and shift cursor by 1.\n     * @returns\n     */\n    read8(): number {\n        const value = this.dataView.getUint8(this.bytePosition);\n        this.shift(1);\n        return value;\n    }\n    /**\n     * Read U16 value from the buffer and shift cursor by 2.\n     * @returns\n     */\n    read16(): number {\n        const value = this.dataView.getUint16(this.bytePosition, true);\n        this.shift(2);\n        return value;\n    }\n    /**\n     * Read U32 value from the buffer and shift cursor by 4.\n     * @returns\n     */\n    read32(): number {\n        const value = this.dataView.getUint32(this.bytePosition, true);\n        this.shift(4);\n        return value;\n    }\n    /**\n     * Read U64 value from the buffer and shift cursor by 8.\n     * @returns\n     */\n    read64(): string {\n        const value1 = this.read32();\n        const value2 = this.read32();\n\n        const result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n        return BigInt('0x' + result).toString(10);\n    }\n    /**\n     * Read U128 value from the buffer and shift cursor by 16.\n     */\n    read128(): string {\n        const value1 = BigInt(this.read64());\n        const value2 = BigInt(this.read64());\n        const result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n        return BigInt('0x' + result).toString(10);\n    }\n    /**\n     * Read U128 value from the buffer and shift cursor by 32.\n     * @returns\n     */\n    read256(): string {\n        const value1 = BigInt(this.read128());\n        const value2 = BigInt(this.read128());\n        const result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n        return BigInt('0x' + result).toString(10);\n    }\n    /**\n     * Read `num` number of bytes from the buffer and shift cursor by `num`.\n     * @param num Number of bytes to read.\n     */\n    readBytes(num: number): Uint8Array {\n        const start = this.bytePosition + this.dataView.byteOffset;\n        const value = new Uint8Array(this.dataView.buffer, start, num);\n\n        this.shift(num);\n\n        return value;\n    }\n    /**\n     * Read ULEB value - an integer of varying size. Used for enum indexes and\n     * vector lengths.\n     * @returns {Number} The ULEB value.\n     */\n    readULEB(): number {\n        const start = this.bytePosition + this.dataView.byteOffset;\n        const buffer = new Uint8Array(this.dataView.buffer, start);\n        const { value, length } = ulebDecode(buffer);\n\n        this.shift(length);\n\n        return value;\n    }\n    /**\n     * Read a BCS vector: read a length and then apply function `cb` X times\n     * where X is the length of the vector, defined as ULEB in BCS bytes.\n     * @param cb Callback to process elements of vector.\n     * @returns {Array<Any>} Array of the resulting values, returned by callback.\n     */\n    readVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n        const length = this.readULEB();\n        const result = [];\n        for (let i = 0; i < length; i++) {\n            result.push(cb(this, i, length));\n        }\n        return result;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 459, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/bcs/src/utils.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, toBase58 } from './b58.js';\nimport { fromBase64, toBase64 } from './b64.js';\nimport { fromHex, toHex } from './hex.js';\nimport type { Encoding } from './types.js';\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n    switch (encoding) {\n        case 'base58':\n            return toBase58(data);\n        case 'base64':\n            return toBase64(data);\n        case 'hex':\n            return toHex(data);\n        default:\n            throw new Error('Unsupported encoding, supported values are: base64, hex');\n    }\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n    switch (encoding) {\n        case 'base58':\n            return fromBase58(data);\n        case 'base64':\n            return fromBase64(data);\n        case 'hex':\n            return fromHex(data);\n        default:\n            throw new Error('Unsupported encoding, supported values are: base64, hex');\n    }\n}\n\nexport function splitGenericParameters(\n    str: string,\n    genericSeparators: [string, string] = ['<', '>'],\n) {\n    const [left, right] = genericSeparators;\n    const tok = [];\n    let word = '';\n    let nestedAngleBrackets = 0;\n\n    for (let i = 0; i < str.length; i++) {\n        const char = str[i];\n        if (char === left) {\n            nestedAngleBrackets++;\n        }\n        if (char === right) {\n            nestedAngleBrackets--;\n        }\n        if (nestedAngleBrackets === 0 && char === ',') {\n            tok.push(word.trim());\n            word = '';\n            continue;\n        }\n        word += char;\n    }\n\n    tok.push(word.trim());\n\n    return tok;\n}\n"],"names":[],"mappings":";;;;;;;;AAIA,SAAS,YAAY,gBAAgB;AACrC,SAAS,YAAY,gBAAgB;AACrC,SAAS,SAAS,aAAa;;;;AAUxB,SAAS,UAAU,IAAA,EAAkB,QAAA,EAA4B;IACpE,OAAQ,UAAU;QACd,KAAK;YACD,WAAO,kKAAA,EAAS,IAAI;QACxB,KAAK;YACD,WAAO,kKAAA,EAAS,IAAI;QACxB,KAAK;YACD,WAAO,+JAAA,EAAM,IAAI;QACrB;YACI,MAAM,IAAI,MAAM,yDAAyD;IACjF;AACJ;AASO,SAAS,UAAU,IAAA,EAAc,QAAA,EAAgC;IACpE,OAAQ,UAAU;QACd,KAAK;YACD,WAAO,oKAAA,EAAW,IAAI;QAC1B,KAAK;YACD,WAAO,oKAAA,EAAW,IAAI;QAC1B,KAAK;YACD,WAAO,iKAAA,EAAQ,IAAI;QACvB;YACI,MAAM,IAAI,MAAM,yDAAyD;IACjF;AACJ;AAEO,SAAS,uBACZ,GAAA,EACA,oBAAsC;IAAC;IAAK,GAAG;CAAA,EACjD;IACE,MAAM,CAAC,MAAM,KAAK,CAAA,GAAI;IACtB,MAAM,MAAM,CAAC,CAAA;IACb,IAAI,OAAO;IACX,IAAI,sBAAsB;IAE1B,IAAA,IAAS,IAAI,GAAG,IAAI,IAAI,MAAA,EAAQ,IAAK;QACjC,MAAM,OAAO,GAAA,CAAI,CAAC,CAAA;QAClB,IAAI,SAAS,MAAM;YACf;QACJ;QACA,IAAI,SAAS,OAAO;YAChB;QACJ;QACA,IAAI,wBAAwB,KAAK,SAAS,KAAK;YAC3C,IAAI,IAAA,CAAK,KAAK,IAAA,CAAK,CAAC;YACpB,OAAO;YACP;QACJ;QACA,QAAQ;IACZ;IAEA,IAAI,IAAA,CAAK,KAAK,IAAA,CAAK,CAAC;IAEpB,OAAO;AACX"}},
    {"offset": {"line": 529, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/bcs/src/writer.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Encoding } from './types.js';\nimport { ulebEncode } from './uleb.js';\nimport { encodeStr } from './utils.js';\n\nexport interface BcsWriterOptions {\n    /** The initial size (in bytes) of the buffer that will be allocated */\n    initialSize?: number;\n    /** The maximum size (in bytes) that the buffer is allowed to grow to */\n    maxSize?: number;\n    /** The amount of bytes that will be allocated whenever additional memory is required */\n    allocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n    private dataView: DataView;\n    private bytePosition: number = 0;\n    private size: number;\n    private maxSize: number;\n    private allocateSize: number;\n\n    constructor({\n        initialSize = 1024,\n        maxSize = Infinity,\n        allocateSize = 1024,\n    }: BcsWriterOptions = {}) {\n        this.size = initialSize;\n        this.maxSize = maxSize;\n        this.allocateSize = allocateSize;\n        this.dataView = new DataView(new ArrayBuffer(initialSize));\n    }\n\n    private ensureSizeOrGrow(bytes: number) {\n        const requiredSize = this.bytePosition + bytes;\n        if (requiredSize > this.size) {\n            const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n            if (requiredSize > nextSize) {\n                throw new Error(\n                    `SizeLimitExceeded: Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n                );\n            }\n\n            this.size = nextSize;\n            const nextBuffer = new ArrayBuffer(this.size);\n            new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n            this.dataView = new DataView(nextBuffer);\n        }\n    }\n\n    /**\n     * Shift current cursor position by `bytes`.\n     *\n     * @param {Number} bytes Number of bytes to\n     * @returns {this} Self for possible chaining.\n     */\n    shift(bytes: number): this {\n        this.bytePosition += bytes;\n        return this;\n    }\n    /**\n     * Write a U8 value into a buffer and shift cursor position by 1.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    write8(value: number | bigint): this {\n        this.ensureSizeOrGrow(1);\n        this.dataView.setUint8(this.bytePosition, Number(value));\n        return this.shift(1);\n    }\n    /**\n     * Write a U16 value into a buffer and shift cursor position by 2.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    write16(value: number | bigint): this {\n        this.ensureSizeOrGrow(2);\n        this.dataView.setUint16(this.bytePosition, Number(value), true);\n        return this.shift(2);\n    }\n    /**\n     * Write a U32 value into a buffer and shift cursor position by 4.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    write32(value: number | bigint): this {\n        this.ensureSizeOrGrow(4);\n        this.dataView.setUint32(this.bytePosition, Number(value), true);\n        return this.shift(4);\n    }\n    /**\n     * Write a U64 value into a buffer and shift cursor position by 8.\n     * @param {bigint} value Value to write.\n     * @returns {this}\n     */\n    write64(value: number | bigint): this {\n        toLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n        return this;\n    }\n    /**\n     * Write a U128 value into a buffer and shift cursor position by 16.\n     *\n     * @param {bigint} value Value to write.\n     * @returns {this}\n     */\n    write128(value: number | bigint): this {\n        toLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n        return this;\n    }\n    /**\n     * Write a U256 value into a buffer and shift cursor position by 16.\n     *\n     * @param {bigint} value Value to write.\n     * @returns {this}\n     */\n    write256(value: number | bigint): this {\n        toLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n        return this;\n    }\n    /**\n     * Write a ULEB value into a buffer and shift cursor position by number of bytes\n     * written.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    writeULEB(value: number): this {\n        ulebEncode(value).forEach((el) => this.write8(el));\n        return this;\n    }\n    /**\n     * Write a vector into a buffer by first writing the vector length and then calling\n     * a callback on each passed value.\n     *\n     * @param {Array<Any>} vector Array of elements to write.\n     * @param {WriteVecCb} cb Callback to call on each element of the vector.\n     * @returns {this}\n     */\n    writeVec(\n        vector: any[],\n        cb: (writer: BcsWriter, el: any, i: number, len: number) => void,\n    ): this {\n        this.writeULEB(vector.length);\n        Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n        return this;\n    }\n\n    /**\n     * Adds support for iterations over the object.\n     * @returns {Uint8Array}\n     */\n    *[Symbol.iterator](): Iterator<number, Iterable<number>> {\n        for (let i = 0; i < this.bytePosition; i++) {\n            yield this.dataView.getUint8(i);\n        }\n        return this.toBytes();\n    }\n\n    /**\n     * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n     * @returns {Uint8Array} Resulting bcs.\n     */\n    toBytes(): Uint8Array {\n        return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n    }\n\n    /**\n     * Represent data as 'hex' or 'base64'\n     * @param encoding Encoding to use: 'base64' or 'hex'\n     */\n    toString(encoding: Encoding): string {\n        return encodeStr(this.toBytes(), encoding);\n    }\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n    const result = new Uint8Array(size);\n    let i = 0;\n    while (bigint > 0) {\n        result[i] = Number(bigint % BigInt(256));\n        bigint = bigint / BigInt(256);\n        i += 1;\n    }\n    return result;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 679, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/bcs/src/bcs-type.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, toBase58 } from './b58.js';\nimport { fromBase64, toBase64 } from './b64.js';\nimport { fromHex, toHex } from './hex.js';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\n\nexport interface BcsTypeOptions<T, Input = T> {\n    name?: string;\n    validate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n    $inferType!: T;\n    $inferInput!: Input;\n    name: string;\n    read: (reader: BcsReader) => T;\n    serializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n    validate: (value: Input) => void;\n    #write: (value: Input, writer: BcsWriter) => void;\n    #serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n    constructor(\n        options: {\n            name: string;\n            read: (reader: BcsReader) => T;\n            write: (value: Input, writer: BcsWriter) => void;\n            serialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n            serializedSize?: (value: Input) => number | null;\n            validate?: (value: Input) => void;\n        } & BcsTypeOptions<T, Input>,\n    ) {\n        this.name = options.name;\n        this.read = options.read;\n        this.serializedSize = options.serializedSize ?? (() => null);\n        this.#write = options.write;\n        this.#serialize =\n            options.serialize ??\n            ((value, options) => {\n                const writer = new BcsWriter({\n                    initialSize: this.serializedSize(value) ?? undefined,\n                    ...options,\n                });\n                this.#write(value, writer);\n                return writer.toBytes();\n            });\n\n        this.validate = options.validate ?? (() => {});\n    }\n\n    write(value: Input, writer: BcsWriter) {\n        this.validate(value);\n        this.#write(value, writer);\n    }\n\n    serialize(value: Input, options?: BcsWriterOptions) {\n        this.validate(value);\n        return new SerializedBcs(this, this.#serialize(value, options));\n    }\n\n    parse(bytes: Uint8Array): T {\n        const reader = new BcsReader(bytes);\n        return this.read(reader);\n    }\n\n    fromHex(hex: string) {\n        return this.parse(fromHex(hex));\n    }\n\n    fromBase58(b64: string) {\n        return this.parse(fromBase58(b64));\n    }\n\n    fromBase64(b64: string) {\n        return this.parse(fromBase64(b64));\n    }\n\n    transform<T2 = T, Input2 = Input>({\n        name,\n        input,\n        output,\n        validate,\n    }: {\n        input?: (val: Input2) => Input;\n        output?: (value: T) => T2;\n    } & BcsTypeOptions<T2, Input2>) {\n        return new BcsType<T2, Input2>({\n            name: name ?? this.name,\n            read: (reader) => (output ? output(this.read(reader)) : (this.read(reader) as never)),\n            write: (value, writer) => this.#write(input ? input(value) : (value as never), writer),\n            serializedSize: (value) => this.serializedSize(input ? input(value) : (value as never)),\n            serialize: (value, options) =>\n                this.#serialize(input ? input(value) : (value as never), options),\n            validate: (value) => {\n                validate?.(value);\n                this.validate(input ? input(value) : (value as never));\n            },\n        });\n    }\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@iota/serialized-bcs') as never;\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n    return !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n    #schema: BcsType<T, Input>;\n    #bytes: Uint8Array;\n\n    // Used to brand SerializedBcs so that they can be identified, even between multiple copies\n    // of the @iota/bcs package are installed\n    get [SERIALIZED_BCS_BRAND]() {\n        return true;\n    }\n\n    constructor(type: BcsType<T, Input>, schema: Uint8Array) {\n        this.#schema = type;\n        this.#bytes = schema;\n    }\n\n    toBytes() {\n        return this.#bytes;\n    }\n\n    toHex() {\n        return toHex(this.#bytes);\n    }\n\n    toBase64() {\n        return toBase64(this.#bytes);\n    }\n\n    toBase58() {\n        return toBase58(this.#bytes);\n    }\n\n    parse() {\n        return this.#schema.parse(this.#bytes);\n    }\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n    size,\n    ...options\n}: {\n    name: string;\n    size: number;\n    read: (reader: BcsReader) => T;\n    write: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n    return new BcsType<T, Input>({\n        ...options,\n        serializedSize: () => size,\n    });\n}\n\nexport function uIntBcsType({\n    readMethod,\n    writeMethod,\n    ...options\n}: {\n    name: string;\n    size: number;\n    readMethod: `read${8 | 16 | 32}`;\n    writeMethod: `write${8 | 16 | 32}`;\n    maxValue: number;\n} & BcsTypeOptions<number, number>) {\n    return fixedSizeBcsType<number>({\n        ...options,\n        read: (reader) => reader[readMethod](),\n        write: (value, writer) => writer[writeMethod](value),\n        validate: (value) => {\n            if (value < 0 || value > options.maxValue) {\n                throw new TypeError(\n                    `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n                );\n            }\n            options.validate?.(value);\n        },\n    });\n}\n\nexport function bigUIntBcsType({\n    readMethod,\n    writeMethod,\n    ...options\n}: {\n    name: string;\n    size: number;\n    readMethod: `read${64 | 128 | 256}`;\n    writeMethod: `write${64 | 128 | 256}`;\n    maxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n    return fixedSizeBcsType<string, string | number | bigint>({\n        ...options,\n        read: (reader) => reader[readMethod](),\n        write: (value, writer) => writer[writeMethod](BigInt(value)),\n        validate: (val) => {\n            const value = BigInt(val);\n            if (value < 0 || value > options.maxValue) {\n                throw new TypeError(\n                    `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n                );\n            }\n            options.validate?.(value);\n        },\n    });\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n    serialize,\n    ...options\n}: {\n    name: string;\n    read: (reader: BcsReader) => T;\n    serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n    const type = new BcsType<T, Input>({\n        ...options,\n        serialize,\n        write: (value, writer) => {\n            for (const byte of type.serialize(value).toBytes()) {\n                writer.write8(byte);\n            }\n        },\n    });\n\n    return type;\n}\n\nexport function stringLikeBcsType({\n    toBytes,\n    fromBytes,\n    ...options\n}: {\n    name: string;\n    toBytes: (value: string) => Uint8Array;\n    fromBytes: (bytes: Uint8Array) => string;\n    serializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n    return new BcsType<string>({\n        ...options,\n        read: (reader) => {\n            const length = reader.readULEB();\n            const bytes = reader.readBytes(length);\n\n            return fromBytes(bytes);\n        },\n        write: (hex, writer) => {\n            const bytes = toBytes(hex);\n            writer.writeULEB(bytes.length);\n            for (let i = 0; i < bytes.length; i++) {\n                writer.write8(bytes[i]);\n            }\n        },\n        serialize: (value) => {\n            const bytes = toBytes(value);\n            const size = ulebEncode(bytes.length);\n            const result = new Uint8Array(size.length + bytes.length);\n            result.set(size, 0);\n            result.set(bytes, size.length);\n\n            return result;\n        },\n        validate: (value) => {\n            if (typeof value !== 'string') {\n                throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n            }\n            options.validate?.(value);\n        },\n    });\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n    let lazyType: BcsType<T, Input> | null = null;\n    function getType() {\n        if (!lazyType) {\n            lazyType = cb();\n        }\n        return lazyType;\n    }\n\n    return new BcsType<T, Input>({\n        name: 'lazy' as never,\n        read: (data) => getType().read(data),\n        serializedSize: (value) => getType().serializedSize(value),\n        write: (value, writer) => getType().write(value, writer),\n        serialize: (value, options) => getType().serialize(value, options).toBytes(),\n    });\n}\n"],"names":["options"],"mappings":";;;;;;;;;;;;;;;;;;;;AAIA,SAAS,YAAY,gBAAgB;AACrC,SAAS,YAAY,gBAAgB;AACrC,SAAS,SAAS,aAAa;AAC/B,SAAS,iBAAiB;AAC1B,SAAS,kBAAkB;AAE3B,SAAS,iBAAiB;;;;;;;;AAV1B,IAAA,QAAA,YAAA,SAAA;;;;;;;AAiBO,MAAM,WAAN,MAAM,SAAsB;IAU/B,YACI,OAAA,CAQF;QAZF,aAAA,IAAA,EAAA;QACA,aAAA,IAAA,EAAA;QAYI,IAAA,CAAK,IAAA,GAAO,QAAQ,IAAA;QACpB,IAAA,CAAK,IAAA,GAAO,QAAQ,IAAA;QACpB,IAAA,CAAK,cAAA,GAAiB,QAAQ,cAAA,IAAA,CAAmB,IAAM,IAAA;QACvD,aAAA,IAAA,EAAK,QAAS,QAAQ,KAAA;QACtB,aAAA,IAAA,EAAK,YACD,QAAQ,SAAA,IAAA,CACP,CAAC,OAAOA,aAAY;YACjB,MAAM,SAAS,IAAI,sKAAA,CAAU;gBACzB,aAAa,IAAA,CAAK,cAAA,CAAe,KAAK,KAAK,KAAA;gBAC3C,GAAGA,QAAAA;YACP,CAAC;YACD,aAAA,IAAA,EAAK,QAAL,IAAA,CAAA,IAAA,EAAY,OAAO;YACnB,OAAO,OAAO,OAAA,CAAQ;QAC1B,CAAA;QAEJ,IAAA,CAAK,QAAA,GAAW,QAAQ,QAAA,IAAA,CAAa,KAAO,CAAD,AAAC;IAChD;IAEA,MAAM,KAAA,EAAc,MAAA,EAAmB;QACnC,IAAA,CAAK,QAAA,CAAS,KAAK;QACnB,aAAA,IAAA,EAAK,QAAL,IAAA,CAAA,IAAA,EAAY,OAAO;IACvB;IAEA,UAAU,KAAA,EAAc,OAAA,EAA4B;QAChD,IAAA,CAAK,QAAA,CAAS,KAAK;QACnB,OAAO,IAAI,cAAc,IAAA,EAAM,aAAA,IAAA,EAAK,YAAL,IAAA,CAAA,IAAA,EAAgB,OAAO,QAAQ;IAClE;IAEA,MAAM,KAAA,EAAsB;QACxB,MAAM,SAAS,IAAI,sKAAA,CAAU,KAAK;QAClC,OAAO,IAAA,CAAK,IAAA,CAAK,MAAM;IAC3B;IAEA,QAAQ,GAAA,EAAa;QACjB,OAAO,IAAA,CAAK,KAAA,KAAM,iKAAA,EAAQ,GAAG,CAAC;IAClC;IAEA,WAAW,GAAA,EAAa;QACpB,OAAO,IAAA,CAAK,KAAA,KAAM,oKAAA,EAAW,GAAG,CAAC;IACrC;IAEA,WAAW,GAAA,EAAa;QACpB,OAAO,IAAA,CAAK,KAAA,CAAM,wKAAA,EAAW,GAAG,CAAC;IACrC;IAEA,UAAkC,EAC9B,IAAA,EACA,KAAA,EACA,MAAA,EACA,QAAA,EACJ,EAGgC;QAC5B,OAAO,IAAI,SAAoB;YAC3B,MAAM,QAAQ,IAAA,CAAK,IAAA;YACnB,MAAM,CAAC,SAAY,SAAS,OAAO,IAAA,CAAK,IAAA,CAAK,MAAM,CAAC,IAAK,IAAA,CAAK,IAAA,CAAK,MAAM;YACzE,OAAO,CAAC,OAAO,SAAW,aAAA,IAAA,EAAK,QAAL,IAAA,CAAA,IAAA,EAAY,QAAQ,MAAM,KAAK,IAAK,OAAiB;YAC/E,gBAAgB,CAAC,QAAU,IAAA,CAAK,cAAA,CAAe,QAAQ,MAAM,KAAK,IAAK,KAAe;YACtF,WAAW,CAAC,OAAO,UACf,aAAA,IAAA,EAAK,YAAL,IAAA,CAAA,IAAA,EAAgB,QAAQ,MAAM,KAAK,IAAK,OAAiB;YAC7D,UAAU,CAAC,UAAU;gBACjB,WAAW,KAAK;gBAChB,IAAA,CAAK,QAAA,CAAS,QAAQ,MAAM,KAAK,IAAK,KAAe;YACzD;QACJ,CAAC;IACL;AACJ;AAhFI,SAAA,IAAA;AACA,aAAA,IAAA;AARG,IAAM,UAAN;AAyFP,MAAM,uBAAuB,OAAO,GAAA,CAAI,sBAAsB;AACvD,SAAS,gBAAgB,GAAA,EAA6C;IACzE,OAAO,CAAC,CAAC,OAAO,OAAO,QAAQ,YAAa,GAAA,CAAY,oBAAoB,CAAA,KAAM;AACtF;AAEO,MAAM,cAA4B;IAUrC,YAAY,IAAA,EAAyB,MAAA,CAAoB;QATzD,aAAA,IAAA,EAAA;QACA,aAAA,IAAA,EAAA;QASI,aAAA,IAAA,EAAK,SAAU;QACf,aAAA,IAAA,EAAK,QAAS;IAClB;IAAA,2FAAA;IAAA,yCAAA;IAPA,IAAA,CAAK,oBAAoB,CAAA,GAAI;QACzB,OAAO;IACX;IAOA,UAAU;QACN,OAAO,aAAA,IAAA,EAAK;IAChB;IAEA,QAAQ;QACJ,WAAO,+JAAA,EAAM,aAAA,IAAA,EAAK,OAAM;IAC5B;IAEA,WAAW;QACP,WAAO,kKAAA,EAAS,aAAA,IAAA,EAAK,OAAM;IAC/B;IAEA,WAAW;QACP,WAAO,kKAAA,EAAS,aAAA,IAAA,EAAK,OAAM;IAC/B;IAEA,QAAQ;QACJ,OAAO,aAAA,IAAA,EAAK,SAAQ,KAAA,CAAM,aAAA,IAAA,EAAK,OAAM;IACzC;AACJ;AAjCI,UAAA,IAAA;AACA,SAAA,IAAA;AAkCG,SAAS,iBAA+B,EAC3C,IAAA,EACA,GAAG,SACP,EAK8B;IAC1B,OAAO,IAAI,QAAkB;QACzB,GAAG,OAAA;QACH,gBAAgB,IAAM;IAC1B,CAAC;AACL;AAEO,SAAS,YAAY,EACxB,UAAA,EACA,WAAA,EACA,GAAG,SACP,EAMoC;IAChC,OAAO,iBAAyB;QAC5B,GAAG,OAAA;QACH,MAAM,CAAC,SAAW,MAAA,CAAO,UAAU,CAAA,CAAE;QACrC,OAAO,CAAC,OAAO,SAAW,MAAA,CAAO,WAAW,CAAA,CAAE,KAAK;QACnD,UAAU,CAAC,UAAU;YACjB,IAAI,QAAQ,KAAK,QAAQ,QAAQ,QAAA,EAAU;gBACvC,MAAM,IAAI,UACN,CAAA,QAAA,EAAW,QAAQ,IAAI,CAAA,QAAA,EAAW,KAAK,CAAA,4BAAA,EAA+B,QAAQ,QAAQ,EAAA;YAE9F;YACA,QAAQ,QAAA,GAAW,KAAK;QAC5B;IACJ,CAAC;AACL;AAEO,SAAS,eAAe,EAC3B,UAAA,EACA,WAAA,EACA,GAAG,SACP,EAMsD;IAClD,OAAO,iBAAmD;QACtD,GAAG,OAAA;QACH,MAAM,CAAC,SAAW,MAAA,CAAO,UAAU,CAAA,CAAE;QACrC,OAAO,CAAC,OAAO,SAAW,MAAA,CAAO,WAAW,CAAA,CAAE,OAAO,KAAK,CAAC;QAC3D,UAAU,CAAC,QAAQ;YACf,MAAM,QAAQ,OAAO,GAAG;YACxB,IAAI,QAAQ,KAAK,QAAQ,QAAQ,QAAA,EAAU;gBACvC,MAAM,IAAI,UACN,CAAA,QAAA,EAAW,QAAQ,IAAI,CAAA,QAAA,EAAW,KAAK,CAAA,4BAAA,EAA+B,QAAQ,QAAQ,EAAA;YAE9F;YACA,QAAQ,QAAA,GAAW,KAAK;QAC5B;IACJ,CAAC;AACL;AAEO,SAAS,mBAAiC,EAC7C,SAAA,EACA,GAAG,SACP,EAI8B;IAC1B,MAAM,OAAO,IAAI,QAAkB;QAC/B,GAAG,OAAA;QACH;QACA,OAAO,CAAC,OAAO,WAAW;YACtB,KAAA,MAAW,QAAQ,KAAK,SAAA,CAAU,KAAK,EAAE,OAAA,CAAQ,EAAG;gBAChD,OAAO,MAAA,CAAO,IAAI;YACtB;QACJ;IACJ,CAAC;IAED,OAAO;AACX;AAEO,SAAS,kBAAkB,EAC9B,OAAA,EACA,SAAA,EACA,GAAG,SACP,EAK4B;IACxB,OAAO,IAAI,QAAgB;QACvB,GAAG,OAAA;QACH,MAAM,CAAC,WAAW;YACd,MAAM,SAAS,OAAO,QAAA,CAAS;YAC/B,MAAM,QAAQ,OAAO,SAAA,CAAU,MAAM;YAErC,OAAO,UAAU,KAAK;QAC1B;QACA,OAAO,CAAC,KAAK,WAAW;YACpB,MAAM,QAAQ,QAAQ,GAAG;YACzB,OAAO,SAAA,CAAU,MAAM,MAAM;YAC7B,IAAA,IAAS,IAAI,GAAG,IAAI,MAAM,MAAA,EAAQ,IAAK;gBACnC,OAAO,MAAA,CAAO,KAAA,CAAM,CAAC,CAAC;YAC1B;QACJ;QACA,WAAW,CAAC,UAAU;YAClB,MAAM,QAAQ,QAAQ,KAAK;YAC3B,MAAM,WAAO,qKAAA,EAAW,MAAM,MAAM;YACpC,MAAM,SAAS,IAAI,WAAW,KAAK,MAAA,GAAS,MAAM,MAAM;YACxD,OAAO,GAAA,CAAI,MAAM,CAAC;YAClB,OAAO,GAAA,CAAI,OAAO,KAAK,MAAM;YAE7B,OAAO;QACX;QACA,UAAU,CAAC,UAAU;YACjB,IAAI,OAAO,UAAU,UAAU;gBAC3B,MAAM,IAAI,UAAU,CAAA,QAAA,EAAW,QAAQ,IAAI,CAAA,QAAA,EAAW,KAAK,CAAA,iBAAA,CAAmB;YAClF;YACA,QAAQ,QAAA,GAAW,KAAK;QAC5B;IACJ,CAAC;AACL;AAEO,SAAS,YAAsB,EAAA,EAA6B;IAC/D,IAAI,WAAqC;IACzC,SAAS,UAAU;QACf,IAAI,CAAC,UAAU;YACX,WAAW,GAAG;QAClB;QACA,OAAO;IACX;IAEA,OAAO,IAAI,QAAkB;QACzB,MAAM;QACN,MAAM,CAAC,OAAS,QAAQ,EAAE,IAAA,CAAK,IAAI;QACnC,gBAAgB,CAAC,QAAU,QAAQ,EAAE,cAAA,CAAe,KAAK;QACzD,OAAO,CAAC,OAAO,SAAW,QAAQ,EAAE,KAAA,CAAM,OAAO,MAAM;QACvD,WAAW,CAAC,OAAO,UAAY,QAAQ,EAAE,SAAA,CAAU,OAAO,OAAO,EAAE,OAAA,CAAQ;IAC/E,CAAC;AACL"}},
    {"offset": {"line": 907, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/bcs/src/bcs.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n    BcsType,\n    bigUIntBcsType,\n    dynamicSizeBcsType,\n    fixedSizeBcsType,\n    lazyBcsType,\n    stringLikeBcsType,\n    uIntBcsType,\n} from './bcs-type.js';\nimport type { EnumInputShape, EnumOutputShape } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n    /**\n     * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n     * @example\n     * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n     */\n    u8(options?: BcsTypeOptions<number>) {\n        return uIntBcsType({\n            name: 'u8',\n            readMethod: 'read8',\n            writeMethod: 'write8',\n            size: 1,\n            maxValue: 2 ** 8 - 1,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n     * @example\n     * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n     */\n    u16(options?: BcsTypeOptions<number>) {\n        return uIntBcsType({\n            name: 'u16',\n            readMethod: 'read16',\n            writeMethod: 'write16',\n            size: 2,\n            maxValue: 2 ** 16 - 1,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n     * @example\n     * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n     */\n    u32(options?: BcsTypeOptions<number>) {\n        return uIntBcsType({\n            name: 'u32',\n            readMethod: 'read32',\n            writeMethod: 'write32',\n            size: 4,\n            maxValue: 2 ** 32 - 1,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n     * @example\n     * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n     */\n    u64(options?: BcsTypeOptions<string, number | bigint | string>) {\n        return bigUIntBcsType({\n            name: 'u64',\n            readMethod: 'read64',\n            writeMethod: 'write64',\n            size: 8,\n            maxValue: 2n ** 64n - 1n,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n     * @example\n     * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n     */\n    u128(options?: BcsTypeOptions<string, number | bigint | string>) {\n        return bigUIntBcsType({\n            name: 'u128',\n            readMethod: 'read128',\n            writeMethod: 'write128',\n            size: 16,\n            maxValue: 2n ** 128n - 1n,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n     * @example\n     * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n     */\n    u256(options?: BcsTypeOptions<string, number | bigint | string>) {\n        return bigUIntBcsType({\n            name: 'u256',\n            readMethod: 'read256',\n            writeMethod: 'write256',\n            size: 32,\n            maxValue: 2n ** 256n - 1n,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write boolean values.\n     * @example\n     * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n     */\n    bool(options?: BcsTypeOptions<boolean>) {\n        return fixedSizeBcsType<boolean>({\n            name: 'bool',\n            size: 1,\n            read: (reader) => reader.read8() === 1,\n            write: (value, writer) => writer.write8(value ? 1 : 0),\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (typeof value !== 'boolean') {\n                    throw new TypeError(`Expected boolean, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n     * @example\n     *\n     */\n    uleb128(options?: BcsTypeOptions<number>) {\n        return dynamicSizeBcsType<number>({\n            name: 'uleb128',\n            read: (reader) => reader.readULEB(),\n            serialize: (value) => {\n                return Uint8Array.from(ulebEncode(value));\n            },\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a fixed length byte array\n     * @param size The number of bytes this types represents\n     * @example\n     * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n     */\n    bytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n        return fixedSizeBcsType<Uint8Array>({\n            name: `bytes[${size}]`,\n            size,\n            read: (reader) => reader.readBytes(size),\n            write: (value, writer) => {\n                for (let i = 0; i < size; i++) {\n                    writer.write8(value[i] ?? 0);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== size) {\n                    throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a variable length byte array\n     *\n     * @example\n     * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n     */\n    byteVector(options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n        return new BcsType<Uint8Array, Iterable<number>>({\n            name: `bytesVector`,\n            read: (reader) => {\n                const length = reader.readULEB();\n\n                return reader.readBytes(length);\n            },\n            write: (value, writer) => {\n                const array = new Uint8Array(value);\n                writer.writeULEB(array.length);\n                for (let i = 0; i < array.length; i++) {\n                    writer.write8(array[i] ?? 0);\n                }\n            },\n            ...options,\n            serializedSize: (value) => {\n                const length = 'length' in value ? (value.length as number) : null;\n                return length == null ? null : ulebEncode(length).length + length;\n            },\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n     * @example\n     * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n     */\n    string(options?: BcsTypeOptions<string>) {\n        return stringLikeBcsType({\n            name: 'string',\n            toBytes: (value) => new TextEncoder().encode(value),\n            fromBytes: (bytes) => new TextDecoder().decode(bytes),\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that represents a fixed length array of a given type\n     * @param size The number of elements in the array\n     * @param type The BcsType of each element in the array\n     * @example\n     * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n     */\n    fixedArray<T, Input>(\n        size: number,\n        type: BcsType<T, Input>,\n        options?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n    ) {\n        return new BcsType<T[], Iterable<Input> & { length: number }>({\n            name: `${type.name}[${size}]`,\n            read: (reader) => {\n                const result: T[] = new Array(size);\n                for (let i = 0; i < size; i++) {\n                    result[i] = type.read(reader);\n                }\n                return result;\n            },\n            write: (value, writer) => {\n                for (const item of value) {\n                    type.write(item, writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== size) {\n                    throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing an optional value\n     * @param type The BcsType of the optional value\n     * @example\n     * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n     * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n     */\n    option<T, Input>(type: BcsType<T, Input>) {\n        return bcs\n            .enum(`Option<${type.name}>`, {\n                None: null,\n                Some: type,\n            })\n            .transform({\n                input: (value: Input | null | undefined) => {\n                    if (value == null) {\n                        return { None: true };\n                    }\n\n                    return { Some: value };\n                },\n                output: (value) => {\n                    if (value.$kind === 'Some') {\n                        return value.Some;\n                    }\n\n                    return null;\n                },\n            });\n    },\n\n    /**\n     * Creates a BcsType representing a variable length vector of a given type\n     * @param type The BcsType of each element in the vector\n     *\n     * @example\n     * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n     */\n    vector<T, Input>(\n        type: BcsType<T, Input>,\n        options?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n    ) {\n        return new BcsType<T[], Iterable<Input> & { length: number }>({\n            name: `vector<${type.name}>`,\n            read: (reader) => {\n                const length = reader.readULEB();\n                const result: T[] = new Array(length);\n                for (let i = 0; i < length; i++) {\n                    result[i] = type.read(reader);\n                }\n                return result;\n            },\n            write: (value, writer) => {\n                writer.writeULEB(value.length);\n                for (const item of value) {\n                    type.write(item, writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a tuple of a given set of types\n     * @param types The BcsTypes for each element in the tuple\n     *\n     * @example\n     * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n     * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n     */\n    tuple<const Types extends readonly BcsType<any>[]>(\n        types: Types,\n        options?: BcsTypeOptions<\n            {\n                -readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n            },\n            {\n                [K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n            }\n        >,\n    ) {\n        return new BcsType<\n            {\n                -readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n            },\n            {\n                [K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n            }\n        >({\n            name: `(${types.map((t) => t.name).join(', ')})`,\n            serializedSize: (values) => {\n                let total = 0;\n                for (let i = 0; i < types.length; i++) {\n                    const size = types[i].serializedSize(values[i]);\n                    if (size == null) {\n                        return null;\n                    }\n\n                    total += size;\n                }\n\n                return total;\n            },\n            read: (reader) => {\n                const result: unknown[] = [];\n                for (const type of types) {\n                    result.push(type.read(reader));\n                }\n                return result as never;\n            },\n            write: (value, writer) => {\n                for (let i = 0; i < types.length; i++) {\n                    types[i].write(value[i], writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!Array.isArray(value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== types.length) {\n                    throw new TypeError(\n                        `Expected array of length ${types.length}, found ${value.length}`,\n                    );\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a struct of a given set of fields\n     * @param name The name of the struct\n     * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n     *\n     * @example\n     * const struct = bcs.struct('MyStruct', {\n     *  a: bcs.u8(),\n     *  b: bcs.string(),\n     * })\n     * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n     */\n    struct<T extends Record<string, BcsType<any>>>(\n        name: string,\n        fields: T,\n        options?: Omit<\n            BcsTypeOptions<\n                {\n                    [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n                },\n                {\n                    [K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n                }\n            >,\n            'name'\n        >,\n    ) {\n        const canonicalOrder = Object.entries(fields);\n\n        return new BcsType<\n            {\n                [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n            },\n            {\n                [K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n            }\n        >({\n            name,\n            serializedSize: (values) => {\n                let total = 0;\n                for (const [field, type] of canonicalOrder) {\n                    const size = type.serializedSize(values[field]);\n                    if (size == null) {\n                        return null;\n                    }\n\n                    total += size;\n                }\n\n                return total;\n            },\n            read: (reader) => {\n                const result: Record<string, unknown> = {};\n                for (const [field, type] of canonicalOrder) {\n                    result[field] = type.read(reader);\n                }\n\n                return result as never;\n            },\n            write: (value, writer) => {\n                for (const [field, type] of canonicalOrder) {\n                    type.write(value[field], writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (typeof value !== 'object' || value == null) {\n                    throw new TypeError(`Expected object, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing an enum of a given set of options\n     * @param name The name of the enum\n     * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n     * null can be used to represent a variant with no data.\n     *\n     * @example\n     * const enum = bcs.enum('MyEnum', {\n     *   A: bcs.u8(),\n     *   B: bcs.string(),\n     *   C: null,\n     * })\n     * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n     * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n     * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n     */\n    enum<T extends Record<string, BcsType<any> | null>>(\n        name: string,\n        values: T,\n        options?: Omit<\n            BcsTypeOptions<\n                EnumOutputShape<{\n                    [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n                }>,\n                EnumInputShape<{\n                    [K in keyof T]: T[K] extends BcsType<any, infer U>\n                        ? U\n                        : boolean | object | null;\n                }>\n            >,\n            'name'\n        >,\n    ) {\n        const canonicalOrder = Object.entries(values as object);\n        return new BcsType<\n            EnumOutputShape<{\n                [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n            }>,\n            EnumInputShape<{\n                [K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n            }>\n        >({\n            name,\n            read: (reader) => {\n                const index = reader.readULEB();\n\n                const enumEntry = canonicalOrder[index];\n                if (!enumEntry) {\n                    throw new TypeError(`Unknown value ${index} for enum ${name}`);\n                }\n\n                const [kind, type] = enumEntry;\n\n                return {\n                    [kind]: type?.read(reader) ?? true,\n                    $kind: kind,\n                } as never;\n            },\n            write: (value, writer) => {\n                const [name, val] = Object.entries(value).filter(([name]) =>\n                    Object.hasOwn(values, name),\n                )[0];\n\n                for (let i = 0; i < canonicalOrder.length; i++) {\n                    const [optionName, optionType] = canonicalOrder[i];\n                    if (optionName === name) {\n                        writer.writeULEB(i);\n                        optionType?.write(val, writer);\n                        return;\n                    }\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (typeof value !== 'object' || value == null) {\n                    throw new TypeError(`Expected object, found ${typeof value}`);\n                }\n\n                const keys = Object.keys(value).filter(\n                    (k) => value[k] !== undefined && Object.hasOwn(values, k),\n                );\n\n                if (keys.length !== 1) {\n                    throw new TypeError(\n                        `Expected object with one key, but found ${keys.length} for type ${name}}`,\n                    );\n                }\n\n                const [variant] = keys;\n\n                if (!Object.hasOwn(values, variant)) {\n                    throw new TypeError(`Invalid enum variant ${variant}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a map of a given key and value type\n     * @param keyType The BcsType of the key\n     * @param valueType The BcsType of the value\n     * @example\n     * const map = bcs.map(bcs.u8(), bcs.string())\n     * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n     */\n    map<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n        return bcs.vector(bcs.tuple([keyType, valueType])).transform({\n            name: `Map<${keyType.name}, ${valueType.name}>`,\n            input: (value: Map<InputK, InputV>) => {\n                return [...value.entries()];\n            },\n            output: (value) => {\n                const result = new Map<K, V>();\n                for (const [key, val] of value) {\n                    result.set(key, val);\n                }\n                return result;\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n     * @param cb A callback that returns the BcsType\n     */\n    lazy<T extends BcsType<any>>(cb: () => T): T {\n        return lazyBcsType(cb) as T;\n    },\n};\n"],"names":["name"],"mappings":"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"}},
    {"offset": {"line": 1389, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/bcs/src/uleb.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebEncode(num: number): number[] {\n    const arr = [];\n    let len = 0;\n\n    if (num === 0) {\n        return [0];\n    }\n\n    while (num > 0) {\n        arr[len] = num & 0x7f;\n        if ((num >>= 7)) {\n            arr[len] |= 0x80;\n        }\n        len += 1;\n    }\n\n    return arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebDecode(arr: number[] | Uint8Array): {\n    value: number;\n    length: number;\n} {\n    let total = 0;\n    let shift = 0;\n    let len = 0;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const byte = arr[len];\n        len += 1;\n        total |= (byte & 0x7f) << shift;\n        if ((byte & 0x80) === 0) {\n            break;\n        }\n        shift += 7;\n    }\n\n    return {\n        value: total,\n        length: len,\n    };\n}\n"],"names":[],"mappings":";;;;;;AAMO,SAAS,WAAW,GAAA,EAAuB;IAC9C,MAAM,MAAM,CAAC,CAAA;IACb,IAAI,MAAM;IAEV,IAAI,QAAQ,GAAG;QACX,OAAO;YAAC,CAAC;SAAA;IACb;IAEA,MAAO,MAAM,EAAG;QACZ,GAAA,CAAI,GAAG,CAAA,GAAI,MAAM;QACjB,IAAK,QAAQ,GAAI;YACb,GAAA,CAAI,GAAG,CAAA,IAAK;QAChB;QACA,OAAO;IACX;IAEA,OAAO;AACX;AAIO,SAAS,WAAW,GAAA,EAGzB;IACE,IAAI,QAAQ;IACZ,IAAI,QAAQ;IACZ,IAAI,MAAM;IAGV,MAAO,KAAM;QACT,MAAM,OAAO,GAAA,CAAI,GAAG,CAAA;QACpB,OAAO;QACP,SAAA,CAAU,OAAO,GAAA,KAAS;QAC1B,IAAA,CAAK,OAAO,GAAA,MAAU,GAAG;YACrB;QACJ;QACA,SAAS;IACb;IAEA,OAAO;QACH,OAAO;QACP,QAAQ;IACZ;AACJ"}},
    {"offset": {"line": 1436, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/bcs/src/reader.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n    private dataView: DataView;\n    private bytePosition: number = 0;\n\n    /**\n     * @param {Uint8Array} data Data to use as a buffer.\n     */\n    constructor(data: Uint8Array) {\n        this.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    }\n    /**\n     * Shift current cursor position by `bytes`.\n     *\n     * @param {Number} bytes Number of bytes to\n     * @returns {this} Self for possible chaining.\n     */\n    shift(bytes: number) {\n        this.bytePosition += bytes;\n        return this;\n    }\n    /**\n     * Read U8 value from the buffer and shift cursor by 1.\n     * @returns\n     */\n    read8(): number {\n        const value = this.dataView.getUint8(this.bytePosition);\n        this.shift(1);\n        return value;\n    }\n    /**\n     * Read U16 value from the buffer and shift cursor by 2.\n     * @returns\n     */\n    read16(): number {\n        const value = this.dataView.getUint16(this.bytePosition, true);\n        this.shift(2);\n        return value;\n    }\n    /**\n     * Read U32 value from the buffer and shift cursor by 4.\n     * @returns\n     */\n    read32(): number {\n        const value = this.dataView.getUint32(this.bytePosition, true);\n        this.shift(4);\n        return value;\n    }\n    /**\n     * Read U64 value from the buffer and shift cursor by 8.\n     * @returns\n     */\n    read64(): string {\n        const value1 = this.read32();\n        const value2 = this.read32();\n\n        const result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n        return BigInt('0x' + result).toString(10);\n    }\n    /**\n     * Read U128 value from the buffer and shift cursor by 16.\n     */\n    read128(): string {\n        const value1 = BigInt(this.read64());\n        const value2 = BigInt(this.read64());\n        const result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n        return BigInt('0x' + result).toString(10);\n    }\n    /**\n     * Read U128 value from the buffer and shift cursor by 32.\n     * @returns\n     */\n    read256(): string {\n        const value1 = BigInt(this.read128());\n        const value2 = BigInt(this.read128());\n        const result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n        return BigInt('0x' + result).toString(10);\n    }\n    /**\n     * Read `num` number of bytes from the buffer and shift cursor by `num`.\n     * @param num Number of bytes to read.\n     */\n    readBytes(num: number): Uint8Array {\n        const start = this.bytePosition + this.dataView.byteOffset;\n        const value = new Uint8Array(this.dataView.buffer, start, num);\n\n        this.shift(num);\n\n        return value;\n    }\n    /**\n     * Read ULEB value - an integer of varying size. Used for enum indexes and\n     * vector lengths.\n     * @returns {Number} The ULEB value.\n     */\n    readULEB(): number {\n        const start = this.bytePosition + this.dataView.byteOffset;\n        const buffer = new Uint8Array(this.dataView.buffer, start);\n        const { value, length } = ulebDecode(buffer);\n\n        this.shift(length);\n\n        return value;\n    }\n    /**\n     * Read a BCS vector: read a length and then apply function `cb` X times\n     * where X is the length of the vector, defined as ULEB in BCS bytes.\n     * @param cb Callback to process elements of vector.\n     * @returns {Array<Any>} Array of the resulting values, returned by callback.\n     */\n    readVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n        const length = this.readULEB();\n        const result = [];\n        for (let i = 0; i < length; i++) {\n            result.push(cb(this, i, length));\n        }\n        return result;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1548, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/bcs/src/writer.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Encoding } from './types.js';\nimport { ulebEncode } from './uleb.js';\nimport { encodeStr } from './utils.js';\n\nexport interface BcsWriterOptions {\n    /** The initial size (in bytes) of the buffer that will be allocated */\n    initialSize?: number;\n    /** The maximum size (in bytes) that the buffer is allowed to grow to */\n    maxSize?: number;\n    /** The amount of bytes that will be allocated whenever additional memory is required */\n    allocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n    private dataView: DataView;\n    private bytePosition: number = 0;\n    private size: number;\n    private maxSize: number;\n    private allocateSize: number;\n\n    constructor({\n        initialSize = 1024,\n        maxSize = Infinity,\n        allocateSize = 1024,\n    }: BcsWriterOptions = {}) {\n        this.size = initialSize;\n        this.maxSize = maxSize;\n        this.allocateSize = allocateSize;\n        this.dataView = new DataView(new ArrayBuffer(initialSize));\n    }\n\n    private ensureSizeOrGrow(bytes: number) {\n        const requiredSize = this.bytePosition + bytes;\n        if (requiredSize > this.size) {\n            const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n            if (requiredSize > nextSize) {\n                throw new Error(\n                    `SizeLimitExceeded: Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n                );\n            }\n\n            this.size = nextSize;\n            const nextBuffer = new ArrayBuffer(this.size);\n            new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n            this.dataView = new DataView(nextBuffer);\n        }\n    }\n\n    /**\n     * Shift current cursor position by `bytes`.\n     *\n     * @param {Number} bytes Number of bytes to\n     * @returns {this} Self for possible chaining.\n     */\n    shift(bytes: number): this {\n        this.bytePosition += bytes;\n        return this;\n    }\n    /**\n     * Write a U8 value into a buffer and shift cursor position by 1.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    write8(value: number | bigint): this {\n        this.ensureSizeOrGrow(1);\n        this.dataView.setUint8(this.bytePosition, Number(value));\n        return this.shift(1);\n    }\n    /**\n     * Write a U16 value into a buffer and shift cursor position by 2.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    write16(value: number | bigint): this {\n        this.ensureSizeOrGrow(2);\n        this.dataView.setUint16(this.bytePosition, Number(value), true);\n        return this.shift(2);\n    }\n    /**\n     * Write a U32 value into a buffer and shift cursor position by 4.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    write32(value: number | bigint): this {\n        this.ensureSizeOrGrow(4);\n        this.dataView.setUint32(this.bytePosition, Number(value), true);\n        return this.shift(4);\n    }\n    /**\n     * Write a U64 value into a buffer and shift cursor position by 8.\n     * @param {bigint} value Value to write.\n     * @returns {this}\n     */\n    write64(value: number | bigint): this {\n        toLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n        return this;\n    }\n    /**\n     * Write a U128 value into a buffer and shift cursor position by 16.\n     *\n     * @param {bigint} value Value to write.\n     * @returns {this}\n     */\n    write128(value: number | bigint): this {\n        toLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n        return this;\n    }\n    /**\n     * Write a U256 value into a buffer and shift cursor position by 16.\n     *\n     * @param {bigint} value Value to write.\n     * @returns {this}\n     */\n    write256(value: number | bigint): this {\n        toLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n        return this;\n    }\n    /**\n     * Write a ULEB value into a buffer and shift cursor position by number of bytes\n     * written.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    writeULEB(value: number): this {\n        ulebEncode(value).forEach((el) => this.write8(el));\n        return this;\n    }\n    /**\n     * Write a vector into a buffer by first writing the vector length and then calling\n     * a callback on each passed value.\n     *\n     * @param {Array<Any>} vector Array of elements to write.\n     * @param {WriteVecCb} cb Callback to call on each element of the vector.\n     * @returns {this}\n     */\n    writeVec(\n        vector: any[],\n        cb: (writer: BcsWriter, el: any, i: number, len: number) => void,\n    ): this {\n        this.writeULEB(vector.length);\n        Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n        return this;\n    }\n\n    /**\n     * Adds support for iterations over the object.\n     * @returns {Uint8Array}\n     */\n    *[Symbol.iterator](): Iterator<number, Iterable<number>> {\n        for (let i = 0; i < this.bytePosition; i++) {\n            yield this.dataView.getUint8(i);\n        }\n        return this.toBytes();\n    }\n\n    /**\n     * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n     * @returns {Uint8Array} Resulting bcs.\n     */\n    toBytes(): Uint8Array {\n        return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n    }\n\n    /**\n     * Represent data as 'hex' or 'base64'\n     * @param encoding Encoding to use: 'base64' or 'hex'\n     */\n    toString(encoding: Encoding): string {\n        return encodeStr(this.toBytes(), encoding);\n    }\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n    const result = new Uint8Array(size);\n    let i = 0;\n    while (bigint > 0) {\n        result[i] = Number(bigint % BigInt(256));\n        bigint = bigint / BigInt(256);\n        i += 1;\n    }\n    return result;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1698, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/bcs/src/bcs-type.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, toBase58 } from './b58.js';\nimport { fromBase64, toBase64 } from './b64.js';\nimport { fromHex, toHex } from './hex.js';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\n\nexport interface BcsTypeOptions<T, Input = T> {\n    name?: string;\n    validate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n    $inferType!: T;\n    $inferInput!: Input;\n    name: string;\n    read: (reader: BcsReader) => T;\n    serializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n    validate: (value: Input) => void;\n    #write: (value: Input, writer: BcsWriter) => void;\n    #serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n    constructor(\n        options: {\n            name: string;\n            read: (reader: BcsReader) => T;\n            write: (value: Input, writer: BcsWriter) => void;\n            serialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n            serializedSize?: (value: Input) => number | null;\n            validate?: (value: Input) => void;\n        } & BcsTypeOptions<T, Input>,\n    ) {\n        this.name = options.name;\n        this.read = options.read;\n        this.serializedSize = options.serializedSize ?? (() => null);\n        this.#write = options.write;\n        this.#serialize =\n            options.serialize ??\n            ((value, options) => {\n                const writer = new BcsWriter({\n                    initialSize: this.serializedSize(value) ?? undefined,\n                    ...options,\n                });\n                this.#write(value, writer);\n                return writer.toBytes();\n            });\n\n        this.validate = options.validate ?? (() => {});\n    }\n\n    write(value: Input, writer: BcsWriter) {\n        this.validate(value);\n        this.#write(value, writer);\n    }\n\n    serialize(value: Input, options?: BcsWriterOptions) {\n        this.validate(value);\n        return new SerializedBcs(this, this.#serialize(value, options));\n    }\n\n    parse(bytes: Uint8Array): T {\n        const reader = new BcsReader(bytes);\n        return this.read(reader);\n    }\n\n    fromHex(hex: string) {\n        return this.parse(fromHex(hex));\n    }\n\n    fromBase58(b64: string) {\n        return this.parse(fromBase58(b64));\n    }\n\n    fromBase64(b64: string) {\n        return this.parse(fromBase64(b64));\n    }\n\n    transform<T2 = T, Input2 = Input>({\n        name,\n        input,\n        output,\n        validate,\n    }: {\n        input?: (val: Input2) => Input;\n        output?: (value: T) => T2;\n    } & BcsTypeOptions<T2, Input2>) {\n        return new BcsType<T2, Input2>({\n            name: name ?? this.name,\n            read: (reader) => (output ? output(this.read(reader)) : (this.read(reader) as never)),\n            write: (value, writer) => this.#write(input ? input(value) : (value as never), writer),\n            serializedSize: (value) => this.serializedSize(input ? input(value) : (value as never)),\n            serialize: (value, options) =>\n                this.#serialize(input ? input(value) : (value as never), options),\n            validate: (value) => {\n                validate?.(value);\n                this.validate(input ? input(value) : (value as never));\n            },\n        });\n    }\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@iota/serialized-bcs') as never;\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n    return !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n    #schema: BcsType<T, Input>;\n    #bytes: Uint8Array;\n\n    // Used to brand SerializedBcs so that they can be identified, even between multiple copies\n    // of the @iota/bcs package are installed\n    get [SERIALIZED_BCS_BRAND]() {\n        return true;\n    }\n\n    constructor(type: BcsType<T, Input>, schema: Uint8Array) {\n        this.#schema = type;\n        this.#bytes = schema;\n    }\n\n    toBytes() {\n        return this.#bytes;\n    }\n\n    toHex() {\n        return toHex(this.#bytes);\n    }\n\n    toBase64() {\n        return toBase64(this.#bytes);\n    }\n\n    toBase58() {\n        return toBase58(this.#bytes);\n    }\n\n    parse() {\n        return this.#schema.parse(this.#bytes);\n    }\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n    size,\n    ...options\n}: {\n    name: string;\n    size: number;\n    read: (reader: BcsReader) => T;\n    write: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n    return new BcsType<T, Input>({\n        ...options,\n        serializedSize: () => size,\n    });\n}\n\nexport function uIntBcsType({\n    readMethod,\n    writeMethod,\n    ...options\n}: {\n    name: string;\n    size: number;\n    readMethod: `read${8 | 16 | 32}`;\n    writeMethod: `write${8 | 16 | 32}`;\n    maxValue: number;\n} & BcsTypeOptions<number, number>) {\n    return fixedSizeBcsType<number>({\n        ...options,\n        read: (reader) => reader[readMethod](),\n        write: (value, writer) => writer[writeMethod](value),\n        validate: (value) => {\n            if (value < 0 || value > options.maxValue) {\n                throw new TypeError(\n                    `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n                );\n            }\n            options.validate?.(value);\n        },\n    });\n}\n\nexport function bigUIntBcsType({\n    readMethod,\n    writeMethod,\n    ...options\n}: {\n    name: string;\n    size: number;\n    readMethod: `read${64 | 128 | 256}`;\n    writeMethod: `write${64 | 128 | 256}`;\n    maxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n    return fixedSizeBcsType<string, string | number | bigint>({\n        ...options,\n        read: (reader) => reader[readMethod](),\n        write: (value, writer) => writer[writeMethod](BigInt(value)),\n        validate: (val) => {\n            const value = BigInt(val);\n            if (value < 0 || value > options.maxValue) {\n                throw new TypeError(\n                    `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n                );\n            }\n            options.validate?.(value);\n        },\n    });\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n    serialize,\n    ...options\n}: {\n    name: string;\n    read: (reader: BcsReader) => T;\n    serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n    const type = new BcsType<T, Input>({\n        ...options,\n        serialize,\n        write: (value, writer) => {\n            for (const byte of type.serialize(value).toBytes()) {\n                writer.write8(byte);\n            }\n        },\n    });\n\n    return type;\n}\n\nexport function stringLikeBcsType({\n    toBytes,\n    fromBytes,\n    ...options\n}: {\n    name: string;\n    toBytes: (value: string) => Uint8Array;\n    fromBytes: (bytes: Uint8Array) => string;\n    serializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n    return new BcsType<string>({\n        ...options,\n        read: (reader) => {\n            const length = reader.readULEB();\n            const bytes = reader.readBytes(length);\n\n            return fromBytes(bytes);\n        },\n        write: (hex, writer) => {\n            const bytes = toBytes(hex);\n            writer.writeULEB(bytes.length);\n            for (let i = 0; i < bytes.length; i++) {\n                writer.write8(bytes[i]);\n            }\n        },\n        serialize: (value) => {\n            const bytes = toBytes(value);\n            const size = ulebEncode(bytes.length);\n            const result = new Uint8Array(size.length + bytes.length);\n            result.set(size, 0);\n            result.set(bytes, size.length);\n\n            return result;\n        },\n        validate: (value) => {\n            if (typeof value !== 'string') {\n                throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n            }\n            options.validate?.(value);\n        },\n    });\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n    let lazyType: BcsType<T, Input> | null = null;\n    function getType() {\n        if (!lazyType) {\n            lazyType = cb();\n        }\n        return lazyType;\n    }\n\n    return new BcsType<T, Input>({\n        name: 'lazy' as never,\n        read: (data) => getType().read(data),\n        serializedSize: (value) => getType().serializedSize(value),\n        write: (value, writer) => getType().write(value, writer),\n        serialize: (value, options) => getType().serialize(value, options).toBytes(),\n    });\n}\n"],"names":["options"],"mappings":"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"}},
    {"offset": {"line": 1926, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/dapp-kit/node_modules/%40iota/bcs/src/bcs.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n    BcsType,\n    bigUIntBcsType,\n    dynamicSizeBcsType,\n    fixedSizeBcsType,\n    lazyBcsType,\n    stringLikeBcsType,\n    uIntBcsType,\n} from './bcs-type.js';\nimport type { EnumInputShape, EnumOutputShape } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n    /**\n     * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n     * @example\n     * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n     */\n    u8(options?: BcsTypeOptions<number>) {\n        return uIntBcsType({\n            name: 'u8',\n            readMethod: 'read8',\n            writeMethod: 'write8',\n            size: 1,\n            maxValue: 2 ** 8 - 1,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n     * @example\n     * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n     */\n    u16(options?: BcsTypeOptions<number>) {\n        return uIntBcsType({\n            name: 'u16',\n            readMethod: 'read16',\n            writeMethod: 'write16',\n            size: 2,\n            maxValue: 2 ** 16 - 1,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n     * @example\n     * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n     */\n    u32(options?: BcsTypeOptions<number>) {\n        return uIntBcsType({\n            name: 'u32',\n            readMethod: 'read32',\n            writeMethod: 'write32',\n            size: 4,\n            maxValue: 2 ** 32 - 1,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n     * @example\n     * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n     */\n    u64(options?: BcsTypeOptions<string, number | bigint | string>) {\n        return bigUIntBcsType({\n            name: 'u64',\n            readMethod: 'read64',\n            writeMethod: 'write64',\n            size: 8,\n            maxValue: 2n ** 64n - 1n,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n     * @example\n     * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n     */\n    u128(options?: BcsTypeOptions<string, number | bigint | string>) {\n        return bigUIntBcsType({\n            name: 'u128',\n            readMethod: 'read128',\n            writeMethod: 'write128',\n            size: 16,\n            maxValue: 2n ** 128n - 1n,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n     * @example\n     * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n     */\n    u256(options?: BcsTypeOptions<string, number | bigint | string>) {\n        return bigUIntBcsType({\n            name: 'u256',\n            readMethod: 'read256',\n            writeMethod: 'write256',\n            size: 32,\n            maxValue: 2n ** 256n - 1n,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write boolean values.\n     * @example\n     * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n     */\n    bool(options?: BcsTypeOptions<boolean>) {\n        return fixedSizeBcsType<boolean>({\n            name: 'bool',\n            size: 1,\n            read: (reader) => reader.read8() === 1,\n            write: (value, writer) => writer.write8(value ? 1 : 0),\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (typeof value !== 'boolean') {\n                    throw new TypeError(`Expected boolean, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n     * @example\n     *\n     */\n    uleb128(options?: BcsTypeOptions<number>) {\n        return dynamicSizeBcsType<number>({\n            name: 'uleb128',\n            read: (reader) => reader.readULEB(),\n            serialize: (value) => {\n                return Uint8Array.from(ulebEncode(value));\n            },\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a fixed length byte array\n     * @param size The number of bytes this types represents\n     * @example\n     * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n     */\n    bytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n        return fixedSizeBcsType<Uint8Array>({\n            name: `bytes[${size}]`,\n            size,\n            read: (reader) => reader.readBytes(size),\n            write: (value, writer) => {\n                for (let i = 0; i < size; i++) {\n                    writer.write8(value[i] ?? 0);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== size) {\n                    throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a variable length byte array\n     *\n     * @example\n     * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n     */\n    byteVector(options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n        return new BcsType<Uint8Array, Iterable<number>>({\n            name: `bytesVector`,\n            read: (reader) => {\n                const length = reader.readULEB();\n\n                return reader.readBytes(length);\n            },\n            write: (value, writer) => {\n                const array = new Uint8Array(value);\n                writer.writeULEB(array.length);\n                for (let i = 0; i < array.length; i++) {\n                    writer.write8(array[i] ?? 0);\n                }\n            },\n            ...options,\n            serializedSize: (value) => {\n                const length = 'length' in value ? (value.length as number) : null;\n                return length == null ? null : ulebEncode(length).length + length;\n            },\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n     * @example\n     * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n     */\n    string(options?: BcsTypeOptions<string>) {\n        return stringLikeBcsType({\n            name: 'string',\n            toBytes: (value) => new TextEncoder().encode(value),\n            fromBytes: (bytes) => new TextDecoder().decode(bytes),\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that represents a fixed length array of a given type\n     * @param size The number of elements in the array\n     * @param type The BcsType of each element in the array\n     * @example\n     * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n     */\n    fixedArray<T, Input>(\n        size: number,\n        type: BcsType<T, Input>,\n        options?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n    ) {\n        return new BcsType<T[], Iterable<Input> & { length: number }>({\n            name: `${type.name}[${size}]`,\n            read: (reader) => {\n                const result: T[] = new Array(size);\n                for (let i = 0; i < size; i++) {\n                    result[i] = type.read(reader);\n                }\n                return result;\n            },\n            write: (value, writer) => {\n                for (const item of value) {\n                    type.write(item, writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== size) {\n                    throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing an optional value\n     * @param type The BcsType of the optional value\n     * @example\n     * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n     * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n     */\n    option<T, Input>(type: BcsType<T, Input>) {\n        return bcs\n            .enum(`Option<${type.name}>`, {\n                None: null,\n                Some: type,\n            })\n            .transform({\n                input: (value: Input | null | undefined) => {\n                    if (value == null) {\n                        return { None: true };\n                    }\n\n                    return { Some: value };\n                },\n                output: (value) => {\n                    if (value.$kind === 'Some') {\n                        return value.Some;\n                    }\n\n                    return null;\n                },\n            });\n    },\n\n    /**\n     * Creates a BcsType representing a variable length vector of a given type\n     * @param type The BcsType of each element in the vector\n     *\n     * @example\n     * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n     */\n    vector<T, Input>(\n        type: BcsType<T, Input>,\n        options?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n    ) {\n        return new BcsType<T[], Iterable<Input> & { length: number }>({\n            name: `vector<${type.name}>`,\n            read: (reader) => {\n                const length = reader.readULEB();\n                const result: T[] = new Array(length);\n                for (let i = 0; i < length; i++) {\n                    result[i] = type.read(reader);\n                }\n                return result;\n            },\n            write: (value, writer) => {\n                writer.writeULEB(value.length);\n                for (const item of value) {\n                    type.write(item, writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a tuple of a given set of types\n     * @param types The BcsTypes for each element in the tuple\n     *\n     * @example\n     * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n     * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n     */\n    tuple<const Types extends readonly BcsType<any>[]>(\n        types: Types,\n        options?: BcsTypeOptions<\n            {\n                -readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n            },\n            {\n                [K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n            }\n        >,\n    ) {\n        return new BcsType<\n            {\n                -readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n            },\n            {\n                [K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n            }\n        >({\n            name: `(${types.map((t) => t.name).join(', ')})`,\n            serializedSize: (values) => {\n                let total = 0;\n                for (let i = 0; i < types.length; i++) {\n                    const size = types[i].serializedSize(values[i]);\n                    if (size == null) {\n                        return null;\n                    }\n\n                    total += size;\n                }\n\n                return total;\n            },\n            read: (reader) => {\n                const result: unknown[] = [];\n                for (const type of types) {\n                    result.push(type.read(reader));\n                }\n                return result as never;\n            },\n            write: (value, writer) => {\n                for (let i = 0; i < types.length; i++) {\n                    types[i].write(value[i], writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!Array.isArray(value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== types.length) {\n                    throw new TypeError(\n                        `Expected array of length ${types.length}, found ${value.length}`,\n                    );\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a struct of a given set of fields\n     * @param name The name of the struct\n     * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n     *\n     * @example\n     * const struct = bcs.struct('MyStruct', {\n     *  a: bcs.u8(),\n     *  b: bcs.string(),\n     * })\n     * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n     */\n    struct<T extends Record<string, BcsType<any>>>(\n        name: string,\n        fields: T,\n        options?: Omit<\n            BcsTypeOptions<\n                {\n                    [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n                },\n                {\n                    [K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n                }\n            >,\n            'name'\n        >,\n    ) {\n        const canonicalOrder = Object.entries(fields);\n\n        return new BcsType<\n            {\n                [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n            },\n            {\n                [K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n            }\n        >({\n            name,\n            serializedSize: (values) => {\n                let total = 0;\n                for (const [field, type] of canonicalOrder) {\n                    const size = type.serializedSize(values[field]);\n                    if (size == null) {\n                        return null;\n                    }\n\n                    total += size;\n                }\n\n                return total;\n            },\n            read: (reader) => {\n                const result: Record<string, unknown> = {};\n                for (const [field, type] of canonicalOrder) {\n                    result[field] = type.read(reader);\n                }\n\n                return result as never;\n            },\n            write: (value, writer) => {\n                for (const [field, type] of canonicalOrder) {\n                    type.write(value[field], writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (typeof value !== 'object' || value == null) {\n                    throw new TypeError(`Expected object, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing an enum of a given set of options\n     * @param name The name of the enum\n     * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n     * null can be used to represent a variant with no data.\n     *\n     * @example\n     * const enum = bcs.enum('MyEnum', {\n     *   A: bcs.u8(),\n     *   B: bcs.string(),\n     *   C: null,\n     * })\n     * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n     * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n     * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n     */\n    enum<T extends Record<string, BcsType<any> | null>>(\n        name: string,\n        values: T,\n        options?: Omit<\n            BcsTypeOptions<\n                EnumOutputShape<{\n                    [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n                }>,\n                EnumInputShape<{\n                    [K in keyof T]: T[K] extends BcsType<any, infer U>\n                        ? U\n                        : boolean | object | null;\n                }>\n            >,\n            'name'\n        >,\n    ) {\n        const canonicalOrder = Object.entries(values as object);\n        return new BcsType<\n            EnumOutputShape<{\n                [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n            }>,\n            EnumInputShape<{\n                [K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n            }>\n        >({\n            name,\n            read: (reader) => {\n                const index = reader.readULEB();\n\n                const enumEntry = canonicalOrder[index];\n                if (!enumEntry) {\n                    throw new TypeError(`Unknown value ${index} for enum ${name}`);\n                }\n\n                const [kind, type] = enumEntry;\n\n                return {\n                    [kind]: type?.read(reader) ?? true,\n                    $kind: kind,\n                } as never;\n            },\n            write: (value, writer) => {\n                const [name, val] = Object.entries(value).filter(([name]) =>\n                    Object.hasOwn(values, name),\n                )[0];\n\n                for (let i = 0; i < canonicalOrder.length; i++) {\n                    const [optionName, optionType] = canonicalOrder[i];\n                    if (optionName === name) {\n                        writer.writeULEB(i);\n                        optionType?.write(val, writer);\n                        return;\n                    }\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (typeof value !== 'object' || value == null) {\n                    throw new TypeError(`Expected object, found ${typeof value}`);\n                }\n\n                const keys = Object.keys(value).filter(\n                    (k) => value[k] !== undefined && Object.hasOwn(values, k),\n                );\n\n                if (keys.length !== 1) {\n                    throw new TypeError(\n                        `Expected object with one key, but found ${keys.length} for type ${name}}`,\n                    );\n                }\n\n                const [variant] = keys;\n\n                if (!Object.hasOwn(values, variant)) {\n                    throw new TypeError(`Invalid enum variant ${variant}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a map of a given key and value type\n     * @param keyType The BcsType of the key\n     * @param valueType The BcsType of the value\n     * @example\n     * const map = bcs.map(bcs.u8(), bcs.string())\n     * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n     */\n    map<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n        return bcs.vector(bcs.tuple([keyType, valueType])).transform({\n            name: `Map<${keyType.name}, ${valueType.name}>`,\n            input: (value: Map<InputK, InputV>) => {\n                return [...value.entries()];\n            },\n            output: (value) => {\n                const result = new Map<K, V>();\n                for (const [key, val] of value) {\n                    result.set(key, val);\n                }\n                return result;\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n     * @param cb A callback that returns the BcsType\n     */\n    lazy<T extends BcsType<any>>(cb: () => T): T {\n        return lazyBcsType(cb) as T;\n    },\n};\n"],"names":["name"],"mappings":"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"}},
    {"offset": {"line": 2408, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/iota-names-sdk/src/bcs.ts"],"sourcesContent":["// Copyright (c) 2025 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@iota/iota-sdk/bcs';\n\nexport const DummyFieldBcs = bcs.struct('DummyFieldObj', {\n    dummy_field: bcs.bool(),\n});\n\nexport const NameBcs = bcs.struct('Name', {\n    labels: bcs.vector(bcs.string()),\n});\n\nconst RangeBcs = bcs.struct('Range', {\n    from: bcs.u8(),\n    to: bcs.u8(),\n});\n\nconst CouponRulesBcs = bcs.struct('CouponRules', {\n    length: bcs.option(RangeBcs),\n    available_claims: bcs.option(bcs.u64()),\n    user: bcs.option(bcs.Address),\n    expiration: bcs.option(bcs.u64()),\n    years: bcs.option(RangeBcs),\n    can_stack: bcs.bool(),\n});\n\nexport const CouponHouseBcs = bcs.struct('CouponHouse', {\n    coupons: bcs.struct('Coupons', {\n        coupons: bcs.struct('Table', {\n            id: bcs.struct('UID', {\n                id: bcs.struct('ID', {\n                    bytes: bcs.Address,\n                }),\n            }),\n            size: bcs.u64(),\n        }),\n    }),\n    version: bcs.u8(),\n    id: bcs.struct('UID', {\n        id: bcs.struct('ID', {\n            bytes: bcs.Address,\n        }),\n    }),\n});\n\nexport const CouponBcs = bcs.struct('Coupon', {\n    kind: bcs.u8(),\n    amount: bcs.u64(),\n    rules: CouponRulesBcs,\n});\n"],"names":[],"mappings":";;;;;;;;;;AAGA,SAAS,WAAW;;AAEb,MAAM,gBAAgB,8LAAA,CAAI,MAAA,CAAO,iBAAiB;IACrD,aAAa,8LAAA,CAAI,IAAA,CAAK;AAC1B,CAAC;AAEM,MAAM,UAAU,8LAAA,CAAI,MAAA,CAAO,QAAQ;IACtC,QAAQ,8LAAA,CAAI,MAAA,CAAO,8LAAA,CAAI,MAAA,CAAO,CAAC;AACnC,CAAC;AAED,MAAM,WAAW,8LAAA,CAAI,MAAA,CAAO,SAAS;IACjC,MAAM,8LAAA,CAAI,EAAA,CAAG;IACb,IAAI,8LAAA,CAAI,EAAA,CAAG;AACf,CAAC;AAED,MAAM,iBAAiB,8LAAA,CAAI,MAAA,CAAO,eAAe;IAC7C,QAAQ,8LAAA,CAAI,MAAA,CAAO,QAAQ;IAC3B,kBAAkB,8LAAA,CAAI,MAAA,CAAO,8LAAA,CAAI,GAAA,CAAI,CAAC;IACtC,MAAM,8LAAA,CAAI,MAAA,CAAO,8LAAA,CAAI,OAAO;IAC5B,YAAY,8LAAA,CAAI,MAAA,CAAO,8LAAA,CAAI,GAAA,CAAI,CAAC;IAChC,OAAO,8LAAA,CAAI,MAAA,CAAO,QAAQ;IAC1B,WAAW,8LAAA,CAAI,IAAA,CAAK;AACxB,CAAC;AAEM,MAAM,iBAAiB,8LAAA,CAAI,MAAA,CAAO,eAAe;IACpD,SAAS,8LAAA,CAAI,MAAA,CAAO,WAAW;QAC3B,SAAS,8LAAA,CAAI,MAAA,CAAO,SAAS;YACzB,IAAI,8LAAA,CAAI,MAAA,CAAO,OAAO;gBAClB,IAAI,8LAAA,CAAI,MAAA,CAAO,MAAM;oBACjB,OAAO,8LAAA,CAAI,OAAA;gBACf,CAAC;YACL,CAAC;YACD,MAAM,8LAAA,CAAI,GAAA,CAAI;QAClB,CAAC;IACL,CAAC;IACD,SAAS,8LAAA,CAAI,EAAA,CAAG;IAChB,IAAI,8LAAA,CAAI,MAAA,CAAO,OAAO;QAClB,IAAI,8LAAA,CAAI,MAAA,CAAO,MAAM;YACjB,OAAO,8LAAA,CAAI,OAAA;QACf,CAAC;IACL,CAAC;AACL,CAAC;AAEM,MAAM,YAAY,8LAAA,CAAI,MAAA,CAAO,UAAU;IAC1C,MAAM,8LAAA,CAAI,EAAA,CAAG;IACb,QAAQ,8LAAA,CAAI,GAAA,CAAI;IAChB,OAAO;AACX,CAAC"}},
    {"offset": {"line": 2467, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/iota-names-sdk/src/constants.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2025 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nexport const MAX_U64 = BigInt('18446744073709551615');\nexport const MIN_LABEL_SIZE = 3;\nexport const GRACE_PERIOD_MS = 30 * 24 * 60 * 60 * 1000;\n\n/**\n * Allowed keys for metadata.\n */\nexport const ALLOWED_METADATA = {\n    avatar: 'avatar',\n    twitterX: 'twitter/x',\n    discord: 'discord',\n    github: 'github',\n    email: 'email',\n    btc: 'btc',\n    eth: 'eth',\n    ltc: 'ltc',\n    doge: 'doge',\n    sol: 'sol',\n    sui: 'sui',\n    website: 'website',\n    ipfs: 'ipfs',\n    arweave: 'arweave',\n};\n\nexport const packages = {\n    devnet: {\n        adminAddress: '0x1ca3c38e888493f869ac35346a2041d6cf87b0b935ebba14b35a08811d8a76e4',\n        adminCap: '0x5a45ba086c2a873b5d6d34e8503e8ca8850588bf7f301285e279c8dab94eeb73',\n        auctionPackageId: '0x79c8714ea294a92da04875c77ccabf8d1a06107e80d41c23d6777d5b1e6724a5',\n        auctionHouseObjectId: '0xc922c77a1d4f4e699aa912a7c24aee4668f8975d2a5f01ba780f656289bf2c2c',\n        coins: {\n            IOTA: {\n                type: '0x0000000000000000000000000000000000000000000000000000000000000002::iota::IOTA',\n                metadataId: '0xf7ceb0424ca93f77858c74aebda8bcd5ffe0f32b82ebcc38afb3ba643d03a5f8',\n            },\n        },\n        iotaNamesObjectId: '0x07c59b37bd7d036bf78fa30561a2ab9f7a970837487656ec29466e817f879342',\n        packageId: '0xb9d617f24c84826bf660a2f4031951678cc80c264aebc4413459fb2a95ada9ba',\n        paymentsPackageId: '0x98b9b33b7c2347a8f4e8b8716fb4c7e6e1af846ec2ea063a47bba81ffe03b440',\n        publisherId: '0xb9435d6c5f3a7bd85fa362b4b89262cf738d48774695e8e9955704ce0fd3526f',\n        registryTableId: '0xe00b2f2400c33b4dbd3081c4dcf2e289d0544caba23a3d130b264bd756403c07',\n        reverseRegistryTableId:\n            '0x1c1da17843cc453ad4079b05ce55e103b7a8cdd4db6ab42dc367b47ed6d8994d',\n        couponsPackageId: '0xf2d61106ef44216f03709276c4e79c78485080c6d8fbad8464b7a570b9f36470',\n        subnamesPackageId: '0x1efbf928710d0d92635dacff4c502516169d37fa006cabd2f3cdd0123221e09e',\n        tempSubnameProxyPackageId:\n            '0x4a16b7b2a9c194989519c87ee3f1d1007ece8aecb62b9a50a4c10075db0591a3',\n        upgradeCap: '0xd64205c4b10eff4b4adb00ab6f754cda8d8e7525985a31307f7e232481dfaf6e',\n    },\n    testnet: {\n        adminAddress: '0x548474360f9769077ccf07ff6e65060eb448470eabc1ae42b9ed371ddbfc23d2',\n        adminCap: '0x541b117cac18fb1c07a293db300acd12b05c01fa81232b37151b005ca7d4f755',\n        auctionPackageId: '0x6f727ea576a00036657fff0ae3a6d7c8171b178bf35112d6b83b2a6272cc5f0d',\n        auctionHouseObjectId: '0x2292ea885039babe8c320f19e0b7546ebdef2b2f6cf2be600bf994cdb51e0050',\n        coins: {\n            IOTA: {\n                type: '0x0000000000000000000000000000000000000000000000000000000000000002::iota::IOTA',\n                metadataId: '0x6dcda050874e2f160a008afc9e3ca6304a667cc85045e35f25b3c7967282b153',\n            },\n        },\n        iotaNamesObjectId: '0x7cab491740d51e0d75b26bf9984e49ba2e32a2d0694cabcee605543ed13c7dec',\n        packageId: '0x7fff6e95f385349bec98d17121ab2bfa3e134f2f0b1ccefc270313415f7835ea',\n        paymentsPackageId: '0x6b1b01f4c72786a893191d5c6e73d3012f7529f86fdee3bc8c163323cee08441',\n        publisherId: '0x42faed18f40323158fb9b0f38630800addc2e9eea696265756769fc1f0e08ceb',\n        registryTableId: '0x2dfc6f6d46ba55217425643a59dc85fe4d8ed273a9f74077bd0ee280dbb4f590',\n        reverseRegistryTableId:\n            '0x3550bcacb793ef8b776264665e7c99fa3d897695ed664656aac693cf9cf9b76b',\n        couponsPackageId: '0xa7e4e483d79c245470d5eb3c285a4503a78d90a69d36e35e0993012f5c6137ca',\n        subnamesPackageId: '0xd06a5607cc762f2352eeeb8c86c7f962558a06c6023c1eec031a41651d898c87',\n        tempSubnameProxyPackageId:\n            '0x7f34c135e55e5b436b3feaad369eabfe5b6d14c0c57544fefb6921db047e8cbc',\n        upgradeCap: '0x03ac547ee58c268a69b5663a1fdee0e8202206922968d2a387104730627d188e',\n    },\n    // TODO: Support Mainnet\n};\n"],"names":[],"mappings":";;;;;;;;;;;;AAIO,MAAM,UAAU,OAAO,sBAAsB;AAC7C,MAAM,iBAAiB;AACvB,MAAM,kBAAkB,KAAK,KAAK,KAAK,KAAK;AAK5C,MAAM,mBAAmB;IAC5B,QAAQ;IACR,UAAU;IACV,SAAS;IACT,QAAQ;IACR,OAAO;IACP,KAAK;IACL,KAAK;IACL,KAAK;IACL,MAAM;IACN,KAAK;IACL,KAAK;IACL,SAAS;IACT,MAAM;IACN,SAAS;AACb;AAEO,MAAM,WAAW;IACpB,QAAQ;QACJ,cAAc;QACd,UAAU;QACV,kBAAkB;QAClB,sBAAsB;QACtB,OAAO;YACH,MAAM;gBACF,MAAM;gBACN,YAAY;YAChB;QACJ;QACA,mBAAmB;QACnB,WAAW;QACX,mBAAmB;QACnB,aAAa;QACb,iBAAiB;QACjB,wBACI;QACJ,kBAAkB;QAClB,mBAAmB;QACnB,2BACI;QACJ,YAAY;IAChB;IACA,SAAS;QACL,cAAc;QACd,UAAU;QACV,kBAAkB;QAClB,sBAAsB;QACtB,OAAO;YACH,MAAM;gBACF,MAAM;gBACN,YAAY;YAChB;QACJ;QACA,mBAAmB;QACnB,WAAW;QACX,mBAAmB;QACnB,aAAa;QACb,iBAAiB;QACjB,wBACI;QACJ,kBAAkB;QAClB,mBAAmB;QACnB,2BACI;QACJ,YAAY;IAChB;AAEJ"}},
    {"offset": {"line": 2550, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/iota-names-sdk/src/coupons.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2025 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Coupon } from './types';\n\nexport const INVALID_YEARS = 'Coupon is not valid for the given number of years.';\nexport const INVALID_FOR_NAME_LENGTH = 'Coupon is not valid for the given name length.';\nexport const INVALID_PERCENTAGE = 'Invalid percentage amount for coupon.';\nexport const INVALID_USER = 'Coupon address does not match.';\nexport const COUPON_EXPIRED = 'Coupon has expired.';\nexport const INVALID_AVAILABLE_CLAIMS = 'Number of claims cannot be zero.';\nexport const NON_STACKING_COUPON = 'Coupon cannot be used with other coupons.';\n\nexport function validateCoupon(coupon: Coupon, years: number, length: number, address?: string) {\n    try {\n        hasAvailableClaims(coupon.rules);\n        isCouponValidForNameYears(coupon.rules, years);\n        // Percentage off coupon\n        if (coupon.kind === 0) {\n            isValidCouponPercentage(coupon.amount);\n        }\n        isCouponValidForNameLength(coupon.rules, length);\n        isCouponValidForAddress(coupon.rules, address);\n        isCouponExpired(coupon.rules);\n    } catch (error: unknown) {\n        throw new Error(\n            `Coupon '${coupon.couponCode}' validation failed: ${(error as Error)?.message}`,\n        );\n    }\n}\n\nexport function validateCoupons(\n    coupons: Coupon[],\n    years: number,\n    length: number,\n    address?: string,\n) {\n    for (const coupon of coupons) {\n        if (!coupon.rules.can_stack && coupons.length > 1) {\n            throw new Error(\n                `Coupon '${coupon.couponCode}' validation failed: ${NON_STACKING_COUPON}`,\n            );\n        }\n        validateCoupon(coupon, years, length, address);\n    }\n}\n\nexport function applyCouponsToPrice(coupons: Coupon[], initialPrice: number): number {\n    if (!coupons || coupons.length === 0) {\n        return initialPrice;\n    }\n\n    let price = initialPrice;\n\n    for (const coupon of coupons) {\n        if (!coupon.rules.can_stack && coupons.length > 1) {\n            throw new Error('Coupons provided cannot be stacked');\n        }\n\n        price = applyCouponToPrice(price, coupon);\n    }\n\n    return price;\n}\n\nexport function applyCouponToPrice(price: number, coupon?: Coupon): number {\n    if (!coupon) {\n        return price;\n    }\n\n    const couponAmount = Number(coupon.amount);\n\n    // 0 => percentage off\n    // 1 => fixed amount off,\n    if (coupon.kind === 0) {\n        let discountAmount = (price * couponAmount) / 100;\n        return price - discountAmount;\n    } else if (coupon.kind === 1) {\n        const discountedAmount = price - couponAmount;\n\n        return discountedAmount < 0 ? 0 : discountedAmount;\n    } else {\n        throw new Error(`Unknown coupon kind: ${coupon.kind}`);\n    }\n}\n\nexport function hasAvailableClaims(rules: { available_claims?: string | null }) {\n    if (\n        rules?.available_claims !== null &&\n        rules?.available_claims !== undefined &&\n        parseInt(rules?.available_claims) <= 0\n    ) {\n        throw new Error(INVALID_AVAILABLE_CLAIMS);\n    }\n}\n\nexport function isCouponValidForNameYears(\n    rules: { years?: { from: number; to: number } | null },\n    years: number,\n) {\n    const { from: minYears, to: maxYears } = rules.years || {};\n    if (minYears && maxYears && (years < minYears || years > maxYears)) {\n        throw new Error(INVALID_YEARS);\n    }\n}\n\nexport function isValidCouponPercentage(amount: string) {\n    if (parseInt(amount) <= 0 || parseInt(amount) > 100) {\n        throw new Error(INVALID_PERCENTAGE);\n    }\n}\n\nexport function isCouponValidForNameLength(\n    rules: { length?: { from: number; to: number } | null },\n    length: number,\n) {\n    const { from: minLength, to: maxLength } = rules.length || {};\n    if (minLength && maxLength && (length < minLength || length > maxLength)) {\n        throw new Error(INVALID_FOR_NAME_LENGTH);\n    }\n}\n\nexport function isCouponValidForAddress(rules: { user?: string | null }, userAddress?: string) {\n    if (rules.user && rules.user !== userAddress) {\n        throw new Error(INVALID_USER);\n    }\n}\n\nexport function isCouponExpired(\n    rules: { expiration?: string | null },\n    currentTimestamp: string = Date.now().toString(),\n) {\n    if (rules.expiration && Number(currentTimestamp) > Number(rules.expiration)) {\n        throw new Error(COUPON_EXPIRED);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMO,MAAM,gBAAgB;AACtB,MAAM,0BAA0B;AAChC,MAAM,qBAAqB;AAC3B,MAAM,eAAe;AACrB,MAAM,iBAAiB;AACvB,MAAM,2BAA2B;AACjC,MAAM,sBAAsB;AAE5B,SAAS,eAAe,MAAA,EAAgB,KAAA,EAAe,MAAA,EAAgB,OAAA,EAAkB;IAC5F,IAAI;QACA,mBAAmB,OAAO,KAAK;QAC/B,0BAA0B,OAAO,KAAA,EAAO,KAAK;QAE7C,IAAI,OAAO,IAAA,KAAS,GAAG;YACnB,wBAAwB,OAAO,MAAM;QACzC;QACA,2BAA2B,OAAO,KAAA,EAAO,MAAM;QAC/C,wBAAwB,OAAO,KAAA,EAAO,OAAO;QAC7C,gBAAgB,OAAO,KAAK;IAChC,EAAA,OAAS,OAAgB;QACrB,MAAM,IAAI,MACN,CAAA,QAAA,EAAW,OAAO,UAAU,CAAA,qBAAA,EAAyB,OAAiB,OAAO,EAAA;IAErF;AACJ;AAEO,SAAS,gBACZ,OAAA,EACA,KAAA,EACA,MAAA,EACA,OAAA,EACF;IACE,KAAA,MAAW,UAAU,QAAS;QAC1B,IAAI,CAAC,OAAO,KAAA,CAAM,SAAA,IAAa,QAAQ,MAAA,GAAS,GAAG;YAC/C,MAAM,IAAI,MACN,CAAA,QAAA,EAAW,OAAO,UAAU,CAAA,qBAAA,EAAwB,mBAAmB,EAAA;QAE/E;QACA,eAAe,QAAQ,OAAO,QAAQ,OAAO;IACjD;AACJ;AAEO,SAAS,oBAAoB,OAAA,EAAmB,YAAA,EAA8B;IACjF,IAAI,CAAC,WAAW,QAAQ,MAAA,KAAW,GAAG;QAClC,OAAO;IACX;IAEA,IAAI,QAAQ;IAEZ,KAAA,MAAW,UAAU,QAAS;QAC1B,IAAI,CAAC,OAAO,KAAA,CAAM,SAAA,IAAa,QAAQ,MAAA,GAAS,GAAG;YAC/C,MAAM,IAAI,MAAM,oCAAoC;QACxD;QAEA,QAAQ,mBAAmB,OAAO,MAAM;IAC5C;IAEA,OAAO;AACX;AAEO,SAAS,mBAAmB,KAAA,EAAe,MAAA,EAAyB;IACvE,IAAI,CAAC,QAAQ;QACT,OAAO;IACX;IAEA,MAAM,eAAe,OAAO,OAAO,MAAM;IAIzC,IAAI,OAAO,IAAA,KAAS,GAAG;QACnB,IAAI,iBAAkB,QAAQ,eAAgB;QAC9C,OAAO,QAAQ;IACnB,OAAA,IAAW,OAAO,IAAA,KAAS,GAAG;QAC1B,MAAM,mBAAmB,QAAQ;QAEjC,OAAO,mBAAmB,IAAI,IAAI;IACtC,OAAO;QACH,MAAM,IAAI,MAAM,CAAA,qBAAA,EAAwB,OAAO,IAAI,EAAE;IACzD;AACJ;AAEO,SAAS,mBAAmB,KAAA,EAA6C;IAC5E,IACI,OAAO,qBAAqB,QAC5B,OAAO,qBAAqB,KAAA,KAC5B,SAAS,OAAO,gBAAgB,KAAK,GACvC;QACE,MAAM,IAAI,MAAM,wBAAwB;IAC5C;AACJ;AAEO,SAAS,0BACZ,KAAA,EACA,KAAA,EACF;IACE,MAAM,EAAE,MAAM,QAAA,EAAU,IAAI,QAAA,CAAS,CAAA,GAAI,MAAM,KAAA,IAAS,CAAC;IACzD,IAAI,YAAY,YAAA,CAAa,QAAQ,YAAY,QAAQ,QAAA,GAAW;QAChE,MAAM,IAAI,MAAM,aAAa;IACjC;AACJ;AAEO,SAAS,wBAAwB,MAAA,EAAgB;IACpD,IAAI,SAAS,MAAM,KAAK,KAAK,SAAS,MAAM,IAAI,KAAK;QACjD,MAAM,IAAI,MAAM,kBAAkB;IACtC;AACJ;AAEO,SAAS,2BACZ,KAAA,EACA,MAAA,EACF;IACE,MAAM,EAAE,MAAM,SAAA,EAAW,IAAI,SAAA,CAAU,CAAA,GAAI,MAAM,MAAA,IAAU,CAAC;IAC5D,IAAI,aAAa,aAAA,CAAc,SAAS,aAAa,SAAS,SAAA,GAAY;QACtE,MAAM,IAAI,MAAM,uBAAuB;IAC3C;AACJ;AAEO,SAAS,wBAAwB,KAAA,EAAiC,WAAA,EAAsB;IAC3F,IAAI,MAAM,IAAA,IAAQ,MAAM,IAAA,KAAS,aAAa;QAC1C,MAAM,IAAI,MAAM,YAAY;IAChC;AACJ;AAEO,SAAS,gBACZ,KAAA,EACA,mBAA2B,KAAK,GAAA,CAAI,EAAE,QAAA,CAAS,CAAA,EACjD;IACE,IAAI,MAAM,UAAA,IAAc,OAAO,gBAAgB,IAAI,OAAO,MAAM,UAAU,GAAG;QACzE,MAAM,IAAI,MAAM,cAAc;IAClC;AACJ"}},
    {"offset": {"line": 2681, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/iota-names-sdk/src/utils.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2025 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nconst LABEL_REGEX = /(?!-)[a-z0-9-]{0,62}[a-z0-9]/;\nconst SUBNAME_REGEX = /^(?!-)[a-z0-9-]{1,62}[a-z0-9]$/;\nconst PATH_REGEX = new RegExp(`(?:${LABEL_REGEX.source}(?:\\\\.${LABEL_REGEX.source})*)`);\nconst NAME_AT_REGEX = new RegExp(`^(${PATH_REGEX.source})?@${LABEL_REGEX.source}$`);\nconst NAME_DOT_REGEX = new RegExp(`^(?:${LABEL_REGEX.source}\\\\.)+(iota)$`);\nconst MAX_LENGTH = 235;\n\nexport function isValidIotaName(name: string): boolean {\n    if (name.length > MAX_LENGTH) {\n        return false;\n    }\n\n    return NAME_AT_REGEX.test(name) || NAME_DOT_REGEX.test(name);\n}\n\nconst LONG_NAMES_TRUNCATE_LENGTH = 11;\nconst CHARACTERS_TO_SHOW = 6;\n\ninterface NormalizeOptions {\n    onlyFirstSubname?: boolean;\n    truncateLongParts?: boolean;\n    ellipsisForDeepSubnames?: boolean;\n}\n\nexport function normalizeIotaName(\n    name: string,\n    format: 'at' | 'dot' = 'at',\n    {\n        onlyFirstSubname,\n        truncateLongParts,\n        ellipsisForDeepSubnames = onlyFirstSubname === true,\n    }: NormalizeOptions = {},\n): string {\n    const lowerCase = name.toLowerCase();\n    let parts;\n\n    // Split in parts\n    if (NAME_AT_REGEX.test(lowerCase)) {\n        let [path, name] = lowerCase.split('@');\n        parts = [...(path ? path.split('.') : []), name];\n    } else if (NAME_DOT_REGEX.test(lowerCase)) {\n        parts = lowerCase.split('.').slice(0, -1);\n    } else {\n        throw new Error(`Invalid IOTA name \"${name}\"`);\n    }\n\n    const subnamesEllipsis = format === 'dot' ? '.' : '..';\n\n    // Only select the first subname if desired\n    let subnames =\n        onlyFirstSubname && parts.length >= 2\n            ? [\n                  // First name from the left (e.g yes.no.no.no.iota)\n                  parts[0],\n                  ellipsisForDeepSubnames && parts.length > 2 ? subnamesEllipsis : '',\n              ].filter(Boolean)\n            : parts.slice(0, -1);\n\n    let parentName = parts[parts.length - 1];\n\n    if (truncateLongParts) {\n        subnames = subnames.map((s) => {\n            return s.length > LONG_NAMES_TRUNCATE_LENGTH\n                ? `${s.slice(0, CHARACTERS_TO_SHOW)}...${s.slice(-CHARACTERS_TO_SHOW)}`\n                : s;\n        });\n\n        parentName =\n            parentName.length > LONG_NAMES_TRUNCATE_LENGTH\n                ? `${parentName.slice(0, CHARACTERS_TO_SHOW)}...${parentName.slice(-CHARACTERS_TO_SHOW)}`\n                : parentName;\n    }\n\n    // Construct name\n    if (format === 'dot') {\n        return `${[...subnames, parentName].join('.')}.iota`;\n    } else {\n        return `${subnames.join('.')}@${parentName}`;\n    }\n}\n\nexport function validateIotaSubname(\n    name: string,\n    minLength: number = 3,\n    maxLength: number = 64,\n): string | null {\n    if (!name) return null;\n    const lowerCase = name.toLowerCase();\n\n    if (name.length < minLength || name.length > maxLength) {\n        return `Name must be ${minLength}-${maxLength} characters long`;\n    }\n    if (!SUBNAME_REGEX.test(lowerCase)) {\n        return 'Invalid characters. Only a-z, 0-9, and hyphens (not at the beginning or end) are allowed';\n    }\n    return null;\n}\n\nexport function validateIotaName(\n    name: string,\n    minLength: number = 3,\n    maxLength: number = 64,\n    allowSubnames: boolean = true,\n): string | null {\n    if (!name) return null;\n    const lowerCase = name.toLowerCase();\n\n    const parts = lowerCase.split('.');\n\n    if (!allowSubnames && parts.length > 2) {\n        return 'No subnames allowed';\n    }\n    for (const part of parts.slice(0, -1)) {\n        if (part.length < minLength || part.length > maxLength) {\n            return `Name must be ${minLength}-${maxLength} characters long`;\n        }\n    }\n    if (!NAME_DOT_REGEX.test(name)) {\n        return 'Invalid characters. Only a-z, 0-9, and hyphens (not at the beginning or end) are allowed';\n    }\n    return null;\n}\n"],"names":["name"],"mappings":"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"}},
    {"offset": {"line": 2775, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/iota-names-sdk/src/helpers.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2025 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Transaction } from '@iota/iota-sdk/transactions';\n\nimport { normalizeIotaName } from './utils.js';\n\nexport function isSubname(name: string): boolean {\n    return normalizeIotaName(name, 'dot').split('.').length > 2;\n}\n\n/**\n * Checks if a name is a nested subname.\n * A nested subname is a subname that is a subname of another subname.\n * @param name The name to check (e.g test.example.sub.iota)\n */\nexport function isNestedSubname(name: string): boolean {\n    return normalizeIotaName(name, 'dot').split('.').length > 3;\n}\n\n/**\n * The years must be between 1 and 5.\n */\nexport function validateYears(years: number) {\n    if (!(years > 0 && years < 6)) throw new Error('Years must be between 1 and 5');\n}\n\nexport function zeroCoin(tx: Transaction, type: string) {\n    return tx.moveCall({\n        target: '0x2::coin::zero',\n        typeArguments: [type],\n    });\n}\n\nexport function getConfigType(iotaNamesPackageV1: string, innerType: string): string {\n    return `${iotaNamesPackageV1}::iota_names::ConfigKey<${innerType}>`;\n}\n\nexport function getNameType(iotaNamesPackageV1: string): string {\n    return `${iotaNamesPackageV1}::name::Name`;\n}\n\nexport function getPricelistConfigType(iotaNamesPackageId: string): string {\n    return `${iotaNamesPackageId}::pricing_config::PricingConfig`;\n}\n\nexport function getRenewalPricelistConfigType(iotaNamesPackageId: string): string {\n    return `${iotaNamesPackageId}::pricing_config::RenewalConfig`;\n}\n\nexport function getNameRegistrationType(iotaNamesPackageId: string): string {\n    return `${iotaNamesPackageId}::name_registration::NameRegistration`;\n}\n\nexport function getSubnameRegistrationType(iotaNamesPackageId: string): string {\n    return `${iotaNamesPackageId}::subname_registration::SubnameRegistration`;\n}\n\nexport function getCoreConfigType(iotaNamesPackageId: string): string {\n    return `${iotaNamesPackageId}::core_config::CoreConfig`;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAMA,SAAS,yBAAyB;;AAE3B,SAAS,UAAU,IAAA,EAAuB;IAC7C,WAAO,8LAAA,EAAkB,MAAM,KAAK,EAAE,KAAA,CAAM,GAAG,EAAE,MAAA,GAAS;AAC9D;AAOO,SAAS,gBAAgB,IAAA,EAAuB;IACnD,WAAO,8LAAA,EAAkB,MAAM,KAAK,EAAE,KAAA,CAAM,GAAG,EAAE,MAAA,GAAS;AAC9D;AAKO,SAAS,cAAc,KAAA,EAAe;IACzC,IAAI,CAAA,CAAE,QAAQ,KAAK,QAAQ,CAAA,EAAI,CAAA,MAAM,IAAI,MAAM,+BAA+B;AAClF;AAEO,SAAS,SAAS,EAAA,EAAiB,IAAA,EAAc;IACpD,OAAO,GAAG,QAAA,CAAS;QACf,QAAQ;QACR,eAAe;YAAC,IAAI;SAAA;IACxB,CAAC;AACL;AAEO,SAAS,cAAc,kBAAA,EAA4B,SAAA,EAA2B;IACjF,OAAO,GAAG,kBAAkB,CAAA,wBAAA,EAA2B,SAAS,CAAA,CAAA,CAAA;AACpE;AAEO,SAAS,YAAY,kBAAA,EAAoC;IAC5D,OAAO,GAAG,kBAAkB,CAAA,YAAA,CAAA;AAChC;AAEO,SAAS,uBAAuB,kBAAA,EAAoC;IACvE,OAAO,GAAG,kBAAkB,CAAA,+BAAA,CAAA;AAChC;AAEO,SAAS,8BAA8B,kBAAA,EAAoC;IAC9E,OAAO,GAAG,kBAAkB,CAAA,+BAAA,CAAA;AAChC;AAEO,SAAS,wBAAwB,kBAAA,EAAoC;IACxE,OAAO,GAAG,kBAAkB,CAAA,qCAAA,CAAA;AAChC;AAEO,SAAS,2BAA2B,kBAAA,EAAoC;IAC3E,OAAO,GAAG,kBAAkB,CAAA,2CAAA,CAAA;AAChC;AAEO,SAAS,kBAAkB,kBAAA,EAAoC;IAClE,OAAO,GAAG,kBAAkB,CAAA,yBAAA,CAAA;AAChC"}},
    {"offset": {"line": 2845, "column": 0}, "map": {"version":3,"sources":["file:///home/truongdo1z/marketplace/node_modules/%40iota/iota-names-sdk/src/iota-names-client.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2025 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@iota/iota-sdk/bcs';\nimport { IotaGraphQLClient } from '@iota/iota-sdk/graphql';\nimport { graphql } from '@iota/iota-sdk/graphql/schemas/2025.2';\nimport { fromB64, toB64 } from '@iota/iota-sdk/utils';\nimport { blake2b } from '@noble/hashes/blake2';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\n\nimport { CouponBcs, CouponHouseBcs, DummyFieldBcs, NameBcs } from './bcs.js';\nimport { ALLOWED_METADATA, packages } from './constants.js';\nimport { applyCouponsToPrice, validateCoupons } from './coupons.js';\nimport {\n    getConfigType,\n    getCoreConfigType,\n    getNameType,\n    getPricelistConfigType,\n    getRenewalPricelistConfigType,\n    isSubname,\n    validateYears,\n} from './helpers.js';\nimport type {\n    Coupon,\n    CouponHouse,\n    IotaNamesClientConfig,\n    IotaNamesCoreConfig,\n    IotaNamesPriceList,\n    NameRecord,\n    PackageInfo,\n} from './types.js';\nimport { isValidIotaName, normalizeIotaName, validateIotaName } from './utils.js';\n\n/// The IotaNamesClient is the main entry point for the IotaNames SDK.\n/// It allows you to interact with IOTA-Names.\nexport class IotaNamesClient {\n    graphQlClient: IotaGraphQLClient;\n    config: PackageInfo;\n\n    constructor(config: IotaNamesClientConfig) {\n        this.graphQlClient = config.graphQlClient;\n\n        if ('network' in config) {\n            this.config = packages[config.network as keyof typeof packages];\n        } else {\n            this.config = config.packageInfo;\n        }\n    }\n\n    /**\n     * Returns the core config of IOTA Names.\n     */\n    async getCoreConfig(): Promise<IotaNamesCoreConfig> {\n        if (!this.config.iotaNamesObjectId) throw new Error('IotaNames object ID is not set');\n        if (!this.config.packageId) throw new Error('IotaNames package ID is not set');\n\n        const coreConfigBcsB64 = toB64(\n            DummyFieldBcs.serialize({\n                dummy_field: false,\n            }).toBytes(),\n        );\n\n        const coreConfigResponse: any = await this.graphQlClient.query({\n            query: graphql(`\n                query getCoreConfig($parentId: IotaAddress!, $name: DynamicFieldName!) {\n                    owner(address: $parentId) {\n                        address\n                        dynamicField(name: $name) {\n                            value {\n                                ... on MoveValue {\n                                    json\n                                }\n                            }\n                        }\n                    }\n                }\n            `),\n            variables: {\n                parentId: this.config.iotaNamesObjectId,\n                name: {\n                    type: getConfigType(\n                        this.config.packageId,\n                        getCoreConfigType(this.config.packageId),\n                    ),\n                    bcs: coreConfigBcsB64,\n                },\n            },\n        });\n\n        const coreConfig = coreConfigResponse?.data?.owner?.dynamicField?.value?.json;\n\n        if (!coreConfig) {\n            throw new Error('Core config not found or is invalid');\n        }\n\n        return coreConfig;\n    }\n\n    /**\n     * Returns the price list for IOTA names in the base asset.\n     */\n    // Format:\n    // {\n    // \t[ 3, 3 ] => 500000000,\n    // \t[ 4, 4 ] => 100000000,\n    // \t[ 5, 63 ] => 20000000\n    // }\n    async getPriceList(): Promise<IotaNamesPriceList> {\n        if (!this.config.iotaNamesObjectId) throw new Error('IotaNames object ID is not set');\n        if (!this.config.packageId) throw new Error('IotaNames package ID is not set');\n\n        const pricingConfigBcsB64 = toB64(\n            DummyFieldBcs.serialize({\n                dummy_field: false,\n            }).toBytes(),\n        );\n\n        const priceListResponse: any = await this.graphQlClient.query({\n            query: graphql(`\n                query getPriceList($parentId: IotaAddress!, $name: DynamicFieldName!) {\n                    owner(address: $parentId) {\n                        address\n                        dynamicField(name: $name) {\n                            value {\n                                ... on MoveValue {\n                                    json\n                                }\n                            }\n                        }\n                    }\n                }\n            `),\n            variables: {\n                parentId: this.config.iotaNamesObjectId,\n                name: {\n                    type: getConfigType(\n                        this.config.packageId,\n                        getPricelistConfigType(this.config.packageId),\n                    ),\n                    bcs: pricingConfigBcsB64,\n                },\n            },\n        });\n\n        const priceList = priceListResponse?.data?.owner?.dynamicField?.value?.json?.pricing;\n        const contents = priceList?.contents;\n\n        // Ensure the content exists\n        if (!contents) {\n            throw new Error('Price list not found or content is invalid');\n        }\n\n        const priceMap = new Map();\n        for (const entry of contents) {\n            const { pos0, pos1 } = entry.key;\n            const key = [Number(pos0), Number(pos1)]; // Convert keys to numbers\n            const value = Number(entry.value); // Convert value to a number\n\n            priceMap.set(key, value);\n        }\n\n        return priceMap;\n    }\n\n    /**\n     * Returns the renewal price list for IOTA names in the base asset.\n     */\n    // Format:\n    // {\n    // \t[ 3, 3 ] => 500000000000,\n    // \t[ 4, 4 ] => 250000000000,\n    // \t[ 5, 63 ] => 50000000000\n    // }\n    async getRenewalPriceList(): Promise<IotaNamesPriceList> {\n        if (!this.config.iotaNamesObjectId) throw new Error('IotaNames object ID is not set');\n        if (!this.config.packageId) throw new Error('IotaNames package ID is not set');\n\n        const pricingConfigBcsB64 = toB64(\n            DummyFieldBcs.serialize({\n                dummy_field: false,\n            }).toBytes(),\n        );\n\n        const priceListResponse: any = await this.graphQlClient.query({\n            query: graphql(`\n                query getRenewalPriceList($parentId: IotaAddress!, $name: DynamicFieldName!) {\n                    owner(address: $parentId) {\n                        address\n                        dynamicField(name: $name) {\n                            value {\n                                ... on MoveValue {\n                                    json\n                                }\n                            }\n                        }\n                    }\n                }\n            `),\n            variables: {\n                parentId: this.config.iotaNamesObjectId,\n                name: {\n                    type: getConfigType(\n                        this.config.packageId,\n                        getRenewalPricelistConfigType(this.config.packageId),\n                    ),\n                    bcs: pricingConfigBcsB64,\n                },\n            },\n        });\n\n        const priceList =\n            priceListResponse?.data?.owner?.dynamicField?.value?.json?.config?.pricing;\n        const contents = priceList?.contents;\n\n        // Ensure the content exists\n        if (!contents) {\n            throw new Error('Price list not found or content is invalid');\n        }\n\n        const priceMap = new Map();\n        for (const entry of contents) {\n            const { pos0, pos1 } = entry.key;\n            const key = [Number(pos0), Number(pos1)]; // Convert keys to numbers\n            const value = Number(entry.value); // Convert value to a number\n\n            priceMap.set(key, value);\n        }\n\n        return priceMap;\n    }\n\n    async getDefaultName(address: string): Promise<string | null> {\n        const response: any = await this.graphQlClient.query({\n            query: graphql(`\n                query resolveNameServiceName($address: IotaAddress!, $nameFormat: NameFormat) {\n                    address(address: $address) {\n                        iotaNamesDefaultName(format: $nameFormat)\n                    }\n                }\n            `),\n            variables: {\n                address,\n            },\n        });\n\n        const defaultName = response?.data?.address?.iotaNamesDefaultName ?? null;\n\n        return defaultName;\n    }\n\n    async getNameRecord(name: string): Promise<NameRecord | null> {\n        if (!isValidIotaName(name)) throw new Error('Invalid IOTA name');\n        if (!this.config.registryTableId) throw new Error('IotaNames package ID is not set');\n\n        const nameBcsB64 = toB64(\n            NameBcs.serialize({\n                labels: normalizeIotaName(name, 'dot').split('.').reverse(),\n            }).toBytes(),\n        );\n\n        const nameRecordResponse: any = await this.graphQlClient.query({\n            query: graphql(`\n                query getNameRecord($parentId: IotaAddress!, $name: DynamicFieldName!) {\n                    owner(address: $parentId) {\n                        address\n                        dynamicField(name: $name) {\n                            value {\n                                ... on MoveValue {\n                                    json\n                                }\n                            }\n                        }\n                    }\n                }\n            `),\n            variables: {\n                parentId: this.config.registryTableId,\n                name: {\n                    type: getNameType(this.config.packageId),\n                    bcs: nameBcsB64,\n                },\n            },\n        });\n\n        const nameRecord = nameRecordResponse.data?.owner?.dynamicField?.value?.json;\n\n        // in case the name record is not found, return null\n        if (!nameRecord) return null;\n\n        const nameRecordData = nameRecord.data?.contents;\n\n        if (nameRecord.error || !nameRecordData)\n            throw new Error('Name record not found. This name is not registered.');\n\n        const data: Record<string, string> = {};\n\n        if (nameRecordData) {\n            nameRecordData.forEach((field: any) => {\n                if (field.key) {\n                    data[field.key as string] = field.value;\n                }\n            });\n        }\n\n        return {\n            name,\n            nftId: nameRecord?.nft_id,\n            targetAddress: nameRecord?.target_address!,\n            expirationTimestampMs: Number(nameRecord?.expiration_timestamp_ms),\n            data,\n            avatar: data[ALLOWED_METADATA.avatar],\n        };\n    }\n\n    async getCouponHouse(): Promise<CouponHouse> {\n        if (!this.config.iotaNamesObjectId) throw new Error('IotaNames object ID is not set');\n        if (!this.config.packageId) throw new Error('IotaNames package ID is not set');\n        if (!this.config.couponsPackageId) throw new Error('Coupon package ID is not set');\n\n        const iotaNamesObjectId = this.config.iotaNamesObjectId;\n        const packageId = this.config.packageId;\n        const couponsPackageId = this.config.couponsPackageId;\n\n        const DummyFieldB64 = DummyFieldBcs.serialize({ dummy_field: false }).toBase64();\n\n        const couponHouseResponse = await this.graphQlClient.query<{\n            owner: { dynamicField: { value: { bcs: string } } };\n        }>({\n            query: graphql(`\n                query getIotaNamesCouponHouseRegistryKey(\n                    $parentId: IotaAddress!\n                    $name: DynamicFieldName!\n                ) {\n                    owner(address: $parentId) {\n                        dynamicField(name: $name) {\n                            value {\n                                ... on MoveValue {\n                                    bcs\n                                }\n                            }\n                        }\n                    }\n                }\n            `),\n            variables: {\n                parentId: iotaNamesObjectId,\n                name: {\n                    type: `${packageId}::iota_names::RegistryKey<${couponsPackageId}::coupon_house::CouponHouse>`,\n                    bcs: DummyFieldB64,\n                },\n            },\n        });\n\n        const couponsHouseDynamicFieldBcsValue =\n            couponHouseResponse?.data?.owner?.dynamicField?.value?.bcs;\n\n        if (!couponsHouseDynamicFieldBcsValue) {\n            throw new Error('Coupon house not found or is invalid');\n        }\n\n        return CouponHouseBcs.parse(fromB64(couponsHouseDynamicFieldBcsValue));\n    }\n\n    async resolveCoupon(couponCode: string): Promise<Coupon | null> {\n        const couponHouse = await this.getCouponHouse();\n        const couponsTableId = couponHouse?.coupons?.coupons?.id.id.bytes;\n\n        if (!couponsTableId) {\n            throw new Error('Coupons table ID not found in the coupon house');\n        }\n\n        const couponCodeHash = bytesToHex(blake2b(couponCode, { dkLen: 32 }));\n        const couponCodeBytes = hexToBytes(couponCodeHash);\n\n        const couponCodeB64 = bcs.vector(bcs.u8()).serialize(couponCodeBytes).toBase64();\n\n        const couponResponse = await this.graphQlClient.query<{\n            owner: { dynamicField: { value: { bcs: string } } };\n        }>({\n            query: graphql(`\n                query getCouponBcs($parentId: IotaAddress!, $name: DynamicFieldName!) {\n                    owner(address: $parentId) {\n                        dynamicField(name: $name) {\n                            value {\n                                ... on MoveValue {\n                                    bcs\n                                }\n                            }\n                        }\n                    }\n                }\n            `),\n            variables: {\n                parentId: couponsTableId,\n                name: {\n                    type: 'vector<u8>',\n                    bcs: couponCodeB64,\n                },\n            },\n        });\n\n        const couponBcsBase64 = couponResponse?.data?.owner?.dynamicField?.value?.bcs;\n\n        if (!couponBcsBase64) {\n            return null;\n        }\n\n        const couponData = CouponBcs.parse(fromB64(couponBcsBase64));\n\n        return { ...couponData, couponCode };\n    }\n\n    /**\n     * Calculates the registration or renewal price for an SLN (Second Level Name).\n     * It expects a name, the number of years and a `IotaNamesPriceList` object,\n     * as returned from `iotaNamesClient.getPriceList()` function, or `iotaNames.getRenewalPriceList()` function.\n     *\n     * It throws an error:\n     * 1. if the name is a subname\n     * 2. if the name is not a valid IOTA name\n     * 3. if the years are not between 1 and 5\n     */\n    async calculatePrice({\n        name,\n        years,\n        isRegistration = true,\n    }: {\n        name: string;\n        years: number;\n        isRegistration?: boolean;\n    }) {\n        if (!isValidIotaName(name)) {\n            throw new Error('Invalid IOTA names');\n        }\n        validateYears(years);\n\n        if (isSubname(name)) {\n            throw new Error('Subnames do not have a registration fee');\n        }\n\n        const length = normalizeIotaName(name, 'dot').split('.')[0].length;\n        const priceList = await this.getPriceList();\n        const renewalPriceList = await this.getRenewalPriceList();\n        let yearsRemain = years;\n        let price = 0;\n\n        if (isRegistration) {\n            for (const [[minLength, maxLength], pricePerYear] of priceList.entries()) {\n                if (length >= minLength && length <= maxLength) {\n                    price += pricePerYear; // Registration is always 1 year\n                    yearsRemain -= 1;\n                    break;\n                }\n            }\n        }\n\n        for (const [[minLength, maxLength], pricePerYear] of renewalPriceList.entries()) {\n            if (length >= minLength && length <= maxLength) {\n                price += yearsRemain * pricePerYear;\n                break;\n            }\n        }\n\n        return price;\n    }\n\n    async calculateDiscountedPrice({\n        coupons,\n        name,\n        years,\n        isRegistration = true,\n        address,\n    }: {\n        coupons: Coupon[] | string[];\n        name: string;\n        years: number;\n        isRegistration?: boolean;\n        address?: string;\n    }) {\n        if (coupons.every((coupon) => typeof coupon === 'string')) {\n            const couponPromises = (coupons as string[]).map(async (couponCode) => {\n                const coupon = await this.resolveCoupon(couponCode);\n                if (!coupon) {\n                    throw new Error(`Coupon not found: ${couponCode}`);\n                }\n\n                return coupon;\n            });\n\n            coupons = (await Promise.all(couponPromises)) as Coupon[];\n        }\n\n        const normalizedName = normalizeIotaName(name, 'dot');\n\n        validateIotaName(normalizedName);\n\n        const nameParts = normalizedName.split('.');\n        const firstNamePart = nameParts[0];\n\n        validateCoupons(coupons, years, firstNamePart.length, address);\n\n        const standardPrice = await this.calculatePrice({\n            name,\n            years,\n            isRegistration,\n        });\n\n        return applyCouponsToPrice(coupons, standardPrice);\n    }\n}\n"],"names":[],"mappings":"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"}}]
}